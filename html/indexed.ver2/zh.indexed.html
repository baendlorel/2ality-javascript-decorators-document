<html lang="en-US">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>使用 2022-03 装饰器 API 进行 JavaScript 元编程</title>
  <link rel="stylesheet" href="../../css/main.css">
  <link rel="stylesheet" href="../../css/highlight.css">
  <link rel="stylesheet" href="../../css/toggle-lang.css">
</head>

<body>
  <div id="page-core-content" class="number-headings">
    <h1 data-en="1">使用 2022-03 装饰器 API 进行 JavaScript 元编程</h1>
    <div>
      <p data-en="2">JavaScript 装饰器终于进入了 <a href="https://exploringjs.com/js/book/ch_history.html#tc39-process">第 3 阶段</a>！最新版本已经被 Babel 支持，<a href="#decorator-implementations">很快也会被 TypeScript 支持</a>。</p>
      <p data-en="3">本文介绍了 ECMAScript 提案 <a href="https://github.com/tc39/proposal-decorators">“Decorators”</a>（2022-03 版本，第 3 阶段），作者为 Daniel Ehrenberg 和 Chris Garrett。</p>
      <p data-en="4">装饰器是以 <code>@</code> 符号开头的关键字，可以用于类和类成员（如方法）前。例如，<code>@trace</code> 就是一个装饰器：</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  @trace
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'C'</span>;
  }
}
</code>
</pre>
      <p data-en="5">装饰器会改变被装饰结构的行为。在这个例子中，每次调用 <code>.toString()</code> 都会被“追踪”（参数和结果会被输出到控制台）。<a href="#example-tracing-method-invocations">稍后我们会看到 <code>@trace</code> 的实现。</a></p>
      <!--more-->
      <p data-en="6">装饰器主要是面向对象的特性，在 Ember、Angular、Vue、Web 组件框架和 MobX 等 OOP 框架和库中非常流行。</p>
      <p data-en="7">关于装饰器，有两个相关角色：</p>
      <ul>
        <li data-en="8">库作者需要了解装饰器 API，以便实现它们。</li>
        <li data-en="9">库使用者只需知道如何应用装饰器。</li>
      </ul>
      <p data-en="10">本文主要面向库作者：我们将学习装饰器的工作原理，并用这些知识实现几个装饰器。</p>
      <nav class="table-of-contents">
        <ul>
          <li>
            <kskb data-en="11" style="display: block;">
              <a href="#history-of-decorators">装饰器的历史（可选章节）</a>

            </kskb>
            <ul>
              <li data-en="12">
                <a href="#the-history-of-decorators">装饰器的历史</a>
              </li>
              <li data-en="13">
                <a href="#the-history-of-babel%E2%80%99s-decorator-implementation">Babel 装饰器实现的历史</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="14" style="display: block;">
              <a href="#what-are-decorators%3F">什么是装饰器？</a>

            </kskb>
            <ul>
              <li data-en="15">
                <a href="#the-shape-of-decorator-functions">装饰器函数的结构</a>
              </li>
              <li data-en="16">
                <a href="#what-can-decorators-do%3F">装饰器能做什么？</a>
              </li>
              <li data-en="17">
                <a href="#summary-tables">总结表格</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="18" style="display: block;">
              <a href="#more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)">装饰器语法与语义的更多信息（可选章节）</a>

            </kskb>
            <ul>
              <li data-en="19">
                <a href="#the-syntax-of-decorator-expressions">装饰器表达式的语法</a>
              </li>
              <li data-en="20">
                <a href="#how-are-decorators-executed%3F">装饰器如何执行？</a>
              </li>
              <li data-en="21">
                <a href="#decorator-initializer-execution">装饰器初始化器何时运行？</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="22" style="display: block;">
              <a href="#techniques-for-exposing-data-from-decorators">装饰器暴露数据的技巧</a>

            </kskb>
            <ul>
              <li data-en="23">
                <a href="#storing-exposed-data-in-a-surrounding-scope">在外部作用域存储暴露的数据</a>
              </li>
              <li data-en="24">
                <a href="#managing-exposed-data-via-a-factory-function">通过工厂函数管理暴露的数据</a>
              </li>
              <li data-en="25">
                <a href="#managing-exposed-data-via-a-class">通过类管理暴露的数据</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="26" style="display: block;">
              <a href="#class-decorators">类装饰器</a>

            </kskb>
            <ul>
              <li data-en="27">
                <a href="#example%3A-collecting-instances">示例：收集实例</a>
              </li>
              <li data-en="28">
                <a href="#making-sure-that-instanceof-works">确保 <code>instanceof</code> 正常工作</a>
              </li>
              <li data-en="29">
                <a href="#example-freezing-instances">示例：冻结实例</a>
              </li>
              <li data-en="30">
                <a href="#example%3A-making-classes-function-callable">示例：让类可函数调用</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="31" style="display: block;">
              <a href="#class-method-decorators">类方法装饰器</a>

            </kskb>
            <ul>
              <li data-en="32">
                <a href="#example-tracing-method-invocations">示例：追踪方法调用</a>
              </li>
              <li data-en="33">
                <a href="#example%3A-binding-methods-to-instances">示例：将方法绑定到实例</a>
              </li>
              <li data-en="34">
                <a href="#example%3A-applying-functions-to-methods">示例：对方法应用函数</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="35" style="display: block;">
              <a href="#class-getter-decorators%2C-class-setter-decorators">类 getter 装饰器、setter 装饰器</a>

            </kskb>
            <ul>
              <li data-en="36">
                <a href="#example%3A-computing-values-lazily">示例：惰性计算值</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="37" style="display: block;">
              <a href="#class-field-decorators">类字段装饰器</a>
            </kskb>
            <ul>
              <li data-en="38">
                <a href="#example%3A-changing-initialization-values-of-fields">示例：改变字段初始化值</a>
              </li>
              <li data-en="39">
                <a href="#read-only-fields">示例：只读字段（实例公有字段）</a>
              </li>
              <li data-en="40">
                <a href="#example%3A-dependency-injection-(instance-public-fields)">示例：依赖注入（实例公有字段）</a>
              </li>
              <li data-en="41">
                <a href="#example-friend-visibility">示例：“友元”可见性（实例私有字段）</a>
              </li>
              <li data-en="42">
                <a href="#example%3A-enums-(static-public-fields)">示例：枚举（静态公有字段）</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="43" style="display: block;">
              <a href="#auto-accessors">自动访问器：类定义的新成员</a>
            </kskb>
            <ul>
              <li data-en="44">
                <a href="#why-are-auto-accessors-needed%3F">为什么需要自动访问器？</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="45" style="display: block;">
              <a href="#class-auto-accessor-decorators">类自动访问器装饰器</a>

            </kskb>
            <ul>
              <li data-en="46">
                <a href="#read-only-auto-accessors">示例：只读自动访问器</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="47" style="display: block;">
              <a href="#faq">常见问题</a>

            </kskb>
            <ul>
              <li data-en="48">
                <a href="#function-decorators">为什么函数不能被装饰？</a>
              </li>
            </ul>
          </li>
          <li data-en="49">
            <a href="#more-decorator-related-proposals">更多与装饰器相关的提案</a>
          </li>
          <li>
            <kskb data-en="50" style="display: block;">
              <a href="#resources">资源</a>

            </kskb>
            <ul>
              <li data-en="51">
                <a href="#decorator-implementations">实现</a>
              </li>
              <li data-en="52">
                <a href="#libraries-with-decorators">带装饰器的库</a>
              </li>
            </ul>
          </li>
          <li data-en="53">
            <a href="#acknowledgements">致谢</a>
          </li>
          <li data-en="54">
            <a href="#further-reading">延伸阅读</a>
          </li>
        </ul>
      </nav>
      <h2 id="history-of-decorators" tabindex="-1" data-en="55">装饰器的历史（可选章节）&nbsp;&nbsp;<a class="heading-anchor" href="#history-of-decorators" aria-hidden="true">#</a></h2>
      <p data-en="56">（本章节为可选内容。如果您跳过此章节，仍然可以理解后续内容。）</p>
      <p data-en="57">让我们从装饰器的历史开始。主要回答以下两个问题：</p>
      <ul>
        <li data-en="58">为什么这个提案花了这么长时间？</li>
        <li data-en="59">为什么感觉 JavaScript 似乎已经有装饰器很多年了？</li>
      </ul>
      <h3 id="the-history-of-decorators" tabindex="-1" data-en="60">装饰器的历史&nbsp;&nbsp;<a class="heading-anchor" href="#the-history-of-decorators" aria-hidden="true">#</a></h3>
      <p data-en="61">以下历史描述了：</p>
      <ul>
        <li data-en="62">各个团体如何在各自的项目中工作，并在 TC39 提案上进行协作。</li>
        <li data-en="63">TC39 提案如何通过 <a href="https://exploringjs.com/js/book/ch_history.html#tc39-process">TC39 过程</a> 的各个阶段（从 0 开始，到 4 结束，提案准备添加到 ECMAScript 中）。在此过程中，提案经历了多次变更。</li>
      </ul>
      <p data-en="64">以下是相关事件的时间顺序：</p>
      <ul>
        <li>
          <kskb data-en="65" style="display: block;">
            <p data-en="66"><a href="https://github.com/tc39/notes/blob/main/meetings/2014-04/apr-10.md">2014-04-10</a>：Yehuda Katz 向 TC39 提出了装饰器提案。该提案晋升为第 0 阶段。</p>
          </kskb>
          <ul>
            <li data-en="67">Katz 的提案是与 Ron Buckton 合作创建的。关于该提案的讨论可以追溯到 <a href="https://twitter.com/rbuckton/status/1581292852532813825">2013 年 7 月</a>。</li>
          </ul>
        </li>
        <li>
          <kskb data-en="68" style="display: block;">
            <p data-en="69">2014-10-22（ngEurope 大会，巴黎）：Angular 团队宣布 Angular 2.0 正在使用 AtScript 编写，并编译为 JavaScript（通过 Traceur）和 Dart。计划包括基于 TypeScript 的 AtScript，同时添加：</p>
          </kskb>
          <ul>
            <li>
              <kskb data-en="70" style="display: block;">三种类型的 <em>注解</em>：
              </kskb>
              <ul>
                <li data-en="71"><em>类型注解</em></li>
                <li data-en="72"><em>字段注解</em> 显式声明字段。</li>
                <li data-en="73"><em>元数据注解</em> 语法与装饰器相同，但仅添加元数据，不改变被注解结构的工作方式。</li>
              </ul>
            </li>
            <li data-en="74">运行时类型检查</li>
            <li data-en="75">类型反射</li>
          </ul>
        </li>
        <li>
          <p data-en="77"><a href="https://github.com/tc39/notes/blob/main/meetings/2015-01/jan-28.md">2015-01-28</a>：Yehuda Katz 和 Jonathan Turner 报告说 Katz 和 TypeScript 团队正在交流想法。</p>
        </li>
        <li>
          <p data-en="79">2015-03-05（ng-conf，盐湖城）：Angular 团队和 TypeScript 团队宣布 Angular 将从 AtScript 切换到 TypeScript，并且 TypeScript 将采用 AtScript 的一些特性（特别是装饰器）。</p>
        </li>
        <li>
          <p data-en="81"><a href="https://github.com/tc39/notes/blob/main/meetings/2015-03/mar-24.md">2015-03-24</a>：装饰器提案进入第 1 阶段。彼时，他们在 GitHub 上有 <a href="https://github.com/wycats/javascript-decorators">一个仓库</a>（由 Yehuda Katz 创建），后来迁移到 <a href="https://github.com/tc39/proposal-decorators">当前所在位置</a>。</p>
        </li>
        <li>
          <p data-en="83">2015-07-20：<a href="https://devblogs.microsoft.com/typescript/announcing-typescript-1-5/">TypeScript 1.5</a> 发布，支持通过 <a href="https://www.typescriptlang.org/docs/handbook/decorators.html">第 1 阶段装饰器</a>，需开启标志 <code>--experimentalDecorators</code>。</p>
          <p data-en="84">多个 JavaScript 项目（如 Angular 和 MobX）使用了这个 TypeScript 特性，这使得 JavaScript 看起来已经有装饰器。</p>
          <p data-en="85">到目前为止，TypeScript 尚未支持更新版本的装饰器 API。<a href="https://github.com/microsoft/TypeScript/pull/50820">Ron Buckton 的一个拉取请求提供了对第 3 阶段装饰器的支持</a>，可能会在 v4.9 之后的版本中发布。</p>
        </li>
        <li>
          <p data-en="87"><a href="https://github.com/tc39/notes/blob/main/meetings/2016-07/jul-28.md">2016-07-28</a>：在 Yehuda Katz 和 Brian Terlson 的介绍后，提案进入第 2 阶段。</p>
        </li>
        <li>
          <p data-en="89"><a href="https://github.com/tc39/notes/blob/main/meetings/2017-07/jul-27.md">2017-07-27</a>：Daniel Ehrenberg 在几个月前加入提案后首次进行了装饰器的介绍。他推动了提案的演变，持续了好几年。</p>
        </li>
        <li>
          <p data-en="91">随后，Chris Garrett 加入了提案，并帮助其进入第 3 阶段，该阶段发生在 <a href="https://github.com/tc39/notes/blob/main/meetings/2022-03/mar-28.md">2022-03-28</a>。装饰器元数据被移至 <a href="https://github.com/tc39/proposal-decorator-metadata">一个单独的提案</a>，该提案从第 2 阶段开始。</p>
        </li>
      </ul>
      <p data-en="92">之所以花了很长时间才进入第 3 阶段，是因为很难让所有利益相关者就 API 达成一致。人们关心的包括与其他特性（如类成员和私有状态）的相互作用以及性能等问题。</p>
      <h3 id="the-history-of-babel%E2%80%99s-decorator-implementation" tabindex="-1" data-en="93">Babel 装饰器实现的历史&nbsp;&nbsp;<a class="heading-anchor" href="#the-history-of-babel%E2%80%99s-decorator-implementation" aria-hidden="true">#</a></h3>
      <p data-en="94">Babel 紧密跟踪了装饰器提案的演变，这要感谢 Logan Smyth、Nicolò Ribaudo 和其他人的努力：</p>
      <ul>
        <li>
          <p data-en="96"><a href="https://babeljs.io/blog/2015/03/31/5.0.0">2015-03-31</a>：Babel 5.0.0 支持第 1 阶段装饰器。</p>
        </li>
        <li>
          <p data-en="98"><a href="https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy">2015-11-29</a> Logan Smyth 的一个外部插件将第 1 阶段装饰器带到了 Babel 6。</p>
        </li>
        <li>
          <p data-en="100"><a href="https://babeljs.io/blog/2018/08/27/7.0.0">2018-08-27</a> Babel 7.0.0 通过官方的 <code>@babel/plugin-proposal-decorators</code> 支持第 2 阶段装饰器。</p>
        </li>
        <li>
          <kskb data-en="101" style="display: block;">
            <p data-en="102">官方插件目前支持 <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators#version">以下版本</a>：</p>

          </kskb>
          <ul>
            <li data-en="103"><code>"legacy"</code>: <a href="https://github.com/wycats/javascript-decorators/blob/e1bf8d41bfa2591d949dd3bbf013514c8904b913/README.md">第 1 阶段装饰器</a></li>
            <li data-en="104"><code>"2018-09"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/7fa580b40f2c19c561511ea2c978e307ae689a1b">第 2 阶段装饰器</a></li>
            <li data-en="105"><code>"2021-12"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/d6c056fa061646178c34f361bad33d583316dc85">第 2 阶段装饰器的更新版本</a></li>
            <li data-en="106"><code>"2022-03"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/8ca65c046dd5e9aa3846a1fe5df343a6f7efd9f8">第 3 阶段装饰器</a></li>
          </ul>
        </li>
      </ul>
      <h2 id="what-are-decorators%3F" tabindex="-1" data-en="107">什么是装饰器？&nbsp;&nbsp;<a class="heading-anchor" href="#what-are-decorators%3F" aria-hidden="true">#</a></h2>
      <p data-en="108">装饰器让我们可以改变 JavaScript 结构（如类和方法）的工作方式。让我们回顾一下使用装饰器 <code>@trace</code>:</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  @trace
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'C'</span>;
  }
}
</code></pre>
      <p data-en="109">要实现 <code>@trace</code>，我们只需编写一个函数 （<a href="#example-tracing-method-invocations">确切的实现稍后会展示</a>）：</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trace</span>(<span class="hljs-params">decoratedMethod</span>) {
  <span class="hljs-comment">// 返回一个替换 `decoratedMethod` 的函数。</span>
}
</code></pre>
      <p data-en="110">带有装饰器方法的类大致等同于以下代码：</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'C'</span>;
  }
}
C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-title function_">trace</span>(C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>);
</code></pre>
      <p data-en="111">换句话说：装饰器是一个可以应用于语言结构的函数。我们通过在它们前面加上 <code>@</code> 和它的名字来实现这一点。</p>
      <p data-en="112">编写和使用装饰器是<em>元编程</em>：</p>
      <ul>
        <li data-en="113">我们不直接编写处理用户数据的代码（<em>编程</em>）。</li>
        <li data-en="114">我们编写一种生成代码的东西，生成的代码可以用来处理用户数据（<em>元编程</em>）。</li>
      </ul>
      <p data-en="115">有关元编程的更多信息，请参见“深度 JavaScript”中的<a href="https://exploringjs.com/deep-js/ch_proxies.html#programming-vs-metaprogramming">“编程与元编程”部分</a>。</p>
      <h3 id="the-shape-of-decorator-functions" tabindex="-1" data-en="116">The shape of decorator functions&nbsp;&nbsp;<a class="heading-anchor" href="#the-shape-of-decorator-functions" aria-hidden="true">#</a></h3>
      <p data-en="117">在我们探索装饰器函数的示例之前，我想先看看它们的 TypeScript 类型签名：</p>
      <pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Decorator</span> = <span class="hljs-function">(<span class="hljs-params">
  <span class="hljs-attr">value</span>: <span class="hljs-title class_">DecoratedValue</span>, <span class="hljs-comment">// 字段不同</span>
  <span class="hljs-attr">context</span>: {
    kind: <span class="hljs-built_in">string</span>;
    name: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>;
    addInitializer(initializer: () =&gt; <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>;

    // Don’t always exist:
    <span class="hljs-keyword">static</span>: <span class="hljs-built_in">boolean</span>;
    <span class="hljs-keyword">private</span>: <span class="hljs-built_in">boolean</span>;
    access: {get: () =&gt; <span class="hljs-built_in">unknown</span>, set: (value: <span class="hljs-built_in">unknown</span>) =&gt; <span class="hljs-built_in">void</span>};
  }
</span>) =&gt;</span> <span class="hljs-built_in">void</span> | <span class="hljs-title class_">ReplacementValue</span>; <span class="hljs-comment">// 仅字段不同</span>
</code></pre>
      <p data-en="118">也就是说，装饰器就是一个函数。它的参数是：</p>
      <ul>
        <li data-en="119">装饰器应用于的 <code>value</code>。</li>
        <li>
          <kskb data-en="120" style="display: block;">包含 <code>value</code> 附加信息的对象 <code>context</code>，具有：
          </kskb>
          <ul>
            <li data-en="121">关于 <code>value</code> 的附加信息（<code>.static</code>、<code>.private</code>）</li>
            <li data-en="122">一个小型 API（<code>.access</code>、<code>.addInitializer</code>），具有元编程功能</li>
          </ul>
        </li>
      </ul>
      <p data-en="123">属性 <code>.kind</code> 告诉装饰器它被应用于哪种类型的 JavaScript 结构。我们可以对多种结构使用相同的函数。</p>
      <p data-en="124">目前，装饰器可以应用于类、方法、getter、setter、字段和 <em><a href="#auto-accessors">自动访问器</a></em>（稍后将解释的一种新类成员）。<code>.kind</code> 的值反映了这一点： </p>
      <ul>
        <li><code>'class'</code></li>
        <li><code>'method'</code></li>
        <li><code>'getter'</code></li>
        <li><code>'setter'</code></li>
        <li><code>'accessor'</code></li>
        <li><code>'field'</code></li>
      </ul>
      <p data-en="131">以下是 <code>Decorator</code> 的确切类型：</p>
      <pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Decorator</span> =
  | <span class="hljs-title class_">ClassDecorator</span>
  | <span class="hljs-title class_">ClassMethodDecorator</span>
  | <span class="hljs-title class_">ClassGetterDecorator</span>
  | <span class="hljs-title class_">ClassSetterDecorator</span>
  | <span class="hljs-title class_">ClassAutoAccessorDecorator</span>
  | <span class="hljs-title class_">ClassFieldDecorator</span>
;
</code></pre>
      <p data-en="132">我们很快会遇到这些装饰器及其类型签名 – 只有这些部分会有所不同：</p>
      <ul>
        <li data-en="133"><code>value</code> 的类型</li>
        <li data-en="134"><code>context</code> 的某些属性</li>
        <li data-en="135">返回类型</li>
      </ul>
      <h3 id="what-can-decorators-do%3F" tabindex="-1" data-en="136">装饰器能做什么？&nbsp;&nbsp;<a class="heading-anchor" href="#what-can-decorators-do%3F" aria-hidden="true">#</a></h3>
      <p data-en="137">每个装饰器最多有四种能力：</p>
      <ul>
        <li>
          <p data-en="139">通过改变参数 <code>value</code> 来改变被装饰的实体。</p>
        </li>
        <li>
          <kskb data-en="140" style="display: block;">
            <p data-en="141">通过返回兼容的值来替换被装饰的实体：</p>
          </kskb>
          <ul>
            <li data-en="142">“兼容”&nbsp;意味着返回的值必须与被装饰值具有相同的类型 – 例如，类装饰器必须返回可调用的值。</li>
            <li data-en="143">如果装饰器不想替换被装饰的值，它可以返回 <code>undefined</code> – 可以是显式返回，也可以是通过不返回任何内容隐式返回。</li>
          </ul>
        </li>
        <li>
          <p data-en="145">向其他人暴露对被装饰实体的访问。<code>context.access</code> 使其能够通过其方法 <code>.get()</code> 和 <code>.set()</code> 来实现。</p>
        </li>
        <li>
          <p data-en="147">在被装饰实体及其容器（如果有的话）存在后处理它们：该功能由 <code>context.addInitializer</code> 提供。它允许装饰器注册一个 <em>初始化器</em> – 在一切准备就绪时调用的回调（更多细节在<a href="#decorator-initializer-execution">稍后解释</a>）。</p>
        </li>
      </ul>
      <p data-en="148">接下来的小节将演示这些能力。起初我们不会使用 <code>context.kind</code> 来检查装饰器应用于哪种类型的构造。稍后我们会这样做。</p>
      <h4 id="ability%3A-replacing-the-decorated-entity" tabindex="-1" data-en="149">能力：替换被装饰实体&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-replacing-the-decorated-entity" aria-hidden="true">#</a></h4>
      <p data-en="150">在下面的示例中，装饰器 <code>@replaceMethod</code> 用它返回的函数替换了方法 <code>.hello()</code>（B 行）。</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">replaceMethod</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-comment">// (A)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">`How are you, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>?`</span>;
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
  @replaceMethod
  <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">// (B)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>!`</span>;
  }
}

<span class="hljs-keyword">const</span> robin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Robin'</span>);
assert.<span class="hljs-title function_">equal</span>(
  robin.<span class="hljs-title function_">hello</span>(), <span class="hljs-string">'How are you, Robin?'</span>
);
</code></pre>
      <h4 id="ability%3A-exposing-access-to-the-decorated-entity-to-others" tabindex="-1" data-en="151">能力：向其他人暴露对被装饰实体的访问&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-exposing-access-to-the-decorated-entity-to-others" aria-hidden="true">#</a></h4>
      <p data-en="152">在下一个示例中，装饰器 <code>@exposeAccess</code> 将一个对象存储在变量 <code>acc</code> 中，使我们能够访问 <code>Color</code> 实例的 <code>.green</code> 属性。</p>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> acc;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">exposeAccess</span>(<span class="hljs-params">_value, {access}</span>) {
  acc = access;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {
  @exposeAccess
  name = <span class="hljs-string">'green'</span>
}

<span class="hljs-keyword">const</span> green = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>();
assert.<span class="hljs-title function_">equal</span>(
  green.<span class="hljs-property">name</span>, <span class="hljs-string">'green'</span>
);
<span class="hljs-comment">// 使用 `acc` 获取和设置 `green.name`</span>
assert.<span class="hljs-title function_">equal</span>(
  acc.<span class="hljs-property">get</span>.<span class="hljs-title function_">call</span>(green), <span class="hljs-string">'green'</span>
);
acc.<span class="hljs-property">set</span>.<span class="hljs-title function_">call</span>(green, <span class="hljs-string">'red'</span>);
assert.<span class="hljs-title function_">equal</span>(
  green.<span class="hljs-property">name</span>, <span class="hljs-string">'red'</span>
);
</code></pre>
      <h4 id="ability%3A-processing-the-decorated-entity-and-its-container" tabindex="-1" data-en="153">能力：处理被装饰实体及其容器&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-processing-the-decorated-entity-and-its-container" aria-hidden="true">#</a></h4>
      <p data-en="154">在以下代码中，我们使用装饰器 <code>@collect</code> 将被装饰方法的键存储在实例属性 <code>.collectedMethodKeys</code> 中：</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">collect</span>(<span class="hljs-params">_value, {name, addInitializer}</span>) {
  <span class="hljs-title function_">addInitializer</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-comment">// (A)</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">collectedMethodKeys</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">collectedMethodKeys</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">collectedMethodKeys</span>.<span class="hljs-title function_">add</span>(name);
  });
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  @collect
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {}
  @collect
  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() {}
}
<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();
assert.<span class="hljs-title function_">deepEqual</span>(
  inst.<span class="hljs-property">collectedMethodKeys</span>,
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'toString'</span>, <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>])
);
</code></pre>
      <p data-en="155">在 A 行添加的初始化函数必须是普通函数，因为需要访问隐式参数 <code>this</code>。箭头函数无法提供此访问权限 – 它们的 <code>this</code> 是静态作用域的（像任何普通变量一样）。</p>
      <h3 id="summary-tables" tabindex="-1" data-en="156">总结表格&nbsp;&nbsp;<a class="heading-anchor" href="#summary-tables" aria-hidden="true">#</a></h3>
      <p data-en="157">类型签名：</p>
      <table class="framed" data-en="158">
        <thead>
          <tr>
            <th>装饰器种类</th>
            <th><code>(input) =&gt; output</code></th>
            <th><code>.access</code></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Class</td>
            <td><code>(func) =&gt; func2</code></td>
            <td>–</td>
          </tr>
          <tr>
            <td>Method</td>
            <td><code>(func) =&gt; func2</code></td>
            <td><code>{get}</code></td>
          </tr>
          <tr>
            <td>Getter</td>
            <td><code>(func) =&gt; func2</code></td>
            <td><code>{get}</code></td>
          </tr>
          <tr>
            <td>Setter</td>
            <td><code>(func) =&gt; func2</code></td>
            <td><code>{set}</code></td>
          </tr>
          <tr>
            <td>Auto-accessor</td>
            <td><code>({get,set}) =&gt; {get,set,init}</code></td>
            <td><code>{get,set}</code></td>
          </tr>
          <tr>
            <td>Field</td>
            <td><code>() =&gt; (initValue)=&gt;initValue2</code></td>
            <td><code>{get,set}</code></td>
          </tr>
        </tbody>
      </table>
      <p data-en="159">函数中 <code>this</code> 的值：</p>
      <table class="framed" data-en="160">
        <thead>
          <tr>
            <th><code>this</code> 是 →</th>
            <th><code>undefined</code></th>
            <th>Class</th>
            <th>Instance</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Decorator function</td>
            <td>✔</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>Static initializer</td>
            <td></td>
            <td>✔</td>
            <td></td>
          </tr>
          <tr>
            <td>Non-static initializer</td>
            <td></td>
            <td></td>
            <td>✔</td>
          </tr>
          <tr>
            <td>Static field decorator result</td>
            <td></td>
            <td>✔</td>
            <td></td>
          </tr>
          <tr>
            <td>Non-static field decorator result</td>
            <td></td>
            <td></td>
            <td>✔</td>
          </tr>
        </tbody>
      </table>
      <h2 id="more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)" tabindex="-1" data-en="161">装饰器语法与语义的更多信息（可选章节）&nbsp;&nbsp;<a class="heading-anchor" href="#more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)" aria-hidden="true">#</a></h2>
      <p data-en="162">(本章节为可选内容。如果您跳过此章节，仍然可以理解后续内容。)</p>
      <h3 id="the-syntax-of-decorator-expressions" tabindex="-1" data-en="163">装饰器表达式的语法&nbsp;&nbsp;<a class="heading-anchor" href="#the-syntax-of-decorator-expressions" aria-hidden="true">#</a></h3>
      <ul>
        <li data-en="164">装饰器表达式以一个或多个标识符的链开始，标识符之间用点分隔。除第一个标识符外，每个标识符都可以是私有的（前缀为 <code>#</code>）。不允许使用方括号 <code>[]</code>。</li>
        <li data-en="165">可选：末尾可以加上括号中的函数调用参数。下一小节将解释这意味着什么。</li>
        <li data-en="166">如果我们把它放在括号中，我们可以使用任何表达式：
          <pre><code class="language-js">@(«expr»)
              </code></pre>
        </li>
      </ul>
      <p data-en="167">无论装饰器允许在哪里，我们都可以使用多个装饰器。以下代码演示了装饰器语法</p>
      <pre><code class="language-js"><span class="hljs-comment">// 五个 MyClass 的装饰器</span>

@myFunc
@<span class="hljs-title function_">myFuncFactory</span>(<span class="hljs-string">'arg1'</span>, <span class="hljs-string">'arg2'</span>)

@libraryModule.<span class="hljs-property">prop</span>
@someObj.<span class="hljs-title function_">method</span>(<span class="hljs-number">123</span>)

@(<span class="hljs-title function_">wrap</span>(dict[<span class="hljs-string">'prop'</span>])) <span class="hljs-comment">// 任意表达式</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {}
</code></pre>
      <h3 id="how-are-decorators-executed%3F" tabindex="-1" data-en="168">装饰器如何执行？&nbsp;&nbsp;<a class="heading-anchor" href="#how-are-decorators-executed%3F" aria-hidden="true">#</a></h3>
      <ul>
        <li>
          <p data-en="170">评估：<code>@</code> 符号后面的表达式在类定义的执行过程中被评估，与计算属性键和静态字段一起（见代码）。结果必须是函数。它们被存储在临时位置（可以认为是局部变量），以便稍后调用。</p>
        </li>
        <li>
          <p data-en="172">调用：装饰器函数在类定义的执行过程中稍后被调用，在方法被评估后，但在构造函数和原型被组装之前。结果再次存储在临时位置。</p>
        </li>
        <li>
          <p data-en="174">应用：在所有装饰器函数被调用后，使用它们的结果，这可能会影响构造函数和原型。类装饰器在所有方法和字段装饰器之后应用。</p>
        </li>
      </ul>
      <p data-en="175">以下代码说明了装饰器表达式、计算属性键和字段初始化器的评估顺序：</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">decorate</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`EVALUATE @decorate(): <span class="hljs-subst">${str}</span>`</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`APPLY @decorate(): <span class="hljs-subst">${str}</span>`</span>); <span class="hljs-comment">// (A)</span>
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);
  <span class="hljs-keyword">return</span> str;
}

@<span class="hljs-title function_">decorate</span>(<span class="hljs-string">'class'</span>)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TheClass</span> {

  @<span class="hljs-title function_">decorate</span>(<span class="hljs-string">'static field'</span>)
  <span class="hljs-keyword">static</span> staticField = <span class="hljs-title function_">log</span>(<span class="hljs-string">'static field value'</span>);

  @<span class="hljs-title function_">decorate</span>(<span class="hljs-string">'prototype method'</span>)
  [<span class="hljs-title function_">log</span>(<span class="hljs-string">'computed key'</span>)]() {}

  @<span class="hljs-title function_">decorate</span>(<span class="hljs-string">'instance field'</span>)
  instanceField = <span class="hljs-title function_">log</span>(<span class="hljs-string">'instance field value'</span>);
    <span class="hljs-comment">// 仅在我们实例化类时，此初始化器才会运行</span>
}

<span class="hljs-comment">// Output:</span>
<span class="hljs-comment">// EVALUATE @decorate(): class</span>
<span class="hljs-comment">// EVALUATE @decorate(): static field</span>
<span class="hljs-comment">// EVALUATE @decorate(): prototype method</span>
<span class="hljs-comment">// computed key</span>
<span class="hljs-comment">// EVALUATE @decorate(): instance field</span>
<span class="hljs-comment">// APPLY @decorate(): prototype method</span>
<span class="hljs-comment">// APPLY @decorate(): static field</span>
<span class="hljs-comment">// APPLY @decorate(): instance field</span>
<span class="hljs-comment">// APPLY @decorate(): class</span>
<span class="hljs-comment">// static field value</span>
</code></pre>
      <p data-en="176">函数 <code>decorate</code> 在每次评估 <code>decorate()</code> 表达式时被调用。在 A行，它返回实际的装饰器函数，该函数稍后会被应用。</p>
      <h3 id="decorator-initializer-execution" tabindex="-1" data-en="177">装饰器初始化器何时运行？&nbsp;&nbsp;<a class="heading-anchor" href="#decorator-initializer-execution" aria-hidden="true">#</a></h3>
      <p data-en="178">装饰器初始化器的运行时间取决于装饰器的种类：</p>
      <ul>
        <li>
          <p data-en="180">类装饰器初始化器在类完全定义并且所有静态字段初始化后运行。</p>
        </li>
        <li>
          <p data-en="182">非静态类元素装饰器的初始化器在实例化期间运行，在实例字段初始化之前。</p>
        </li>
        <li>
          <p data-en="184">静态类元素装饰器的初始化器在类定义期间运行，在静态字段定义之前，但在所有其他类元素定义之后。</p>
        </li>
      </ul>
      <p data-en="185">为什么会这样？对于非静态初始化器，我们有五个选项 – 它们可以在以下时机运行：</p>
      <ol>
        <li data-en="186">在 <code>super</code> 之前</li>
        <li data-en="187">在 <code>super</code> 之后，字段初始化之前</li>
        <li data-en="188">按定义顺序交错在字段之间</li>
        <li data-en="189">在字段初始化之后，子类实例化之前</li>
        <li data-en="190">在子类实例化之后</li>
      </ol>
      <p data-en="191">为什么选择了第 2 种方案？</p>
      <ul>
        <li>
          <p data-en="193">第 1 种方案被拒绝，因为装饰器初始化器必须能够访问 <code>this</code>，而在 <code>super</code> 运行之前无法做到这一点。</p>
        </li>
        <li>
          <p data-en="195">第 3 种方案被拒绝，因为同时运行所有装饰器初始化器比确保它们正确交错要简单。</p>
        </li>
      </ul>
      <ul>
        <li>
          <p data-en="197">第 4 种方案被拒绝，因为在字段之前运行装饰器初始化器可以确保字段在被装饰方法完全初始化之前不会被访问。例如，如果有 <code>@bind</code> 装饰器，则字段初始化器可以依赖于被装饰的方法已被绑定。</p>
        </li>
        <li>
          <p data-en="199">第 5 种方案被拒绝，因为它允许超类干扰子类，这会破坏超类不应意识到其子类的规则。</p>
        </li>
      </ul>
      <p data-en="200">以下代码演示了 Babel 当前如何调用装饰器初始化器。请注意，Babel 尚不支持类字段装饰器的初始化器（这是对装饰器 API 的最近更改）。</p>
      <pre><code class="language-js"><span class="hljs-comment">// 我们在记录步骤时等待实例化后,</span>
<span class="hljs-comment">// 这样我们就可以将`this`的值与实例进行比较。</span>
<span class="hljs-keyword">const</span> steps = [];
<span class="hljs-keyword">function</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">msg, _this</span>) {
  steps.<span class="hljs-title function_">push</span>({msg, _this});
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">pushStr</span>(<span class="hljs-params">str</span>) {
  steps.<span class="hljs-title function_">push</span>(str);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">_value, {name, addInitializer}</span>) {
  <span class="hljs-title function_">pushStr</span>(<span class="hljs-string">`@init <span class="hljs-subst">${name}</span>`</span>);
  <span class="hljs-keyword">if</span> (addInitializer) {
    <span class="hljs-title function_">addInitializer</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-title function_">push</span>(<span class="hljs-string">`DECORATOR INITIALIZER <span class="hljs-subst">${name}</span>`</span>, <span class="hljs-variable language_">this</span>);
    });
  }
}

@init <span class="hljs-keyword">class</span> <span class="hljs-title class_">TheClass</span> {
  <span class="hljs-comment">//--- Static ---</span>

  <span class="hljs-keyword">static</span> {
    <span class="hljs-title function_">pushStr</span>(<span class="hljs-string">'static block'</span>);
  }

  @init <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params"></span>) {}
  @init <span class="hljs-keyword">static</span> accessor staticAcc = <span class="hljs-title function_">pushStr</span>(<span class="hljs-string">'staticAcc'</span>);
  @init <span class="hljs-keyword">static</span> staticField = <span class="hljs-title function_">pushStr</span>(<span class="hljs-string">'staticField'</span>);

  <span class="hljs-comment">//--- Non-static ---</span>

  @init <span class="hljs-title function_">prototypeMethod</span>(<span class="hljs-params"></span>) {}
  @init accessor instanceAcc = <span class="hljs-title function_">pushStr</span>(<span class="hljs-string">'instanceAcc'</span>);
  @init instanceField = <span class="hljs-title function_">pushStr</span>(<span class="hljs-string">'instanceField'</span>);

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">pushStr</span>(<span class="hljs-string">'constructor'</span>);
  }
}

<span class="hljs-title function_">pushStr</span>(<span class="hljs-string">'===== 实例化 ====='</span>);
<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TheClass</span>();

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> step <span class="hljs-keyword">of</span> steps) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> step === <span class="hljs-string">'string'</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(step);
    <span class="hljs-keyword">continue</span>;
  }
  <span class="hljs-keyword">let</span> thisDesc = <span class="hljs-string">'???'</span>;
  <span class="hljs-keyword">if</span> (step.<span class="hljs-property">_this</span> === <span class="hljs-title class_">TheClass</span>) {
    thisDesc = <span class="hljs-title class_">TheClass</span>.<span class="hljs-property">name</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (step.<span class="hljs-property">_this</span> === inst) {
    thisDesc = <span class="hljs-string">'inst'</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (step.<span class="hljs-property">_this</span> === <span class="hljs-literal">undefined</span>) {
    thisDesc = <span class="hljs-string">'undefined'</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${step.msg}</span> (this===<span class="hljs-subst">${thisDesc}</span>)`</span>);
}

<span class="hljs-comment">// Output:</span>
<span class="hljs-comment">// @init staticMethod</span>
<span class="hljs-comment">// @init staticAcc</span>
<span class="hljs-comment">// @init prototypeMethod</span>
<span class="hljs-comment">// @init instanceAcc</span>
<span class="hljs-comment">// @init staticField</span>
<span class="hljs-comment">// @init instanceField</span>
<span class="hljs-comment">// @init TheClass</span>
<span class="hljs-comment">// DECORATOR INITIALIZER staticMethod (this===TheClass)</span>
<span class="hljs-comment">// DECORATOR INITIALIZER staticAcc (this===TheClass)</span>
<span class="hljs-comment">// static block</span>
<span class="hljs-comment">// staticAcc</span>
<span class="hljs-comment">// staticField</span>
<span class="hljs-comment">// DECORATOR INITIALIZER TheClass (this===TheClass)</span>
<span class="hljs-comment">// ===== Instantiation =====</span>
<span class="hljs-comment">// DECORATOR INITIALIZER prototypeMethod (this===inst)</span>
<span class="hljs-comment">// DECORATOR INITIALIZER instanceAcc (this===inst)</span>
<span class="hljs-comment">// instanceAcc</span>
<span class="hljs-comment">// instanceField</span>
<span class="hljs-comment">// constructor</span>
</code></pre>
      <h2 id="techniques-for-exposing-data-from-decorators" tabindex="-1" data-en="201">装饰器暴露数据的技巧&nbsp;&nbsp;<a class="heading-anchor" href="#techniques-for-exposing-data-from-decorators" aria-hidden="true">#</a></h2>
      <p data-en="202">有时装饰器会收集数据。让我们探索它们如何将这些数据提供给其他方。</p>
      <h3 id="storing-exposed-data-in-a-surrounding-scope" tabindex="-1" data-en="203">在外部作用域存储暴露的数据&nbsp;&nbsp;<a class="heading-anchor" href="#storing-exposed-data-in-a-surrounding-scope" aria-hidden="true">#</a></h3>
      <p data-en="204">最简单的解决方案是将数据存储在外部作用域的某个位置。例如，装饰器 <code>@collect</code> 收集类并将它们存储在 Set <code>classes</code> 中（A 行）：</p>
      <pre><code class="language-js"><span class="hljs-keyword">const</span> classes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(); <span class="hljs-comment">// (A)</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">collect</span>(<span class="hljs-params">value, {kind, addInitializer}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'class'</span>) {
    classes.<span class="hljs-title function_">add</span>(value);
  }
}

@collect
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {}
@collect
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> {}
@collect
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {}

assert.<span class="hljs-title function_">deepEqual</span>(
  classes, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([A, B, C])
);
</code></pre>
      <p data-en="205">此方法的缺点是，如果装饰器来自另一个模块，则此方法无效。</p>
      <h3 id="managing-exposed-data-via-a-factory-function" tabindex="-1" data-en="206">通过工厂函数管理暴露的数据&nbsp;&nbsp;<a class="heading-anchor" href="#managing-exposed-data-via-a-factory-function" aria-hidden="true">#</a></h3>
      <p data-en="207">一种更复杂的方法是使用工厂函数 <code>createClassCollector()</code>，该函数返回：</p>
      <ul>
        <li data-en="208">一个类装饰器 <code>collect</code></li>
        <li data-en="209">一个 Set <code>classes</code>，装饰器将把收集到的类添加到其中</li>
      </ul>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createClassCollector</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> classes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">collect</span>(<span class="hljs-params">value, {kind, addInitializer}</span>) {
    <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'class'</span>) {
      classes.<span class="hljs-title function_">add</span>(value);
    }
  }
  <span class="hljs-keyword">return</span> {
    classes,
    collect,
  };
}

<span class="hljs-keyword">const</span> {classes, collect} = <span class="hljs-title function_">createClassCollector</span>();

@collect
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {}
@collect
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> {}
@collect
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {}

assert.<span class="hljs-title function_">deepEqual</span>(
  classes, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([A, B, C])
);
</code></pre>
      <h3 id="managing-exposed-data-via-a-class" tabindex="-1" data-en="210">通过类管理暴露的数据&nbsp;&nbsp;<a class="heading-anchor" href="#managing-exposed-data-via-a-class" aria-hidden="true">#</a></h3>
      <p data-en="211">我们也可以使用类来代替工厂函数。它有两个成员：</p>
      <ul>
        <li data-en="212"><code>.classes</code>，一个包含收集到的类的 Set</li>
        <li data-en="213"><code>.install</code>，一个类装饰器</li>
      </ul>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassCollector</span> {
  classes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
  install = <span class="hljs-function">(<span class="hljs-params">value, {kind}</span>) =&gt;</span> { <span class="hljs-comment">// (A)</span>
    <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'class'</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">classes</span>.<span class="hljs-title function_">add</span>(value); <span class="hljs-comment">// (B)</span>
    }
  };
}

<span class="hljs-keyword">const</span> collector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassCollector</span>();

@collector.<span class="hljs-property">install</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {}
@collector.<span class="hljs-property">install</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> {}
@collector.<span class="hljs-property">install</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {}

assert.<span class="hljs-title function_">deepEqual</span>(
  collector.<span class="hljs-property">classes</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([A, B, C])
);
</code></pre>
      <p data-en="214">我们通过将一个箭头函数分配给公共实例字段来实现 <code>.install</code>（A 行）。实例字段初始化器在 <code>this</code> 指向当前实例的作用域中运行。这也是箭头函数的外部作用域，解释了为什么 <code>this</code> 在 B 行具有该值。</p>
      <p data-en="215">我们也可以通过 getter 来实现 <code>.install</code>，但那样的话，每次读取 <code>.install</code> 时都必须返回一个新函数。</p>
      <h2 id="class-decorators" tabindex="-1" data-en="216">类装饰器&nbsp;&nbsp;<a class="heading-anchor" href="#class-decorators" aria-hidden="true">#</a></h2>
      <p data-en="217">类装饰器具有以下类型签名：</p>
      <pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ClassDecorator</span> = <span class="hljs-function">(<span class="hljs-params">
  <span class="hljs-attr">value</span>: <span class="hljs-title class_">Function</span>,
  <span class="hljs-attr">context</span>: {
    kind: <span class="hljs-string">'class'</span>;
    name: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;
    addInitializer(initializer: () =&gt; <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_">Function</span> | <span class="hljs-built_in">void</span>;
</code></pre>
      <p data-en="218">类装饰器的能力：</p>
      <ul>
        <li data-en="219">它可以通过改变 <code>value</code> 来改变被装饰的类。</li>
        <li data-en="220">它可以通过返回可调用的值来替换被装饰的类。</li>
        <li data-en="221">它可以注册初始化器，初始化器在被装饰的类完全设置后调用。</li>
        <li data-en="222">由于类不是其他语言结构的成员（而方法是类的成员），因此它不获取 <code>context.access</code>。</li>
      </ul>
      <h3 id="example%3A-collecting-instances" tabindex="-1" data-en="223">示例：收集实例&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-collecting-instances" aria-hidden="true">#</a></h3>
      <p data-en="224">在下面的示例中，我们使用装饰器收集所有被装饰类的实例：</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InstanceCollector</span> {
  instances = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
  install = <span class="hljs-function">(<span class="hljs-params">value, {kind}</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'class'</span>) {
      <span class="hljs-keyword">const</span> _this = <span class="hljs-variable language_">this</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) { <span class="hljs-comment">// (A)</span>
        <span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">value</span>(...args); <span class="hljs-comment">// (B)</span>
        _this.<span class="hljs-property">instances</span>.<span class="hljs-title function_">add</span>(inst);
        <span class="hljs-keyword">return</span> inst;
      };
    }
  };
}

<span class="hljs-keyword">const</span> collector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstanceCollector</span>();

@collector.<span class="hljs-property">install</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {}

<span class="hljs-keyword">const</span> inst1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
<span class="hljs-keyword">const</span> inst2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
<span class="hljs-keyword">const</span> inst3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();

assert.<span class="hljs-title function_">deepEqual</span>(
  collector.<span class="hljs-property">instances</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([inst1, inst2, inst3])
);
</code></pre>
      <p data-en="225">我们通过将一个函数包装在 <code>.install</code> 中来实现收集实例。该函数在实例化时被调用，并将新创建的实例添加到收集器的实例集合中。</p>
      <p data-en="226">请注意，我们不能在 A 行返回一个箭头函数，因为箭头函数不能被 new 调用。</p>
      <p data-en="227">此方法的一个缺点是，它破坏了 <code>instanceof</code>：</p>
      <pre><code class="language-js">assert.<span class="hljs-title function_">equal</span>(
  inst1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyClass</span>,
  <span class="hljs-literal">false</span>
);
</code></pre>
      <p data-en="228">下一小节将解释我们如何修复这个问题。</p>
      <h3 id="making-sure-that-instanceof-works" tabindex="-1" data-en="229">确保 <code>instanceof</code> 正常工作&nbsp;&nbsp;<a class="heading-anchor" href="#making-sure-that-instanceof-works" aria-hidden="true">#</a></h3>
      <p data-en="230">在本节中，我们将使用简单的装饰器 <code>@countInstances</code> 来演示如何使被包装的类支持 <code>instanceof</code>。</p>
      <h4 id="enabling-instanceof-via-.prototype" tabindex="-1" data-en="231">通过 <code>.prototype</code> 启用 <code>instanceof</code>&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-.prototype" aria-hidden="true">#</a></h4>
      <p data-en="232">启用 <code>instanceof</code> 的一种方法是将包装函数的 <code>.prototype</code> 设置为被包装的 <code>value</code> 的 <code>.prototype</code>（A 行）：</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">countInstances</span>(<span class="hljs-params">value</span>) {
  <span class="hljs-keyword">const</span> _this = <span class="hljs-variable language_">this</span>;
  <span class="hljs-keyword">let</span> instanceCount = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 包装器必须是可通过 new 调用的</span>
  <span class="hljs-keyword">const</span> wrapper = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
    instanceCount++;
    <span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title function_">value</span>(...args);
    <span class="hljs-comment">// 修改实例</span>
    instance.<span class="hljs-property">count</span> = instanceCount;
    <span class="hljs-keyword">return</span> instance;
  };
  wrapper.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = value.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// (A)</span>
  <span class="hljs-keyword">return</span> wrapper;
}

@countInstances
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {}

<span class="hljs-keyword">const</span> inst1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
assert.<span class="hljs-title function_">ok</span>(inst1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyClass</span>);
assert.<span class="hljs-title function_">equal</span>(inst1.<span class="hljs-property">count</span>, <span class="hljs-number">1</span>);

<span class="hljs-keyword">const</span> inst2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
assert.<span class="hljs-title function_">ok</span>(inst2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyClass</span>);
assert.<span class="hljs-title function_">equal</span>(inst2.<span class="hljs-property">count</span>, <span class="hljs-number">2</span>);
</code></pre>
      <p data-en="233">这是有效的，原因如下：</p>
      <pre><code class="language-js">inst <span class="hljs-keyword">instanceof</span> C
C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(inst)
</code></pre>
      <p data-en="234">有关 <code>instanceof</code> 的更多信息，请参见 <a href="https://exploringjs.com/js/book/ch_classes.html#instanceof-operator">《探索 JavaScript》</a>。</p>
      <h4 id="enabling-instanceof-via-symbol.hasinstance" tabindex="-1" data-en="235">通过 <code>Symbol.hasInstance</code> 启用 <code>instanceof</code>&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-symbol.hasinstance" aria-hidden="true">#</a></h4>
      <p data-en="236">启用 <code>instanceof</code> 的另一种选择是给包装函数一个键为 <code>Symbol.hasInstance</code> 的方法（A 行）：</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">countInstances</span>(<span class="hljs-params">value</span>) {
  <span class="hljs-keyword">const</span> _this = <span class="hljs-variable language_">this</span>;
  <span class="hljs-keyword">let</span> instanceCount = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 包装器必须是可通过 new 调用的</span>
  <span class="hljs-keyword">const</span> wrapper = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
    instanceCount++;
    <span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title function_">value</span>(...args);
    <span class="hljs-comment">// 修改实例</span>
    instance.<span class="hljs-property">count</span> = instanceCount;
    <span class="hljs-keyword">return</span> instance;
  };
  <span class="hljs-comment">// 属性是只读的，因此我们不能使用赋值</span>
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <span class="hljs-comment">// (A)</span>
    wrapper, <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>,
    {
      <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) {
        <span class="hljs-keyword">return</span> x <span class="hljs-keyword">instanceof</span> value; 
      }
    }
  );
  <span class="hljs-keyword">return</span> wrapper;
}

@countInstances
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {}

<span class="hljs-keyword">const</span> inst1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
assert.<span class="hljs-title function_">ok</span>(inst1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyClass</span>);
assert.<span class="hljs-title function_">equal</span>(inst1.<span class="hljs-property">count</span>, <span class="hljs-number">1</span>);

<span class="hljs-keyword">const</span> inst2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
assert.<span class="hljs-title function_">ok</span>(inst2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyClass</span>);
assert.<span class="hljs-title function_">equal</span>(inst2.<span class="hljs-property">count</span>, <span class="hljs-number">2</span>);
</code></pre>
      <p data-en="237">《探索 JavaScript》 中有<a href="https://exploringjs.com/js/book/ch_symbols.html#publicly-known-symbols">关于 <code>Symbol.hasInstance</code> 的更多信息</a>。</p>
      <h4 id="enabling-instanceof-via-subclassing" tabindex="-1" data-en="238">通过子类化启用 <code>instanceof</code>&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-subclassing" aria-hidden="true">#</a></h4>
      <p data-en="239">我们还可以通过返回 <code>value</code> 的子类来启用 <code>instanceof</code>（A 行）：</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">countInstances</span>(<span class="hljs-params">value</span>) {
  <span class="hljs-keyword">const</span> _this = <span class="hljs-variable language_">this</span>;
  <span class="hljs-keyword">let</span> instanceCount = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// 包装器必须是可通过 new 调用的</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> value { <span class="hljs-comment">// (A)</span>
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">...args</span>) {
      <span class="hljs-variable language_">super</span>(...args);
      instanceCount++;
      <span class="hljs-comment">// 修改实例</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = instanceCount;
    }
  };
}

@countInstances
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {}

<span class="hljs-keyword">const</span> inst1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
assert.<span class="hljs-title function_">ok</span>(inst1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyClass</span>);
assert.<span class="hljs-title function_">equal</span>(inst1.<span class="hljs-property">count</span>, <span class="hljs-number">1</span>);

<span class="hljs-keyword">const</span> inst2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
assert.<span class="hljs-title function_">ok</span>(inst2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyClass</span>);
assert.<span class="hljs-title function_">equal</span>(inst2.<span class="hljs-property">count</span>, <span class="hljs-number">2</span>);
</code></pre>
      <h3 id="example-freezing-instances" tabindex="-1" data-en="240">示例：冻结实例&nbsp;&nbsp;<a class="heading-anchor" href="#example-freezing-instances" aria-hidden="true">#</a></h3>
      <p data-en="241">装饰器类 <code>@freeze</code> 通过冻结它所装饰的类生成的所有实例来实现：</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">freeze</span> (<span class="hljs-params">value, {kind}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'class'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
      <span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">value</span>(...args);
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(inst);
    }
  }
}

@freeze
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
}

<span class="hljs-keyword">const</span> red = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">'red'</span>);
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> red.<span class="hljs-property">name</span> = <span class="hljs-string">'green'</span>,
  <span class="hljs-regexp">/^TypeError: Cannot assign to read only property 'name'/</span>
);
</code></pre>
      <p data-en="242">此装饰器有以下缺点：</p>
      <ul>
        <li data-en="243">它破坏了 <code>instanceof</code>。我们已经看到如何修复这个问题。</li>
        <li>
          <kskb data-en="244" style="display: block;">对装饰类的子类化效果不佳：
          </kskb>
          <ul>
            <li data-en="245">构造函数的连接方式并不理想，因为混合了包装构造函数。这可以通过返回被装饰的 <code>value</code> 的子类来部分修复。</li>
            <li data-en="246">子类无法设置属性，因为它们的 <code>this</code> 是不可变的。无法避免此缺点。</li>
          </ul>
        </li>
      </ul>
      <p data-en="247">最后一个缺点可以通过在所有构造函数执行后让类装饰器访问装饰类的实例来避免。</p>
      <p data-en="248">这将改变继承的工作方式，因为超类现在可以更改由子类添加的属性。因此，未来是否会有这样的机制尚不确定。</p>
      <h3 id="example%3A-making-classes-function-callable" tabindex="-1" data-en="249">示例：让类可函数调用&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-making-classes-function-callable" aria-hidden="true">#</a></h3>
      <p data-en="250">被 <code>@functionCallable</code> 装饰的类可以通过函数调用而不是 <code>new</code> 操作符来调用：</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionCallable</span>(<span class="hljs-params">value, {kind}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'class'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> !== <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'This function can’t be new-invoked'</span>);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">value</span>(...args);
    }
  }
}

@functionCallable
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
}
<span class="hljs-keyword">const</span> robin = <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Robin'</span>);
assert.<span class="hljs-title function_">equal</span>(
  robin.<span class="hljs-property">name</span>, <span class="hljs-string">'Robin'</span>
);
</code></pre>
      <h2 id="class-method-decorators" tabindex="-1" data-en="251">类方法装饰器&nbsp;&nbsp;<a class="heading-anchor" href="#class-method-decorators" aria-hidden="true">#</a></h2>
      <p data-en="252">类方法装饰器具有以下类型签名：</p>
      <pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ClassMethodDecorator</span> = <span class="hljs-function">(<span class="hljs-params">
  <span class="hljs-attr">value</span>: <span class="hljs-title class_">Function</span>,
  <span class="hljs-attr">context</span>: {
    kind: <span class="hljs-string">'method'</span>;
    name: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>;
    <span class="hljs-keyword">static</span>: <span class="hljs-built_in">boolean</span>;
    <span class="hljs-keyword">private</span>: <span class="hljs-built_in">boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in">unknown</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_">Function</span> | <span class="hljs-built_in">void</span>;
</code></pre>
      <p data-en="253">方法装饰器的能力：</p>
      <ul>
        <li data-en="254">它可以通过改变 <code>value</code> 来改变被装饰的方法。</li>
        <li data-en="255">它可以通过返回一个函数来替换被装饰的方法。</li>
        <li data-en="256">它可以注册初始化器。</li>
        <li data-en="257"><code>context.access</code> 仅支持获取其属性的值，而不支持设置。</li>
      </ul>
      <p data-en="258">构造函数不能被装饰：它们看起来像方法，但实际上并不是真正的方法。</p>
      <h3 id="example-tracing-method-invocations" tabindex="-1" data-en="259">示例：追踪方法调用&nbsp;&nbsp;<a class="heading-anchor" href="#example-tracing-method-invocations" aria-hidden="true">#</a></h3>
      <p data-en="260">装饰器 <code>@trace</code> 包装方法，以便将它们的调用及结果记录到控制台：</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trace</span>(<span class="hljs-params">value, {kind, name}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'method'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`CALL <span class="hljs-subst">${name}</span>: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(args)}</span>`</span>);
      <span class="hljs-keyword">const</span> result = value.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'=&gt; '</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(result));
      <span class="hljs-keyword">return</span> result;
    };
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilder</span> {
  #str = <span class="hljs-string">''</span>;
  @trace
  <span class="hljs-title function_">add</span>(<span class="hljs-params">str</span>) {
    <span class="hljs-variable language_">this</span>.#str += str;
  }
  @trace
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#str;
  }
}

<span class="hljs-keyword">const</span> sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
sb.<span class="hljs-title function_">add</span>(<span class="hljs-string">'Home'</span>);
sb.<span class="hljs-title function_">add</span>(<span class="hljs-string">'page'</span>);
assert.<span class="hljs-title function_">equal</span>(
  sb.<span class="hljs-title function_">toString</span>(), <span class="hljs-string">'Homepage'</span>
);

<span class="hljs-comment">// Output:</span>
<span class="hljs-comment">// CALL add: ["Home"]</span>
<span class="hljs-comment">// =&gt; undefined</span>
<span class="hljs-comment">// CALL add: ["page"]</span>
<span class="hljs-comment">// =&gt; undefined</span>
<span class="hljs-comment">// CALL toString: []</span>
<span class="hljs-comment">// =&gt; "Homepage"</span>
</code></pre>
      <h3 id="example%3A-binding-methods-to-instances" tabindex="-1" data-en="261">示例：将方法绑定到实例&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-binding-methods-to-instances" aria-hidden="true">#</a></h3>
      <p data-en="262">通常，提取方法（A 行）意味着我们无法函数调用它们，因为这会将 <code>this</code> 设置为 <code>undefined</code>：</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color1</span> {
  #name;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.#name = name;
  }
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Color(<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.#name}</span>)`</span>;
  }
}

<span class="hljs-keyword">const</span> green1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color1</span>(<span class="hljs-string">'green'</span>);
<span class="hljs-keyword">const</span> toString1 = green1.<span class="hljs-property">toString</span>; <span class="hljs-comment">// (A)</span>
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">toString1</span>(),
  <span class="hljs-regexp">/^TypeError: Cannot read properties of undefined/</span>
);
</code></pre>
      <p data-en="263">我们可以通过装饰器 <code>@bind</code> 修复这个问题：</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bind</span>(<span class="hljs-params">value, {kind, name, addInitializer}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'method'</span>) {
    <span class="hljs-title function_">addInitializer</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-comment">// (B)</span>
      <span class="hljs-variable language_">this</span>[name] = value.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// (C)</span>
    });
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Color2</span> {
  #name;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.#name = name;
  }
  @bind
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Color(<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.#name}</span>)`</span>;
  }
}

<span class="hljs-keyword">const</span> green2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color2</span>(<span class="hljs-string">'green'</span>);
<span class="hljs-keyword">const</span> toString2 = green2.<span class="hljs-property">toString</span>;
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">toString2</span>(), <span class="hljs-string">'Color(green)'</span>
);

<span class="hljs-comment">// 自有属性 green2.toString 与</span>
<span class="hljs-comment">// Color2.prototype.toString 不同</span>
assert.<span class="hljs-title function_">ok</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(green2, <span class="hljs-string">'toString'</span>));
assert.<span class="hljs-title function_">notEqual</span>(
  green2.<span class="hljs-property">toString</span>,
  <span class="hljs-title class_">Color2</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>
);
</code></pre>
      <p data-en="264">通过将 A 行的初始化器注册为普通函数，我们可以在实例化时访问 <code>this</code>。这也解释了为什么 B 行的 <code>this</code> 具有该值。(line C)</p>
      <h3 id="example%3A-applying-functions-to-methods" tabindex="-1" data-en="265">示例：对方法应用函数&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-applying-functions-to-methods" aria-hidden="true">#</a></h3>
      <p data-en="266">库 <code>core-decorators</code> 提供了一个装饰器，允许我们对方法应用函数。这使我们能够使用像 Lodash 的 <code>memoize()</code> 这样的辅助函数。以下代码展示了装饰器 <code>@applyFunction</code> 的实现：</p>
      <pre><code class="language-js"><span class="hljs-keyword">import</span> { memoize } <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash-es'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">applyFunction</span>(<span class="hljs-params">functionFactory</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">value, {kind}</span>) =&gt;</span> { <span class="hljs-comment">// 装饰器函数</span>
    <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'method'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">functionFactory</span>(value);
    }
  };
}

<span class="hljs-keyword">let</span> invocationCount = <span class="hljs-number">0</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> {
  @<span class="hljs-title function_">applyFunction</span>(memoize)
  <span class="hljs-title function_">expensiveOperation</span>(<span class="hljs-params">str</span>) {
    invocationCount++;
    <span class="hljs-comment">// str` 的昂贵开销 😀</span>
    <span class="hljs-keyword">return</span> str + str;
  }
}

<span class="hljs-keyword">const</span> task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>();
assert.<span class="hljs-title function_">equal</span>(
  task.<span class="hljs-title function_">expensiveOperation</span>(<span class="hljs-string">'abc'</span>),
  <span class="hljs-string">'abcabc'</span>
);
assert.<span class="hljs-title function_">equal</span>(
  task.<span class="hljs-title function_">expensiveOperation</span>(<span class="hljs-string">'abc'</span>),
  <span class="hljs-string">'abcabc'</span>
);
assert.<span class="hljs-title function_">equal</span>(
  invocationCount, <span class="hljs-number">1</span>
);
</code></pre>
      <h2 id="class-getter-decorators%2C-class-setter-decorators" tabindex="-1" data-en="267">类 getter 装饰器、setter 装饰器&nbsp;&nbsp;<a class="heading-anchor" href="#class-getter-decorators%2C-class-setter-decorators" aria-hidden="true">#</a></h2>
      <p data-en="268">这些是 getter 装饰器和 setter 装饰器的类型签名：</p>
      <pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ClassGetterDecorator</span> = <span class="hljs-function">(<span class="hljs-params">
  <span class="hljs-attr">value</span>: <span class="hljs-title class_">Function</span>,
  <span class="hljs-attr">context</span>: {
    kind: <span class="hljs-string">'getter'</span>;
    name: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>;
    <span class="hljs-keyword">static</span>: <span class="hljs-built_in">boolean</span>;
    <span class="hljs-keyword">private</span>: <span class="hljs-built_in">boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in">unknown</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_">Function</span> | <span class="hljs-built_in">void</span>;

<span class="hljs-keyword">type</span> <span class="hljs-title class_">ClassSetterDecorator</span> = <span class="hljs-function">(<span class="hljs-params">
  <span class="hljs-attr">value</span>: <span class="hljs-title class_">Function</span>,
  <span class="hljs-attr">context</span>: {
    kind: <span class="hljs-string">'setter'</span>;
    name: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>;
    <span class="hljs-keyword">static</span>: <span class="hljs-built_in">boolean</span>;
    <span class="hljs-keyword">private</span>: <span class="hljs-built_in">boolean</span>;
    access: { set: (value: <span class="hljs-built_in">unknown</span>) =&gt; <span class="hljs-built_in">void</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_">Function</span> | <span class="hljs-built_in">void</span>;
</code></pre>
      <p data-en="269">getter 装饰器和 setter 装饰器的能力类似于方法装饰器。</p>
      <h3 id="example%3A-computing-values-lazily" tabindex="-1" data-en="270">示例：惰性计算值&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-computing-values-lazily" aria-hidden="true">#</a></h3>
      <p data-en="271">惰性计算属性值的实现需要两种技术：</p>
      <ul>
        <li>
          <p data-en="273">我们通过 getter 实现该属性。这样，计算其值的代码仅在读取属性时执行。</p>
        </li>
        <li>
          <p data-en="275">装饰器 <code>@lazy</code> 包装原始 getter：当包装器第一次被调用时，它调用 getter 并创建一个自身数据属性，其值为计算结果。从此以后，无论何时有人读取该属性，自身属性都会覆盖继承的 getter。</p>
        </li>
      </ul>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  @lazy
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'COMPUTING'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Result of computation'</span>;
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">lazy</span>(<span class="hljs-params">value, {kind, name, addInitializer}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'getter'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">const</span> result = value.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <span class="hljs-comment">// (A)</span>
        <span class="hljs-variable language_">this</span>, name,
        {
          <span class="hljs-attr">value</span>: result,
          <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,
        }
      );
      <span class="hljs-keyword">return</span> result;
    };
  }
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'1 new C()'</span>);
<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'2 inst.value'</span>);
assert.<span class="hljs-title function_">equal</span>(inst.<span class="hljs-property">value</span>, <span class="hljs-string">'Result of computation'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'3 inst.value'</span>);
assert.<span class="hljs-title function_">equal</span>(inst.<span class="hljs-property">value</span>, <span class="hljs-string">'Result of computation'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'4 end'</span>);

<span class="hljs-comment">// Output:</span>
<span class="hljs-comment">// 1 new C()</span>
<span class="hljs-comment">// 2 inst.value</span>
<span class="hljs-comment">// COMPUTING</span>
<span class="hljs-comment">// 3 inst.value</span>
<span class="hljs-comment">// 4 end</span>
</code></pre>
      <p data-en="276">请注意，属性 <code>.[name]</code> 是不可变的（因为只有一个 getter），这就是为什么我们必须在 A 行定义该属性，而不能使用赋值的原因。</p>
      <h2 id="class-field-decorators" tabindex="-1" data-en="277">类字段装饰器&nbsp;&nbsp;<a class="heading-anchor" href="#class-field-decorators" aria-hidden="true">#</a></h2>
      <p data-en="278">类字段装饰器具有以下类型签名：</p>
      <pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ClassFieldDecorator</span> = <span class="hljs-function">(<span class="hljs-params">
  <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>,
  <span class="hljs-attr">context</span>: {
    kind: <span class="hljs-string">'field'</span>;
    name: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>;
    <span class="hljs-keyword">static</span>: <span class="hljs-built_in">boolean</span>;
    <span class="hljs-keyword">private</span>: <span class="hljs-built_in">boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in">unknown</span>, set: (value: <span class="hljs-built_in">unknown</span>) =&gt; <span class="hljs-built_in">void</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">initialValue</span>: <span class="hljs-built_in">unknown</span></span>) =&gt;</span> <span class="hljs-built_in">unknown</span> | <span class="hljs-built_in">void</span>;
</code></pre>
      <p data-en="279">字段装饰器的能力：</p>
      <ul>
        <li>
          <p data-en="281">它不能改变或替换它的字段。如果我们需要该功能，我们必须使用 <em>自<a href="#auto-accessors">动访问器</a></em>（稍后将解释的内容）。</p>
        </li>
        <li>
          <kskb data-en="282" style="display: block;">
            <p data-en="283">通过返回一个接收原始初始化值并返回新初始化值的函数来改变字段的初始化值。</p>
          </kskb>
          <ul>
            <li data-en="284">在该函数内部，<code>this</code> 指向当前实例。</li>
          </ul>
        </li>
        <li>
          <p data-en="286">注册初始化器。这是装饰器 API 的一个最近更改（2022-03 之后），之前是不可行的。</p>
        </li>
      </ul>
      <ul>
        <li data-en="287">它可以通过 <code>context.access</code> 暴露对其字段的访问（即使是私有字段）。</li>
      </ul>
      <h3 id="example%3A-changing-initialization-values-of-fields" tabindex="-1" data-en="288">示例：改变字段初始化值&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-changing-initialization-values-of-fields" aria-hidden="true">#</a></h3>
      <p data-en="289">装饰器 <code>@twice</code> 通过返回一个函数来改变字段的原始初始化值，该函数接收原始值并返回新值：</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twice</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">initialValue</span> =&gt;</span> initialValue * <span class="hljs-number">2</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  @twice
  field = <span class="hljs-number">3</span>;
}

<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();
assert.<span class="hljs-title function_">equal</span>(
  inst.<span class="hljs-property">field</span>, <span class="hljs-number">6</span>
);
</code></pre>
      <h3 id="read-only-fields" tabindex="-1" data-en="290">示例：只读字段（实例公有字段）&nbsp;&nbsp;<a class="heading-anchor" href="#read-only-fields" aria-hidden="true">#</a></h3>
      <p data-en="291">装饰器 <code>@readOnly</code> 通过在字段完全设置后（通过赋值或构造函数）使其不可变来实现。</p>
      <pre><code class="language-js"><span class="hljs-keyword">const</span> readOnlyFieldKeys = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'readOnlyFieldKeys'</span>);

@readOnly
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {
  @readOnly
  name;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
}

<span class="hljs-keyword">const</span> blue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">'blue'</span>);
assert.<span class="hljs-title function_">equal</span>(blue.<span class="hljs-property">name</span>, <span class="hljs-string">'blue'</span>);
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> blue.<span class="hljs-property">name</span> = <span class="hljs-string">'brown'</span>,
  <span class="hljs-regexp">/^TypeError: Cannot assign to read only property 'name'/</span>
);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">readOnly</span>(<span class="hljs-params">value, {kind, name}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'field'</span>) { <span class="hljs-comment">// (A)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>[readOnlyFieldKeys]) {
        <span class="hljs-variable language_">this</span>[readOnlyFieldKeys] = [];
      }
      <span class="hljs-variable language_">this</span>[readOnlyFieldKeys].<span class="hljs-title function_">push</span>(name);
    };
  }
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'class'</span>) { <span class="hljs-comment">// (B)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
      <span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">value</span>(...args);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> inst[readOnlyFieldKeys]) {
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(inst, key, {<span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>});
      }
      <span class="hljs-keyword">return</span> inst;
    }
  }
}
</code></pre>
      <p data-en="292">我们需要两步来让 <code>@readOnly</code> 生效(这也是类也被装饰了的原因):</p>
      <ul>
        <li data-en="293">我们首先收集所有要变成只读的字段 (line A).</li>
        <li data-en="294">等实例已经创建完成，我们再把收集的字段设为不可写(line B)。我们需要把类包起来因为装饰器初始化器执行得太早了。</li>
      </ul>
      <p data-en="295">和不可变类似，这个装饰器也会破坏<code>instanceof</code>的行为。 变通方法也是一样的。</p>
      <p data-en="296">我们一会会看到， <a href="#read-only-auto-accessors"> <code>@readOnly</code>能够和auto-accessor互动而非和字段互动的版本</a>。而且使用过程不需要装饰类。</p>
      <h3 id="example%3A-dependency-injection-(instance-public-fields)" tabindex="-1" data-en="297">示例：依赖注入（实例public字段）&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-dependency-injection-(instance-public-fields)" aria-hidden="true">#</a></h3>
      <p data-en="298"><em>依赖注入（Dependency Injection）</em> 是由以下观察推动的：如果我们提供类的构造函数其依赖项（而不是构造函数自己设置它们），那么就更容易适应不同的环境，包括测试。</p>
      <p data-en="299">这是一种​<em>​控制反转（Inversion of Control）</em>​​：构造函数本身不执行初始化操作，而是由我们代为完成。以下是实现依赖注入的几种方法：</p>
      <ol>
        <li data-en="300">手动创建依赖项并传递给构造函数</li>
        <li data-en="301">通过前端框架（如React）中的"contexts"实现</li>
        <li data-en="302">通过装饰器和<em>依赖注入注册表</em>（<em>依赖注入容器</em>的一种变体）实现</li>
      </ol>
      <p data-en="303">以下代码是方法 #3 的一个简单实现：</p>
      <pre><code class="language-js"><span class="hljs-keyword">const</span> {registry, inject} = <span class="hljs-title function_">createRegistry</span>();

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> {
  <span class="hljs-title function_">log</span>(<span class="hljs-params">str</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
  @inject logger;
  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Hello!'</span>);
  }
}

registry.<span class="hljs-title function_">register</span>(<span class="hljs-string">'logger'</span>, <span class="hljs-title class_">Logger</span>);
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>().<span class="hljs-title function_">run</span>();

<span class="hljs-comment">// Output:</span>
<span class="hljs-comment">// Hello!</span>
</code></pre>
      <p data-en="304">这就是 <code>createRegistry()</code> 的实装方法:</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createRegistry</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> nameToClass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  <span class="hljs-keyword">const</span> nameToInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  <span class="hljs-keyword">const</span> registry = {
    <span class="hljs-title function_">register</span>(<span class="hljs-params">name, componentClass</span>) {
      nameToClass.<span class="hljs-title function_">set</span>(name, componentClass);
    },
    <span class="hljs-title function_">getInstance</span>(<span class="hljs-params">name</span>) {
      <span class="hljs-keyword">if</span> (nameToInstance.<span class="hljs-title function_">has</span>(name)) {
        <span class="hljs-keyword">return</span> nameToInstance.<span class="hljs-title function_">get</span>(name);
      }
      <span class="hljs-keyword">const</span> componentClass = nameToClass.<span class="hljs-title function_">get</span>(name);
      <span class="hljs-keyword">if</span> (componentClass === <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Unknown component name: '</span> + name);
      }
      <span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">componentClass</span>();
      nameToInstance.<span class="hljs-title function_">set</span>(name, inst);
      <span class="hljs-keyword">return</span> inst;
    },
  }; 
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inject</span> (<span class="hljs-params">_value, {kind, name}</span>) {
    <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'field'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> registry.<span class="hljs-title function_">getInstance</span>(name);
    }
  }
  <span class="hljs-keyword">return</span> {registry, inject};
}
</code></pre>
      <h3 id="example-friend-visibility" tabindex="-1" data-en="305">示例：“友元”可见性（实例私有字段）&nbsp;&nbsp;<a class="heading-anchor" href="#example-friend-visibility" aria-hidden="true">#</a></h3>
      <p data-en="306">我们可以通过将某些类成员设为私有来改变其可见性，从而防止它们被公开访问。不过，还有更多有用的可见性类型。例如，<em>友元可见性</em>允许一组<em>友元</em>（函数、其他类等）访问该成员。</p>
      <p data-en="307">有多种方式可以指定友元。在以下示例中，所有能访问<code>friendName</code>的对象都是<code>classWithSecret.#name</code>的友元。其核心思想是：一个模块中包含相互协作的类和函数，而某些实例数据应该仅对这些协作者可见。</p>
      <pre><code class="language-js"><span class="hljs-keyword">const</span> friendName = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Friend</span>();

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassWithSecret</span> {
  @friendName.<span class="hljs-property">install</span> #name = <span class="hljs-string">'Rumpelstiltskin'</span>;
  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#name;
  }
}

<span class="hljs-comment">// 能访问 `secret`的，也能访问 inst.#name</span>
<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWithSecret</span>();
assert.<span class="hljs-title function_">equal</span>(
  friendName.<span class="hljs-title function_">get</span>(inst), <span class="hljs-string">'Rumpelstiltskin'</span>
);
friendName.<span class="hljs-title function_">set</span>(inst, <span class="hljs-string">'Joe'</span>);
assert.<span class="hljs-title function_">equal</span>(
  inst.<span class="hljs-title function_">getName</span>(), <span class="hljs-string">'Joe'</span>
);
</code></pre>
      <p data-en="308">这是<code>Friend</code>类实装的过程：</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Friend</span> {
  #access = <span class="hljs-literal">undefined</span>;
  #<span class="hljs-title function_">getAccessOrThrow</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.#access === <span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'The friend decorator wasn’t used yet'</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#access;
  }
  <span class="hljs-comment">// 一个`this`已经被绑定好了的类属性</span>
  <span class="hljs-comment">// （绑定到了这个实例上）</span>
  install = <span class="hljs-function">(<span class="hljs-params">_value, {kind, access}</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'field'</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.#access) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'This decorator can only be used once'</span>);
      }
      <span class="hljs-variable language_">this</span>.#access = access;
    }
  }
  <span class="hljs-title function_">get</span>(<span class="hljs-params">inst</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">getAccessOrThrow</span>().<span class="hljs-property">get</span>.<span class="hljs-title function_">call</span>(inst);
  }
  <span class="hljs-title function_">set</span>(<span class="hljs-params">inst, value</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">getAccessOrThrow</span>().<span class="hljs-property">set</span>.<span class="hljs-title function_">call</span>(inst, value);
  }
}
</code></pre>
      <h3 id="example%3A-enums-(static-public-fields)" tabindex="-1" data-en="309">示例：枚举（静态公有字段）&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-enums-(static-public-fields)" aria-hidden="true">#</a></h3>
      <p data-en="310">实现枚举的方式有很多种。一种面向对象风格的实现方式是使用类和静态属性（<a href="https://2ality.com/2016/01/enumify.html">关于此方法的更多信息</a>）：</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {
  <span class="hljs-keyword">static</span> red = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">'red'</span>);
  <span class="hljs-keyword">static</span> green = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">'green'</span>);
  <span class="hljs-keyword">static</span> blue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">'blue'</span>);
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">enumKey</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">enumKey</span> = enumKey;
  }
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Color(<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.enumKey}</span>)`</span>;
  }
}
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Color</span>.<span class="hljs-property">green</span>.<span class="hljs-title function_">toString</span>(),
  <span class="hljs-string">'Color(green)'</span>
);
</code></pre>
      <p data-en="311">我们可以使用装饰器自动实现以下功能：</p>
      <ul>
        <li data-en="312">创建一个从"枚举键"（字段名称）到枚举值的映射(Map)</li>
        <li data-en="313">将枚举键添加到枚举值中 - 无需通过构造函数传递</li>
      </ul>
      <p data-en="314">实现方式如下所示：</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">enumEntry</span>(<span class="hljs-params">value, {kind, name}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'field'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">initialValue</span>) {
      <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">'enumFields'</span>)) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">enumFields</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
      }
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">enumFields</span>.<span class="hljs-title function_">set</span>(name, initialValue);
      initialValue.<span class="hljs-property">enumKey</span> = name;
      <span class="hljs-keyword">return</span> initialValue;
    };
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {
  @enumEntry <span class="hljs-keyword">static</span> red = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>();
  @enumEntry <span class="hljs-keyword">static</span> green = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>();
  @enumEntry <span class="hljs-keyword">static</span> blue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>();
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Color(<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.enumKey}</span>)`</span>;
  }
}
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Color</span>.<span class="hljs-property">green</span>.<span class="hljs-title function_">toString</span>(),
  <span class="hljs-string">'Color(green)'</span>
);
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Color</span>.<span class="hljs-property">enumFields</span>,
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([
    [<span class="hljs-string">'red'</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">red</span>],
    [<span class="hljs-string">'green'</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">green</span>],
    [<span class="hljs-string">'blue'</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">blue</span>],
  ])
);
</code></pre>
      <h2 id="auto-accessors" tabindex="-1" data-en="315">自动访问器：类定义的新成员&nbsp;&nbsp;<a class="heading-anchor" href="#auto-accessors" aria-hidden="true">#</a></h2>
      <p data-en="316">装饰器提案引入了一项新的语言特性：<em>自动访问器(auto-accessors)</em>。通过在类字段前添加<code>accessor</code>关键字即可创建自动访问器。它使用起来像普通字段，但在运行时采用不同的实现方式。这将有助于装饰器的使用，我们稍后会看到。以下是自动访问器的示例：</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  <span class="hljs-keyword">static</span> accessor myField1;
  <span class="hljs-keyword">static</span> accessor #myField2;
  accessor myField3;
  accessor #myField4;
}
</code></pre>
      <p data-en="317">字段和自动访问器有何区别？</p>
      <ul>
        <li>
          <kskb data-en="318" style="display: block;">字段会创建以下两种结构之一：
          </kskb>
          <ul>
            <li data-en="319">属性（静态或实例）</li>
            <li data-en="320">私有槽位（静态或实例）</li>
          </ul>
        </li>
        <li>
          <kskb data-en="321" style="display: block;">自动访问器会为数据创建一个私有槽位（静态或实例），并同时创建：</kskb>
          <ul>
            <li data-en="322">公共的getter-setter对（静态或原型）</li>
            <li>
              <kskb data-en="323" style="display: block;">私有的getter-setter对（静态或实例）</kskb>
              <ul>
                <li data-en="324">私有槽位不可继承，因此永远不会存在于原型中</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <p data-en="325">请看以下类示例：</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  accessor str = <span class="hljs-string">'abc'</span>;
}
<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();
assert.<span class="hljs-title function_">equal</span>(
  inst.<span class="hljs-property">str</span>, <span class="hljs-string">'abc'</span>
);
inst.<span class="hljs-property">str</span> = <span class="hljs-string">'def'</span>;
assert.<span class="hljs-title function_">equal</span>(
  inst.<span class="hljs-property">str</span>, <span class="hljs-string">'def'</span>
);
</code></pre>
      <p data-en="326">其内部实现如下所示：</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  #str = <span class="hljs-string">'abc'</span>;
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">str</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#str;
  }
  <span class="hljs-keyword">set</span> <span class="hljs-title function_">str</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-variable language_">this</span>.#str = value;
  }
}
</code></pre>
      <p data-en="327">以下代码展示了自动访问器的getter和setter所在的位置：</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  <span class="hljs-keyword">static</span> accessor myField1;
  <span class="hljs-keyword">static</span> accessor #myField2;
  accessor myField3;
  accessor #myField4;

  <span class="hljs-keyword">static</span> {
    <span class="hljs-comment">// Static getter and setter</span>
    assert.<span class="hljs-title function_">ok</span>(
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(C, <span class="hljs-string">'myField1'</span>), <span class="hljs-string">'myField1'</span>
    );
    <span class="hljs-comment">// Static getter and setter</span>
    assert.<span class="hljs-title function_">ok</span>(
      #myField2 <span class="hljs-keyword">in</span> C, <span class="hljs-string">'#myField2'</span>
    );

    <span class="hljs-comment">// Prototype getter and setter</span>
    assert.<span class="hljs-title function_">ok</span>(
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">'myField3'</span>), <span class="hljs-string">'myField3'</span>
    );
    <span class="hljs-comment">// Private getter and setter</span>
    <span class="hljs-comment">// （保存在实例上，但在各个实例之间共享）</span>
    assert.<span class="hljs-title function_">ok</span>(
      #myField4 <span class="hljs-keyword">in</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(), <span class="hljs-string">'#myField4'</span>
    );
  }
}
</code></pre>
      <p data-en="328">有关私有getter、私有setter和私有方法的槽位为何存储在实例中的更多信息，请参阅<a href="https://exploringjs.com/js/book/ch_classes.html#private-methods-accessors">《探索JavaScript》中的"私有方法和访问器"章节</a>。</p>
      <h3 id="why-are-auto-accessors-needed%3F" tabindex="-1" data-en="329">为什么需要自动访问器？&nbsp;&nbsp;<a class="heading-anchor" href="#why-are-auto-accessors-needed%3F" aria-hidden="true">#</a></h3>
      <p data-en="330">自动访问器是装饰器所必需的：</p>
      <ul>
        <li data-en="331">装饰器只能影响字段的初始值</li>
        <li data-en="332">但可以完全替换自动访问器</li>
      </ul>
      <p data-en="333">因此，当装饰器需要比字段更多的控制权时，我们必须使用自动访问器而非字段。</p>
      <h2 id="class-auto-accessor-decorators" tabindex="-1" data-en="334">类自动访问器装饰器（Class auto-accessor）&nbsp;&nbsp;<a class="heading-anchor" href="#class-auto-accessor-decorators" aria-hidden="true">#</a></h2>
      <p data-en="335">类自动访问器装饰器具有以下类型签名：</p>
      <pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ClassAutoAccessorDecorator</span> = <span class="hljs-function">(<span class="hljs-params">
  <span class="hljs-attr">value</span>: {
    get: () =&gt; <span class="hljs-built_in">unknown</span>;
    set: (value: <span class="hljs-built_in">unknown</span>) =&gt; <span class="hljs-built_in">void</span>;
  },
  <span class="hljs-attr">context</span>: {
    kind: <span class="hljs-string">'accessor'</span>;
    name: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>;
    <span class="hljs-keyword">static</span>: <span class="hljs-built_in">boolean</span>;
    <span class="hljs-keyword">private</span>: <span class="hljs-built_in">boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in">unknown</span>, set: (value: <span class="hljs-built_in">unknown</span>) =&gt; <span class="hljs-built_in">void</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>;
  }
</span>) =&gt;</span> {
  <span class="hljs-attr">get</span>?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">unknown</span>;
  <span class="hljs-attr">set</span>?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">init</span>?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">initialValue</span>: <span class="hljs-built_in">unknown</span></span>) =&gt;</span> <span class="hljs-built_in">unknown</span>;
} | <span class="hljs-built_in">void</span>;
</code></pre>
      <p data-en="336">自动访问器装饰器的能力：</p>
      <ul>
        <li>
          <kskb data-en="337" style="display: block;">通过参数<code>value</code>接收自动访问器的getter和setter</kskb>
          <ul>
            <li data-en="338"><code>context.access</code>提供相同的功能</li>
          </ul>
        </li>
        <li data-en="339">可以通过返回包含<code>.get()</code>和/或<code>.set()</code>方法的对象来替换被装饰的自动访问器</li>
        <li data-en="340">可以通过返回包含<code>.init()</code>方法的对象来影响自动访问器的初始值</li>
        <li data-en="341">可以注册初始化器</li>
      </ul>
      <h3 id="read-only-auto-accessors" tabindex="-1" data-en="342">示例：只读自动访问器&nbsp;&nbsp;<a class="heading-anchor" href="#read-only-auto-accessors" aria-hidden="true">#</a></h3>
      <p data-en="343">我们已经实现了<a href="#read-only-fields">字段的装饰器<code>@readOnly</code></a>。现在为自动访问器实现同样的功能：</p>
      <pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">UNINITIALIZED</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'UNINITIALIZED'</span>);
<span class="hljs-keyword">function</span> <span class="hljs-title function_">readOnly</span>(<span class="hljs-params">{get,set}, {name, kind}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'accessor'</span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">UNINITIALIZED</span>;
      },
      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> value = get.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);
        <span class="hljs-keyword">if</span> (value === <span class="hljs-variable constant_">UNINITIALIZED</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(
            <span class="hljs-string">`Accessor <span class="hljs-subst">${name}</span> hasn’t been initialized yet`</span>
          );
        }
        <span class="hljs-keyword">return</span> value;
      },
      <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) {
        <span class="hljs-keyword">const</span> oldValue = get.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);
        <span class="hljs-keyword">if</span> (oldValue !== <span class="hljs-variable constant_">UNINITIALIZED</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(
            <span class="hljs-string">`Accessor <span class="hljs-subst">${name}</span> can only be set once`</span>
          );
        }
        set.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, newValue);
      },
    };
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {
  @readOnly
  accessor name;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
}

<span class="hljs-keyword">const</span> blue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">'blue'</span>);
assert.<span class="hljs-title function_">equal</span>(blue.<span class="hljs-property">name</span>, <span class="hljs-string">'blue'</span>);
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> blue.<span class="hljs-property">name</span> = <span class="hljs-string">'yellow'</span>,
  <span class="hljs-regexp">/^TypeError: Accessor name can only be set once$/</span>
);

<span class="hljs-keyword">const</span> orange = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">'orange'</span>);
assert.<span class="hljs-title function_">equal</span>(orange.<span class="hljs-property">name</span>, <span class="hljs-string">'orange'</span>);
</code></pre>
      <p data-en="344">与字段版本相比，此装饰器有一个显著的优点：它不需要包装类即可确保被装饰的结构变为只读。</p>
      <h2 id="faq" tabindex="-1" data-en="345">常见问题&nbsp;&nbsp;<a class="heading-anchor" href="#faq" aria-hidden="true">#</a></h2>
      <h3 id="function-decorators" tabindex="-1" data-en="346">为什么函数不能被装饰？&nbsp;&nbsp;<a class="heading-anchor" href="#function-decorators" aria-hidden="true">#</a></h3>
      <p data-en="347">当前提案是以“类”为出发点的。<a href="#more-decorator-related-proposals">函数表达式的装饰器提案已经提出。</a> 然而，自那以后进展不大，并且尚未有函数 <em>声明</em> 的提案。</p>
      <p data-en="348">另一方面，装饰函数相对简单：</p>
      <pre><code class="language-js"><span class="hljs-keyword">const</span> decoratedFunc = <span class="hljs-title function_">decorator</span>(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> {});
</code></pre>
      <p data-en="349">甚至 <a href="https://2ality.com/2022/01/pipe-operator.html">管道运算符提案</a>看起来更好：</p>
      <pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">decoratedFunc</span> = (<span class="hljs-params">x, y</span>) =&gt; {} |&gt; <span class="hljs-title function_">decorator</span>(%);
</code></pre>
      <h2 id="more-decorator-related-proposals" tabindex="-1" data-en="350">More decorator-related proposals&nbsp;&nbsp;<a class="heading-anchor" href="#more-decorator-related-proposals" aria-hidden="true">#</a></h2>
      <p data-en="351">以下这些ECMAScript提案，提供了更多装饰器相关的特性：</p>
      <ul>
        <li>
          <kskb data-en="352" style="display: block;">Stage 2: <a href="https://github.com/tc39/proposal-decorator-metadata">“Decorator Metadata”</a> 作者 Chris Garrett (最近更新：2022-04-11)</kskb>
          <ul>
            <li data-en="353">“本提案旨在扩展装饰器提案，增加装饰器与被装饰的值的元数据的互动。”</li>
          </ul>
        </li>
        <li data-en="354">Stage 0: <a href="https://docs.google.com/document/d/1ikxIP5-RVYq6d_f8lAvf3pKC00W78ueyp-xIZ6q67uU">“Function Expression Decorators”</a> 作者 Igor Minar (最近更新：2016-01-25)</li>
        <li data-en="355">Stage 0: <a href="https://docs.google.com/document/d/1Qpkqf_8NzAwfD8LdnqPjXAQ2wwh8BBUGynhn-ZlCWT0">“Method Parameter Decorators”</a> 作者 Igor Minar (最近更新：2016-01-25)</li>
      </ul>
      <h2 id="resources" tabindex="-1" data-en="356">资源&nbsp;&nbsp;<a class="heading-anchor" href="#resources" aria-hidden="true">#</a></h2>
      <h3 id="decorator-implementations" tabindex="-1" data-en="357">实现&nbsp;&nbsp;<a class="heading-anchor" href="#decorator-implementations" aria-hidden="true">#</a></h3>
      <ul>
        <li>
          <kskb data-en="358" style="display: block;">Babel 目前通过 <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators"><code>@babel/plugin-proposal-decorators</code></a> 对第 3 阶段装饰器提供了最佳支持。
          </kskb>
          <ul>
            <li data-en="359">确保选择 <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators#version">最新的装饰器版本</a>。</li>
            <li data-en="360">本文中所有代码均通过 Babel 开发。</li>
          </ul>
        </li>
        <li>
          <kskb data-en="361" style="display: block;">TypeScript 目前在一个标志后面支持第 1 阶段装饰器。
          </kskb>
          <ul>
            <li data-en="362">有 <a href="https://github.com/microsoft/TypeScript/pull/50820">Ron Buckton 的一个 PR</a> 支持第 3 阶段装饰器，并可能在 TypeScript 4.9 之后的版本中发布。</li>
          </ul>
        </li>
      </ul>
      <h3 id="libraries-with-decorators" tabindex="-1" data-en="363">带装饰器的库&nbsp;&nbsp;<a class="heading-anchor" href="#libraries-with-decorators" aria-hidden="true">#</a></h3>
      <p data-en="364">这些是带装饰器的库。目前它们仅支持第 1 阶段装饰器，但可以作为可能性的灵感：</p>
      <ul>
        <li data-en="365"><a href="https://github.com/jayphelps/core-decorators.js">core-decorators.js</a> by Jay Phelps (targets Babel)</li>
        <li data-en="366"><a href="https://github.com/NetanelBasal/helpful-decorators">“Helpful Decorators For TypeScript Projects”</a> by Netanel Basal</li>
      </ul>
      <h2 id="acknowledgements" tabindex="-1" data-en="367">致谢&nbsp;&nbsp;<a class="heading-anchor" href="#acknowledgements" aria-hidden="true">#</a></h2>
      <ul>
        <li data-en="368">感谢 Chris Garrett 解答我关于装饰器的问题。</li>
      </ul>
      <h2 id="further-reading" tabindex="-1" data-en="369">延伸阅读&nbsp;&nbsp;<a class="heading-anchor" href="#further-reading" aria-hidden="true">#</a></h2>
      <ul>
        <li>
          <p data-en="371"><a href="https://exploringjs.com/js/book/ch_callables.html">章节：Callables</a> [普通函数、箭头函数、类、方法] 在《探索 JavaScript》中</p>
        </li>
        <li>
          <p data-en="373"><a href="https://exploringjs.com/js/book/ch_classes.html">章节：Classes</a> 在《探索 JavaScript》中</p>
        </li>
      </ul>
    </div>
  </div>
</body>
<script src="../js/indexer.js"></script>
<script src="../js/lang-tag.js"></script>

</html>