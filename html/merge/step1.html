<html lang="en-US">
<!-- step1.分别标记中英文元素 -->

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>使用 2022-03 装饰器 API 进行 JavaScript 元编程</title>
  <link rel="stylesheet" href="../../css/main.css">
  <link rel="stylesheet" href="../../css/highlight.css">
  <link rel="stylesheet" href="../../css/toggle-lang.css">
</head>

<body>
  <div id="page-core-content" class="number-headings">
    <h1 data-en="1">JavaScript metaprogramming with the 2022-03 decorators API</h1>
    <div>
      <p data-en="2">JavaScript decorators have finally reached <a href="https://exploringjs.com/js/book/ch_history.html#tc39-process">stage 3</a>! Their latest version is already supported by Babel and <a href="#decorator-implementations">will soon be supported by TypeScript</a>.</p>
      <p data-en="3">This blog post covers the 2022-03 version (stage 3) of the ECMAScript proposal <a href="https://github.com/tc39/proposal-decorators">“Decorators”</a> by Daniel Ehrenberg and Chris Garrett.</p>
      <p data-en="4">A decorator is a keyword that starts with an <code>@</code> symbol and can be put in front of classes and class members (such as methods). For example, <code>@trace</code> is a decorator:</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  @trace
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'C'</span>;
  }
}
</code>
</pre>
      <p data-en="5">A decorator changes how the decorated construct works. In this case, every invocation of <code>.toString()</code> will be “traced” (arguments and result will be logged to the console). <a href="#example-tracing-method-invocations">We’ll see how <code>@trace</code> is implemented later.</a></p>
      <!--more-->
      <p data-en="6">Decorators are mostly an object-oriented feature and popular in OOP frameworks and libraries such as Ember, Angular, Vue, web component frameworks and MobX.</p>
      <p data-en="7">There are two stakeholders when it comes to decorators:</p>
      <ul>
        <li data-en="8">Library authors have to know their API so that they can implement them.</li>
        <li data-en="9">Library users only have to know how to apply them.</li>
      </ul>
      <p data-en="10">This blog post is intended for library authors: We’ll learn how decorators work and use our knowledge to implement several of them.</p>
      <nav class="table-of-contents">
        <ul>
          <li>
            <kskb data-en="11" style="display: block;">
              <a href="#history-of-decorators">The history of decorators (optional section)</a>

            </kskb>
            <ul>
              <li data-en="12">
                <a href="#the-history-of-decorators">The history of decorators</a>
              </li>
              <li data-en="13">
                <a href="#the-history-of-babel%E2%80%99s-decorator-implementation">The history of Babel’s decorator implementation</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="14" style="display: block;">
              <a href="#what-are-decorators%3F">What are decorators?</a>

            </kskb>
            <ul>
              <li data-en="15">
                <a href="#the-shape-of-decorator-functions">The shape of decorator functions</a>
              </li>
              <li data-en="16">
                <a href="#what-can-decorators-do%3F">What can decorators do?</a>
              </li>
              <li data-en="17">
                <a href="#summary-tables">Summary tables</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="18" style="display: block;">
              <a href="#more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)">More information on the syntax and semantics of decorators (optional section)</a>

            </kskb>
            <ul>
              <li data-en="19">
                <a href="#the-syntax-of-decorator-expressions">The syntax of decorator expressions</a>
              </li>
              <li data-en="20">
                <a href="#how-are-decorators-executed%3F">How are decorators executed?</a>
              </li>
              <li data-en="21">
                <a href="#decorator-initializer-execution">When do decorator initializers run?</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="22" style="display: block;">
              <a href="#techniques-for-exposing-data-from-decorators">Techniques for exposing data from decorators</a>

            </kskb>
            <ul>
              <li data-en="23">
                <a href="#storing-exposed-data-in-a-surrounding-scope">Storing exposed data in a surrounding scope</a>
              </li>
              <li data-en="24">
                <a href="#managing-exposed-data-via-a-factory-function">Managing exposed data via a factory function</a>
              </li>
              <li data-en="25">
                <a href="#managing-exposed-data-via-a-class">Managing exposed data via a class</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="26" style="display: block;">
              <a href="#class-decorators">Class decorators</a>

            </kskb>
            <ul>
              <li data-en="27">
                <a href="#example%3A-collecting-instances">Example: collecting instances</a>
              </li>
              <li data-en="28">
                <a href="#making-sure-that-instanceof-works">Making sure that <code>instanceof</code> works</a>
              </li>
              <li data-en="29">
                <a href="#example-freezing-instances">Example: freezing instances</a>
              </li>
              <li data-en="30">
                <a href="#example%3A-making-classes-function-callable">Example: making classes function-callable</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="31" style="display: block;">
              <a href="#class-method-decorators">Class method decorators</a>

            </kskb>
            <ul>
              <li data-en="32">
                <a href="#example-tracing-method-invocations">Example: tracing method invocations</a>
              </li>
              <li data-en="33">
                <a href="#example%3A-binding-methods-to-instances">Example: binding methods to instances</a>
              </li>
              <li data-en="34">
                <a href="#example%3A-applying-functions-to-methods">Example: applying functions to methods</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="35" style="display: block;">
              <a href="#class-getter-decorators%2C-class-setter-decorators">Class getter decorators, class setter decorators</a>

            </kskb>
            <ul>
              <li data-en="36">
                <a href="#example%3A-computing-values-lazily">Example: computing values lazily</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="37" style="display: block;">
              <a href="#class-field-decorators">Class field decorators</a>

            </kskb>
            <ul>
              <li data-en="38">
                <a href="#example%3A-changing-initialization-values-of-fields">Example: changing initialization values of fields</a>
              </li>
              <li data-en="39">
                <a href="#read-only-fields">Example: read-only fields (instance public fields)</a>
              </li>
              <li data-en="40">
                <a href="#example%3A-dependency-injection-(instance-public-fields)">Example: dependency injection (instance public fields)</a>
              </li>
              <li data-en="41">
                <a href="#example-friend-visibility">Example: “friend”&nbsp;visibility (instance private fields)</a>
              </li>
              <li data-en="42">
                <a href="#example%3A-enums-(static-public-fields)">Example: enums (static public fields)</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="43" style="display: block;">
              <a href="#auto-accessors">Auto-accessors: a new member of class definitions</a>

            </kskb>
            <ul>
              <li data-en="44">
                <a href="#why-are-auto-accessors-needed%3F">Why are auto-accessors needed?</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="45" style="display: block;">
              <a href="#class-auto-accessor-decorators">Class auto-accessor decorators</a>

            </kskb>
            <ul>
              <li data-en="46">
                <a href="#read-only-auto-accessors">Example: read-only auto-accessors</a>
              </li>
            </ul>
          </li>
          <li>
            <kskb data-en="47" style="display: block;">
              <a href="#faq">Frequently asked questions</a>

            </kskb>
            <ul>
              <li data-en="48">
                <a href="#function-decorators">Why can’t functions be decorated?</a>
              </li>
            </ul>
          </li>
          <li data-en="49">
            <a href="#more-decorator-related-proposals">More decorator-related proposals</a>
          </li>
          <li>
            <kskb data-en="50" style="display: block;">
              <a href="#resources">Resources</a>

            </kskb>
            <ul>
              <li data-en="51">
                <a href="#decorator-implementations">Implementations</a>
              </li>
              <li data-en="52">
                <a href="#libraries-with-decorators">Libraries with decorators</a>
              </li>
            </ul>
          </li>
          <li data-en="53">
            <a href="#acknowledgements">Acknowledgements</a>
          </li>
          <li data-en="54">
            <a href="#further-reading">Further reading</a>
          </li>
        </ul>
      </nav>
      <h2 id="history-of-decorators" tabindex="-1" data-en="55">The history of decorators (optional section)&nbsp;&nbsp;<a class="heading-anchor" href="#history-of-decorators" aria-hidden="true">#</a></h2>
      <p data-en="56">(This section is optional. If you skip it, you can still understand the remaining content.)</p>
      <p data-en="57">Let’s start by looking at the history of decorators. Among others, two questions will be answered:</p>
      <ul>
        <li data-en="58">Why is this proposal taking so long?</li>
        <li data-en="59">Why does it feel like JavaScript has already had decorators for years?</li>
      </ul>
      <h3 id="the-history-of-decorators" tabindex="-1" data-en="60">The history of decorators&nbsp;&nbsp;<a class="heading-anchor" href="#the-history-of-decorators" aria-hidden="true">#</a></h3>
      <p data-en="61">The following history describes:</p>
      <ul>
        <li data-en="62">How various groups both worked on their own projects and collaborated on the TC39 proposal.</li>
        <li data-en="63">How the TC39 proposal advanced through the stages of <a href="https://exploringjs.com/js/book/ch_history.html#tc39-process">the TC39 process</a> (which start at 0 and end at 4, when the proposal is ready to be added to ECMAScript). Along the way, the proposal changed in numerous ways.</li>
      </ul>
      <p data-en="64">This is a chronological account of relevant events:</p>
      <ul>
        <li>
          <kskb data-en="65" style="display: block;">
            <p data-en="66"><a href="https://github.com/tc39/notes/blob/main/meetings/2014-04/apr-10.md">2014-04-10</a>: Decorators were proposed to TC39 by Yehuda Katz. The proposal advanced to stage 0.</p>

          </kskb>
          <ul>
            <li data-en="67">Katz’s proposal was created in collaboration with Ron Buckton. Discussions about that proposal date back as far as <a href="https://twitter.com/rbuckton/status/1581292852532813825">July 2013</a>.</li>
          </ul>
        </li>
        <li>
          <kskb data-en="68" style="display: block;">
            <p data-en="69">2014-10-22 (ngEurope conference, Paris): The Angular team announced that Angular 2.0 was being written in AtScript and compiled to JavaScript (via Traceur) and Dart. Plans included basing AtScript on TypeScript while adding:</p>

          </kskb>
          <ul>
            <li>
              <kskb data-en="70" style="display: block;">Three kinds of <em>annotations</em>:

              </kskb>
              <ul>
                <li data-en="71"><em>Type annotations</em></li>
                <li data-en="72"><em>Field annotations</em> explicitly declare fields.</li>
                <li data-en="73"><em>Metadata annotations</em> have the same syntax as decorators but only add metadata and don’t change how annotated constructs work.</li>
              </ul>
            </li>
            <li data-en="74">Runtime type checking</li>
            <li data-en="75">Type introspection</li>
          </ul>
        </li>
        <li>
          <kskb data-en="76" style="display: block;">

          </kskb>
          <p data-en="77"><a href="https://github.com/tc39/notes/blob/main/meetings/2015-01/jan-28.md">2015-01-28</a>: Yehuda Katz and Jonathan Turner reported that Katz and the TypeScript team were exchanging ideas.</p>
        </li>
        <li>
          <kskb data-en="78" style="display: block;">

          </kskb>
          <p data-en="79">2015-03-05 (ng-conf, Salt Lake City): The Angular team and the TypeScript team announced that Angular would switch from AtScript to TypeScript and that TypeScript would adopt some of AtScript’s features (especially decorators).</p>
        </li>
        <li>
          <kskb data-en="80" style="display: block;">

          </kskb>
          <p data-en="81"><a href="https://github.com/tc39/notes/blob/main/meetings/2015-03/mar-24.md">2015-03-24</a>: The decorator proposal reached stage 1. At that time, they had <a href="https://github.com/wycats/javascript-decorators">a repository on GitHub</a> (created by Yehuda Katz) that was later moved to <a href="https://github.com/tc39/proposal-decorators">its current location</a>.</p>
        </li>
        <li>
          <kskb data-en="82" style="display: block;">



          </kskb>
          <p data-en="83">2015-07-20: <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-1-5/">TypeScript 1.5</a> came out and supported <a href="https://www.typescriptlang.org/docs/handbook/decorators.html">stage 1 decorators</a> behind the flag <code>--experimentalDecorators</code>.</p>
          <p data-en="84">Several JavaScript projects (e.g. Angular and MobX) used this TypeScript feature which made it look like JavaScript already had decorators.</p>
          <p data-en="85">So far, TypeScript has not supported a newer version of the decorators API. <a href="https://github.com/microsoft/TypeScript/pull/50820">A pull request by Ron Buckton provides support for stage 3 decorators</a> and will likely ship in the release after v4.9.</p>
        </li>
        <li>
          <kskb data-en="86" style="display: block;">

          </kskb>
          <p data-en="87"><a href="https://github.com/tc39/notes/blob/main/meetings/2016-07/jul-28.md">2016-07-28</a>: The proposal reached stage 2, after a presentation by Yehuda Katz and Brian Terlson.</p>
        </li>
        <li>
          <kskb data-en="88" style="display: block;">

          </kskb>
          <p data-en="89"><a href="https://github.com/tc39/notes/blob/main/meetings/2017-07/jul-27.md">2017-07-27</a>: Daniel Ehrenberg held his first decorator presentation, after joining the proposal a few months earlier. He drove its evolution for several years.</p>
        </li>
        <li>
          <kskb data-en="90" style="display: block;">

          </kskb>
          <p data-en="91">Later, Chris Garrett joined the proposal and helped get it to stage 3, which happened <a href="https://github.com/tc39/notes/blob/main/meetings/2022-03/mar-28.md">on 2022-03-28</a>. Decorator metadata was moved to <a href="https://github.com/tc39/proposal-decorator-metadata">a separate proposal</a> that started at stage 2.</p>
        </li>
      </ul>
      <p data-en="92">It took a long time to reach stage 3 because it was difficult to get all stakeholders to agree on an API. Concerns included interactions with other features (such as class members and private state) and performance.</p>
      <h3 id="the-history-of-babel%E2%80%99s-decorator-implementation" tabindex="-1" data-en="93">The history of Babel’s decorator implementation&nbsp;&nbsp;<a class="heading-anchor" href="#the-history-of-babel%E2%80%99s-decorator-implementation" aria-hidden="true">#</a></h3>
      <p data-en="94">Babel closely tracked the evolution of the decorator proposal, thanks to the efforts of Logan Smyth, Nicolò Ribaudo and others:</p>
      <ul>
        <li>
          <kskb data-en="95" style="display: block;">

          </kskb>
          <p data-en="96"><a href="https://babeljs.io/blog/2015/03/31/5.0.0">2015-03-31</a>: Babel 5.0.0 supported stage 1 decorators.</p>
        </li>
        <li>
          <kskb data-en="97" style="display: block;">

          </kskb>
          <p data-en="98"><a href="https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy">2015-11-29</a> An external plugin by Logan Smyth brought support for stage 1 decorators to Babel 6.</p>
        </li>
        <li>
          <kskb data-en="99" style="display: block;">

          </kskb>
          <p data-en="100"><a href="https://babeljs.io/blog/2018/08/27/7.0.0">2018-08-27</a> Babel 7.0.0 supported stage 2 decorators via the official <code>@babel/plugin-proposal-decorators</code>.</p>
        </li>
        <li>
          <kskb data-en="101" style="display: block;">
            <p data-en="102">The official plugin currently supports <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators#version">the following versions</a>:</p>

          </kskb>
          <ul>
            <li data-en="103"><code>"legacy"</code>: <a href="https://github.com/wycats/javascript-decorators/blob/e1bf8d41bfa2591d949dd3bbf013514c8904b913/README.md">stage 1 decorators</a></li>
            <li data-en="104"><code>"2018-09"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/7fa580b40f2c19c561511ea2c978e307ae689a1b">stage 2 decorators</a></li>
            <li data-en="105"><code>"2021-12"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/d6c056fa061646178c34f361bad33d583316dc85">an updated version of the original stage 2 decorators</a></li>
            <li data-en="106"><code>"2022-03"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/8ca65c046dd5e9aa3846a1fe5df343a6f7efd9f8">stage 3 decorators</a></li>
          </ul>
        </li>
      </ul>
      <h2 id="what-are-decorators%3F" tabindex="-1" data-en="107">What are decorators?&nbsp;&nbsp;<a class="heading-anchor" href="#what-are-decorators%3F" aria-hidden="true">#</a></h2>
      <p data-en="108">Decorators let us change how JavaScript constructs (such as classes and methods) work. Let’s revisit our previous example with the decorator <code>@trace</code>:</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  @trace
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'C'</span>;
  }
}
</code></pre>
      <p data-en="109">To implement <code>@trace</code>, we only have to write a function (<a href="#example-tracing-method-invocations">the exact implementation will be shown later</a>):</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trace</span>(<span class="hljs-params">decoratedMethod</span>) {
  <span class="hljs-comment">// Returns a function that replaces `decoratedMethod`.</span>
}
</code></pre>
      <p data-en="110">The class with the decorated method is roughly equivalent to the following code:</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">'C'</span>;
  }
}
C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-title function_">trace</span>(C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>);
</code></pre>
      <p data-en="111">In other words: A decorator is a function that we can apply to language constructs. We do so by putting <code>@</code> plus its name in front of them.</p>
      <p data-en="112">Writing and using decorators is <em>metaprogramming</em>:</p>
      <ul>
        <li data-en="113">We don’t write code that processes user data (<em>programming</em>).</li>
        <li data-en="114">We write code that processes code that processes user data (<em>metaprogramming</em>).</li>
      </ul>
      <p data-en="115">For more information on metaprogramming, see <a href="https://exploringjs.com/deep-js/ch_proxies.html#programming-vs-metaprogramming">section “Programming versus metaprogramming”</a> in “Deep JavaScript”.</p>
      <h3 id="the-shape-of-decorator-functions" tabindex="-1" data-en="116">The shape of decorator functions&nbsp;&nbsp;<a class="heading-anchor" href="#the-shape-of-decorator-functions" aria-hidden="true">#</a></h3>
      <p data-en="117">Before we explore examples of decorator functions, I’d like to take a look at their TypeScript type signature:</p>
      <pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Decorator</span> = <span class="hljs-function">(<span class="hljs-params">
  <span class="hljs-attr">value</span>: <span class="hljs-title class_">DecoratedValue</span>, <span class="hljs-comment">// only fields differ</span>
  <span class="hljs-attr">context</span>: {
    kind: <span class="hljs-built_in">string</span>;
    name: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>;
    addInitializer(initializer: () =&gt; <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>;

    // Don’t always exist:
    <span class="hljs-keyword">static</span>: <span class="hljs-built_in">boolean</span>;
    <span class="hljs-keyword">private</span>: <span class="hljs-built_in">boolean</span>;
    access: {get: () =&gt; <span class="hljs-built_in">unknown</span>, set: (value: <span class="hljs-built_in">unknown</span>) =&gt; <span class="hljs-built_in">void</span>};
  }
</span>) =&gt;</span> <span class="hljs-built_in">void</span> | <span class="hljs-title class_">ReplacementValue</span>; <span class="hljs-comment">// only fields differ</span>
</code></pre>
      <p data-en="118">That is, a decorator is a function. Its parameters are:</p>
      <ul>
        <li data-en="119">The <code>value</code> that the decorator is applied to.</li>
        <li>
          <kskb data-en="120" style="display: block;">The object <code>context</code> with:

          </kskb>
          <ul>
            <li data-en="121">Additional information on <code>value</code> (<code>.static</code>, <code>.private</code>)</li>
            <li data-en="122">A small API (<code>.access</code>, <code>.addInitializer</code>) with metaprogramming functionality</li>
          </ul>
        </li>
      </ul>
      <p data-en="123">Property <code>.kind</code> tells the decorator which kind of JavaScript construct it is applied to. We can use the same function for multiple constructs.</p>
      <p data-en="124">Currently, decorators can be applied to classes, methods, getters, setters, fields, and <em>auto-accessors</em> (a new class member that is explained <a href="#auto-accessors">later</a>). The values of <code>.kind</code> reflect that:</p>
      <ul>
        <li data-en="125"><code>'class'</code></li>
        <li data-en="126"><code>'method'</code></li>
        <li data-en="127"><code>'getter'</code></li>
        <li data-en="128"><code>'setter'</code></li>
        <li data-en="129"><code>'accessor'</code></li>
        <li data-en="130"><code>'field'</code></li>
      </ul>
      <p data-en="131">This is the exact type of <code>Decorator</code>:</p>
      <pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Decorator</span> =
  | <span class="hljs-title class_">ClassDecorator</span>
  | <span class="hljs-title class_">ClassMethodDecorator</span>
  | <span class="hljs-title class_">ClassGetterDecorator</span>
  | <span class="hljs-title class_">ClassSetterDecorator</span>
  | <span class="hljs-title class_">ClassAutoAccessorDecorator</span>
  | <span class="hljs-title class_">ClassFieldDecorator</span>
;
</code></pre>
      <p data-en="132">We’ll soon encounter each of these kinds of decorators and its type signature – where only these parts change:</p>
      <ul>
        <li data-en="133">The type of <code>value</code></li>
        <li data-en="134">Some of the properties of <code>context</code></li>
        <li data-en="135">The return type</li>
      </ul>
      <h3 id="what-can-decorators-do%3F" tabindex="-1" data-en="136">What can decorators do?&nbsp;&nbsp;<a class="heading-anchor" href="#what-can-decorators-do%3F" aria-hidden="true">#</a></h3>
      <p data-en="137">Each decorator has up to four abilities:</p>
      <ul>
        <li>
          <kskb data-en="138" style="display: block;">

          </kskb>
          <p data-en="139">It can change the decorated entity by changing the parameter <code>value</code>.</p>
        </li>
        <li>
          <kskb data-en="140" style="display: block;">
            <p data-en="141">It can replace the decorated entity by returning a compatible value:</p>

          </kskb>
          <ul>
            <li data-en="142">“Compatible”&nbsp;means that the returned value must have the same type as the decorated value – e.g., class decorators must return callable values.</li>
            <li data-en="143">If the decorator doesn’t want to replace the decorated value, it can return <code>undefined</code> – either explicitly or implicitly, by not returning anything.</li>
          </ul>
        </li>
        <li>
          <kskb data-en="144" style="display: block;">

          </kskb>
          <p data-en="145">Exposing access to the decorated entity to others. <code>context.access</code> enables it to do that, via its methods <code>.get()</code> and <code>.set()</code>.</p>
        </li>
        <li>
          <kskb data-en="146" style="display: block;">

          </kskb>
          <p data-en="147">Processing the decorated entity and its container (if it has one), after both exist: That functionality is provided by <code>context.addInitializer</code>. It lets the decorator register an <em>initializer</em> – a callback that is invoked when everything is ready (more details are explained <a href="#decorator-initializer-execution">later</a>).</p>
        </li>
      </ul>
      <p data-en="148">The next subsections demonstrate these abilities. We initially won’t use <code>context.kind</code> to check which kind of construct a decorator is applied to. We will do that later, though.</p>
      <h4 id="ability%3A-replacing-the-decorated-entity" tabindex="-1" data-en="149">Ability: replacing the decorated entity&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-replacing-the-decorated-entity" aria-hidden="true">#</a></h4>
      <p data-en="150">In the following example, the decorator <code>@replaceMethod</code> replaces method <code>.hello()</code> (line B) with a function that it returns (line A).</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">replaceMethod</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-comment">// (A)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">`How are you, <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>?`</span>;
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
  @replaceMethod
  <span class="hljs-title function_">hello</span>(<span class="hljs-params"></span>) { <span class="hljs-comment">// (B)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Hi <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.name}</span>!`</span>;
  }
}

<span class="hljs-keyword">const</span> robin = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Robin'</span>);
assert.<span class="hljs-title function_">equal</span>(
  robin.<span class="hljs-title function_">hello</span>(), <span class="hljs-string">'How are you, Robin?'</span>
);
</code></pre>
      <h4 id="ability%3A-exposing-access-to-the-decorated-entity-to-others" tabindex="-1" data-en="151">Ability: exposing access to the decorated entity to others&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-exposing-access-to-the-decorated-entity-to-others" aria-hidden="true">#</a></h4>
      <p data-en="152">In the next example, the decorator <code>@exposeAccess</code> stores an object in the variable <code>acc</code> that lets us access property <code>.green</code> of the instances of <code>Color</code>.</p>
      <pre><code class="language-js"><span class="hljs-keyword">let</span> acc;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">exposeAccess</span>(<span class="hljs-params">_value, {access}</span>) {
  acc = access;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {
  @exposeAccess
  name = <span class="hljs-string">'green'</span>
}

<span class="hljs-keyword">const</span> green = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>();
assert.<span class="hljs-title function_">equal</span>(
  green.<span class="hljs-property">name</span>, <span class="hljs-string">'green'</span>
);
<span class="hljs-comment">// Using `acc` to get and set `green.name`</span>
assert.<span class="hljs-title function_">equal</span>(
  acc.<span class="hljs-property">get</span>.<span class="hljs-title function_">call</span>(green), <span class="hljs-string">'green'</span>
);
acc.<span class="hljs-property">set</span>.<span class="hljs-title function_">call</span>(green, <span class="hljs-string">'red'</span>);
assert.<span class="hljs-title function_">equal</span>(
  green.<span class="hljs-property">name</span>, <span class="hljs-string">'red'</span>
);
</code></pre>
      <h4 id="ability%3A-processing-the-decorated-entity-and-its-container" tabindex="-1" data-en="153">Ability: processing the decorated entity and its container&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-processing-the-decorated-entity-and-its-container" aria-hidden="true">#</a></h4>
      <p data-en="154">In the following code, we use the decorator <code>@collect</code> to store the keys of decorated methods in the instance property <code>.collectedMethodKeys</code>:</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">collect</span>(<span class="hljs-params">_value, {name, addInitializer}</span>) {
  <span class="hljs-title function_">addInitializer</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-comment">// (A)</span>
    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">collectedMethodKeys</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">collectedMethodKeys</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
    }
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">collectedMethodKeys</span>.<span class="hljs-title function_">add</span>(name);
  });
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  @collect
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {}
  @collect
  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() {}
}
<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();
assert.<span class="hljs-title function_">deepEqual</span>(
  inst.<span class="hljs-property">collectedMethodKeys</span>,
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-string">'toString'</span>, <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>])
);
</code></pre>
      <p data-en="155">The initializer function added by the decorator in line A must be an ordinary function because access to the implicit parameter <code>this</code> is needed. Arrow functions don’t provide this access – their <code>this</code> is statically scoped (like any normal variable).</p>
      <h3 id="summary-tables" tabindex="-1" data-en="156">Summary tables&nbsp;&nbsp;<a class="heading-anchor" href="#summary-tables" aria-hidden="true">#</a></h3>
      <p data-en="157">Type signature:</p>
      <table class="framed" data-en="158">
        <thead>
          <tr>
            <th>Kind of decorator</th>
            <th><code>(input) =&gt; output</code></th>
            <th><code>.access</code></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Class</td>
            <td><code>(func) =&gt; func2</code></td>
            <td>–</td>
          </tr>
          <tr>
            <td>Method</td>
            <td><code>(func) =&gt; func2</code></td>
            <td><code>{get}</code></td>
          </tr>
          <tr>
            <td>Getter</td>
            <td><code>(func) =&gt; func2</code></td>
            <td><code>{get}</code></td>
          </tr>
          <tr>
            <td>Setter</td>
            <td><code>(func) =&gt; func2</code></td>
            <td><code>{set}</code></td>
          </tr>
          <tr>
            <td>Auto-accessor</td>
            <td><code>({get,set}) =&gt; {get,set,init}</code></td>
            <td><code>{get,set}</code></td>
          </tr>
          <tr>
            <td>Field</td>
            <td><code>() =&gt; (initValue)=&gt;initValue2</code></td>
            <td><code>{get,set}</code></td>
          </tr>
        </tbody>
      </table>
      <p data-en="159">Value of <code>this</code> in functions:</p>
      <table class="framed" data-en="160">
        <thead>
          <tr>
            <th><code>this</code> is →</th>
            <th><code>undefined</code></th>
            <th>Class</th>
            <th>Instance</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Decorator function</td>
            <td>✔</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>Static initializer</td>
            <td></td>
            <td>✔</td>
            <td></td>
          </tr>
          <tr>
            <td>Non-static initializer</td>
            <td></td>
            <td></td>
            <td>✔</td>
          </tr>
          <tr>
            <td>Static field decorator result</td>
            <td></td>
            <td>✔</td>
            <td></td>
          </tr>
          <tr>
            <td>Non-static field decorator result</td>
            <td></td>
            <td></td>
            <td>✔</td>
          </tr>
        </tbody>
      </table>
      <h2 id="more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)" tabindex="-1" data-en="161">More information on the syntax and semantics of decorators (optional section)&nbsp;&nbsp;<a class="heading-anchor" href="#more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)" aria-hidden="true">#</a></h2>
      <p data-en="162">(This section is optional. If you skip it, you can still understand the remaining content.)</p>
      <h3 id="the-syntax-of-decorator-expressions" tabindex="-1" data-en="163">The syntax of decorator expressions&nbsp;&nbsp;<a class="heading-anchor" href="#the-syntax-of-decorator-expressions" aria-hidden="true">#</a></h3>
      <ul>
        <li data-en="164">A decorator expression starts with a chain of one or more identifiers, separated by dots. Each identifier except the first one can be private (prefix <code>#</code>). Square brackets <code>[]</code> are not allowed.</li>
        <li data-en="165">Optional at the end: function call arguments in parentheses. The next subsection explains what that means.</li>
        <li data-en="166">We can use any expression if we put it in parentheses:
          <pre><code class="language-js">@(«expr»)
</code></pre>
        </li>
      </ul>
      <p data-en="167">Wherever decorators are allowed, we can use more than one of them. The following code demonstrates decorator syntax:</p>
      <pre><code class="language-js"><span class="hljs-comment">// Five decorators for MyClass</span>

@myFunc
@<span class="hljs-title function_">myFuncFactory</span>(<span class="hljs-string">'arg1'</span>, <span class="hljs-string">'arg2'</span>)

@libraryModule.<span class="hljs-property">prop</span>
@someObj.<span class="hljs-title function_">method</span>(<span class="hljs-number">123</span>)

@(<span class="hljs-title function_">wrap</span>(dict[<span class="hljs-string">'prop'</span>])) <span class="hljs-comment">// arbitrary expression</span>

<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {}
</code></pre>
      <h3 id="how-are-decorators-executed%3F" tabindex="-1" data-en="168">How are decorators executed?&nbsp;&nbsp;<a class="heading-anchor" href="#how-are-decorators-executed%3F" aria-hidden="true">#</a></h3>
      <ul>
        <li>
          <kskb data-en="169" style="display: block;">

          </kskb>
          <p data-en="170">Evaluation: The expressions after the <code>@</code> symbols are evaluated during the execution of the class definition, along with computed property keys and static fields (see code below). The results must be functions. They are stored in temporary locations (think local variables), to be invoked later.</p>
        </li>
        <li>
          <kskb data-en="171" style="display: block;">

          </kskb>
          <p data-en="172">Invocation: The decorator functions are called later during the execution of a class definition, after methods have been evaluated but before constructor and prototype have been assembled. Once again the results are stored in temporary locations.</p>
        </li>
        <li>
          <kskb data-en="173" style="display: block;">

          </kskb>
          <p data-en="174">Application: After all decorator functions were invoked, their results are used, which can affect constructor and prototype. Class decorators are applied after all method and field decorators.</p>
        </li>
      </ul>
      <p data-en="175">The following code illustrates in which order decorator expressions, computed property keys and field initializers are evaluated:</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">decorate</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`EVALUATE @decorate(): <span class="hljs-subst">${str}</span>`</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`APPLY @decorate(): <span class="hljs-subst">${str}</span>`</span>); <span class="hljs-comment">// (A)</span>
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);
  <span class="hljs-keyword">return</span> str;
}

@<span class="hljs-title function_">decorate</span>(<span class="hljs-string">'class'</span>)
<span class="hljs-keyword">class</span> <span class="hljs-title class_">TheClass</span> {

  @<span class="hljs-title function_">decorate</span>(<span class="hljs-string">'static field'</span>)
  <span class="hljs-keyword">static</span> staticField = <span class="hljs-title function_">log</span>(<span class="hljs-string">'static field value'</span>);

  @<span class="hljs-title function_">decorate</span>(<span class="hljs-string">'prototype method'</span>)
  [<span class="hljs-title function_">log</span>(<span class="hljs-string">'computed key'</span>)]() {}

  @<span class="hljs-title function_">decorate</span>(<span class="hljs-string">'instance field'</span>)
  instanceField = <span class="hljs-title function_">log</span>(<span class="hljs-string">'instance field value'</span>);
    <span class="hljs-comment">// This initializer only runs if we instantiate the class</span>
}

<span class="hljs-comment">// Output:</span>
<span class="hljs-comment">// EVALUATE @decorate(): class</span>
<span class="hljs-comment">// EVALUATE @decorate(): static field</span>
<span class="hljs-comment">// EVALUATE @decorate(): prototype method</span>
<span class="hljs-comment">// computed key</span>
<span class="hljs-comment">// EVALUATE @decorate(): instance field</span>
<span class="hljs-comment">// APPLY @decorate(): prototype method</span>
<span class="hljs-comment">// APPLY @decorate(): static field</span>
<span class="hljs-comment">// APPLY @decorate(): instance field</span>
<span class="hljs-comment">// APPLY @decorate(): class</span>
<span class="hljs-comment">// static field value</span>
</code></pre>
      <p data-en="176">Function <code>decorate</code> is invoked whenever the expression <code>decorate()</code> after the <code>@</code> symbol is evaluated. In line A, it returns the actual decorator function, which is applied later.</p>
      <h3 id="decorator-initializer-execution" tabindex="-1" data-en="177">When do decorator initializers run?&nbsp;&nbsp;<a class="heading-anchor" href="#decorator-initializer-execution" aria-hidden="true">#</a></h3>
      <p data-en="178">When a decorator initializer runs, depends on the kind of decorator:</p>
      <ul>
        <li>
          <kskb data-en="179" style="display: block;">

          </kskb>
          <p data-en="180">Class decorator initializers run after the class is fully defined and all static fields were initialized.</p>
        </li>
        <li>
          <kskb data-en="181" style="display: block;">

          </kskb>
          <p data-en="182">The initializers of non-static class element decorators run during instantiation, before instance fields are initialized.</p>
        </li>
        <li>
          <kskb data-en="183" style="display: block;">

          </kskb>
          <p data-en="184">The initializers of static class element decorators run during class definition, before static fields are defined but after other all other class elements were defined.</p>
        </li>
      </ul>
      <p data-en="185">Why is that? For non-static initializers, we have five options – they can run:</p>
      <ol>
        <li data-en="186">Before <code>super</code></li>
        <li data-en="187">After <code>super</code>, before field initialization</li>
        <li data-en="188">Interleaved between fields in definition order</li>
        <li data-en="189">After field initialization, before child class instantiation</li>
        <li data-en="190">After child class instantiation</li>
      </ol>
      <p data-en="191">Why was #2 chosen?</p>
      <ul>
        <li>
          <kskb data-en="192" style="display: block;">

          </kskb>
          <p data-en="193">#1 was rejected because decorator initializers must be able to access <code>this</code>, which isn’t possible before <code>super</code> runs.</p>
        </li>
        <li>
          <kskb data-en="194" style="display: block;">

          </kskb>
          <p data-en="195">#3 was rejected because running all decorator initializers at the same time is simpler than ensuring that they are properly interleaved.</p>
        </li>
      </ul>
      <ul>
        <li>
          <kskb data-en="196" style="display: block;">

          </kskb>
          <p data-en="197">#4 was rejected because running decorator initializers before fields ensures that fields don’t see partially initialized methods. For example, if there are <code>@bind</code> decorators, then field initializers can rely on the decorated methods being bound.</p>
        </li>
        <li>
          <kskb data-en="198" style="display: block;">

          </kskb>
          <p data-en="199">#5 was rejected because it would allow superclasses to interfere with subclasses, which would break the rule that superclasses should not be aware of their subclasses.</p>
        </li>
      </ul>
      <p data-en="200">The following code demonstrates in which order Babel currently invokes decorator initializers. Note that Babel does not yet support initializers for class field decorators (which was a recent change to the decorators API).</p>
      <pre><code class="language-js"><span class="hljs-comment">// We wait until after instantiation before we log steps,</span>
<span class="hljs-comment">// so that we can compare the value of `this` with the instance.</span>
<span class="hljs-keyword">const</span> steps = [];
<span class="hljs-keyword">function</span> <span class="hljs-title function_">push</span>(<span class="hljs-params">msg, _this</span>) {
  steps.<span class="hljs-title function_">push</span>({msg, _this});
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">pushStr</span>(<span class="hljs-params">str</span>) {
  steps.<span class="hljs-title function_">push</span>(str);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">init</span>(<span class="hljs-params">_value, {name, addInitializer}</span>) {
  <span class="hljs-title function_">pushStr</span>(<span class="hljs-string">`@init <span class="hljs-subst">${name}</span>`</span>);
  <span class="hljs-keyword">if</span> (addInitializer) {
    <span class="hljs-title function_">addInitializer</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-title function_">push</span>(<span class="hljs-string">`DECORATOR INITIALIZER <span class="hljs-subst">${name}</span>`</span>, <span class="hljs-variable language_">this</span>);
    });
  }
}

@init <span class="hljs-keyword">class</span> <span class="hljs-title class_">TheClass</span> {
  <span class="hljs-comment">//--- Static ---</span>

  <span class="hljs-keyword">static</span> {
    <span class="hljs-title function_">pushStr</span>(<span class="hljs-string">'static block'</span>);
  }

  @init <span class="hljs-keyword">static</span> <span class="hljs-title function_">staticMethod</span>(<span class="hljs-params"></span>) {}
  @init <span class="hljs-keyword">static</span> accessor staticAcc = <span class="hljs-title function_">pushStr</span>(<span class="hljs-string">'staticAcc'</span>);
  @init <span class="hljs-keyword">static</span> staticField = <span class="hljs-title function_">pushStr</span>(<span class="hljs-string">'staticField'</span>);

  <span class="hljs-comment">//--- Non-static ---</span>

  @init <span class="hljs-title function_">prototypeMethod</span>(<span class="hljs-params"></span>) {}
  @init accessor instanceAcc = <span class="hljs-title function_">pushStr</span>(<span class="hljs-string">'instanceAcc'</span>);
  @init instanceField = <span class="hljs-title function_">pushStr</span>(<span class="hljs-string">'instanceField'</span>);

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">pushStr</span>(<span class="hljs-string">'constructor'</span>);
  }
}

<span class="hljs-title function_">pushStr</span>(<span class="hljs-string">'===== Instantiation ====='</span>);
<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TheClass</span>();

<span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> step <span class="hljs-keyword">of</span> steps) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> step === <span class="hljs-string">'string'</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(step);
    <span class="hljs-keyword">continue</span>;
  }
  <span class="hljs-keyword">let</span> thisDesc = <span class="hljs-string">'???'</span>;
  <span class="hljs-keyword">if</span> (step.<span class="hljs-property">_this</span> === <span class="hljs-title class_">TheClass</span>) {
    thisDesc = <span class="hljs-title class_">TheClass</span>.<span class="hljs-property">name</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (step.<span class="hljs-property">_this</span> === inst) {
    thisDesc = <span class="hljs-string">'inst'</span>;
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (step.<span class="hljs-property">_this</span> === <span class="hljs-literal">undefined</span>) {
    thisDesc = <span class="hljs-string">'undefined'</span>;
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`<span class="hljs-subst">${step.msg}</span> (this===<span class="hljs-subst">${thisDesc}</span>)`</span>);
}

<span class="hljs-comment">// Output:</span>
<span class="hljs-comment">// @init staticMethod</span>
<span class="hljs-comment">// @init staticAcc</span>
<span class="hljs-comment">// @init prototypeMethod</span>
<span class="hljs-comment">// @init instanceAcc</span>
<span class="hljs-comment">// @init staticField</span>
<span class="hljs-comment">// @init instanceField</span>
<span class="hljs-comment">// @init TheClass</span>
<span class="hljs-comment">// DECORATOR INITIALIZER staticMethod (this===TheClass)</span>
<span class="hljs-comment">// DECORATOR INITIALIZER staticAcc (this===TheClass)</span>
<span class="hljs-comment">// static block</span>
<span class="hljs-comment">// staticAcc</span>
<span class="hljs-comment">// staticField</span>
<span class="hljs-comment">// DECORATOR INITIALIZER TheClass (this===TheClass)</span>
<span class="hljs-comment">// ===== Instantiation =====</span>
<span class="hljs-comment">// DECORATOR INITIALIZER prototypeMethod (this===inst)</span>
<span class="hljs-comment">// DECORATOR INITIALIZER instanceAcc (this===inst)</span>
<span class="hljs-comment">// instanceAcc</span>
<span class="hljs-comment">// instanceField</span>
<span class="hljs-comment">// constructor</span>
</code></pre>
      <h2 id="techniques-for-exposing-data-from-decorators" tabindex="-1" data-en="201">Techniques for exposing data from decorators&nbsp;&nbsp;<a class="heading-anchor" href="#techniques-for-exposing-data-from-decorators" aria-hidden="true">#</a></h2>
      <p data-en="202">Sometimes decorators collect data. Let’s explore how they can make this data available to other parties.</p>
      <h3 id="storing-exposed-data-in-a-surrounding-scope" tabindex="-1" data-en="203">Storing exposed data in a surrounding scope&nbsp;&nbsp;<a class="heading-anchor" href="#storing-exposed-data-in-a-surrounding-scope" aria-hidden="true">#</a></h3>
      <p data-en="204">The simplest solution is to store data in a location in a surrounding scope. For example, the decorator <code>@collect</code> collects classes and stores them in the Set <code>classes</code> (line A):</p>
      <pre><code class="language-js"><span class="hljs-keyword">const</span> classes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(); <span class="hljs-comment">// (A)</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">collect</span>(<span class="hljs-params">value, {kind, addInitializer}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'class'</span>) {
    classes.<span class="hljs-title function_">add</span>(value);
  }
}

@collect
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {}
@collect
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> {}
@collect
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {}

assert.<span class="hljs-title function_">deepEqual</span>(
  classes, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([A, B, C])
);
</code></pre>
      <p data-en="205">The downside of this approach is that it doesn’t work if a decorator comes from another module.</p>
      <h3 id="managing-exposed-data-via-a-factory-function" tabindex="-1" data-en="206">Managing exposed data via a factory function&nbsp;&nbsp;<a class="heading-anchor" href="#managing-exposed-data-via-a-factory-function" aria-hidden="true">#</a></h3>
      <p data-en="207">A more sophisticated approach is to use a factory function <code>createClassCollector()</code> that returns:</p>
      <ul>
        <li data-en="208">A class decorator <code>collect</code></li>
        <li data-en="209">A Set <code>classes</code>, to which the decorator will add the classes it collects</li>
      </ul>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createClassCollector</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> classes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">collect</span>(<span class="hljs-params">value, {kind, addInitializer}</span>) {
    <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'class'</span>) {
      classes.<span class="hljs-title function_">add</span>(value);
    }
  }
  <span class="hljs-keyword">return</span> {
    classes,
    collect,
  };
}

<span class="hljs-keyword">const</span> {classes, collect} = <span class="hljs-title function_">createClassCollector</span>();

@collect
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {}
@collect
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> {}
@collect
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {}

assert.<span class="hljs-title function_">deepEqual</span>(
  classes, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([A, B, C])
);
</code></pre>
      <h3 id="managing-exposed-data-via-a-class" tabindex="-1" data-en="210">Managing exposed data via a class&nbsp;&nbsp;<a class="heading-anchor" href="#managing-exposed-data-via-a-class" aria-hidden="true">#</a></h3>
      <p data-en="211">Instead of a factory function, we can also use a class. It has two members:</p>
      <ul>
        <li data-en="212"><code>.classes</code>, a Set with the collected classes</li>
        <li data-en="213"><code>.install</code>, a class decorator</li>
      </ul>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassCollector</span> {
  classes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
  install = <span class="hljs-function">(<span class="hljs-params">value, {kind}</span>) =&gt;</span> { <span class="hljs-comment">// (A)</span>
    <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'class'</span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">classes</span>.<span class="hljs-title function_">add</span>(value); <span class="hljs-comment">// (B)</span>
    }
  };
}

<span class="hljs-keyword">const</span> collector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassCollector</span>();

@collector.<span class="hljs-property">install</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> {}
@collector.<span class="hljs-property">install</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span> {}
@collector.<span class="hljs-property">install</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {}

assert.<span class="hljs-title function_">deepEqual</span>(
  collector.<span class="hljs-property">classes</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([A, B, C])
);
</code></pre>
      <p data-en="214">We implemented <code>.install</code> by assigning an arrow function to a public instance field (line A). Instance field initializers run in scopes where <code>this</code> refers to the current instance. That is also the outer scope of the arrow function and explains what value <code>this</code> has in line B.</p>
      <p data-en="215">We could also implement <code>.install</code> via a getter, but then we’d have to return a new function whenever <code>.install</code> is read.</p>
      <h2 id="class-decorators" tabindex="-1" data-en="216">Class decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-decorators" aria-hidden="true">#</a></h2>
      <p data-en="217">Class decorators have the following type signature:</p>
      <pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ClassDecorator</span> = <span class="hljs-function">(<span class="hljs-params">
  <span class="hljs-attr">value</span>: <span class="hljs-title class_">Function</span>,
  <span class="hljs-attr">context</span>: {
    kind: <span class="hljs-string">'class'</span>;
    name: <span class="hljs-built_in">string</span> | <span class="hljs-literal">undefined</span>;
    addInitializer(initializer: () =&gt; <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_">Function</span> | <span class="hljs-built_in">void</span>;
</code></pre>
      <p data-en="218">Abilities of a class decorator:</p>
      <ul>
        <li data-en="219">It can change the decorated class by changing <code>value</code>.</li>
        <li data-en="220">It can replace the decorated class by returning a callable value.</li>
        <li data-en="221">It can register initializers, which are called after the decorated class is fully set up.</li>
        <li data-en="222">It does not get <code>context.access</code> because classes are not members of other language constructs (whereas, e.g., methods are members of classes).</li>
      </ul>
      <h3 id="example%3A-collecting-instances" tabindex="-1" data-en="223">Example: collecting instances&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-collecting-instances" aria-hidden="true">#</a></h3>
      <p data-en="224">In the next example, we use a decorator to collect all instances of a decorated class:</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">InstanceCollector</span> {
  instances = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();
  install = <span class="hljs-function">(<span class="hljs-params">value, {kind}</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'class'</span>) {
      <span class="hljs-keyword">const</span> _this = <span class="hljs-variable language_">this</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) { <span class="hljs-comment">// (A)</span>
        <span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">value</span>(...args); <span class="hljs-comment">// (B)</span>
        _this.<span class="hljs-property">instances</span>.<span class="hljs-title function_">add</span>(inst);
        <span class="hljs-keyword">return</span> inst;
      };
    }
  };
}

<span class="hljs-keyword">const</span> collector = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InstanceCollector</span>();

@collector.<span class="hljs-property">install</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {}

<span class="hljs-keyword">const</span> inst1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
<span class="hljs-keyword">const</span> inst2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
<span class="hljs-keyword">const</span> inst3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();

assert.<span class="hljs-title function_">deepEqual</span>(
  collector.<span class="hljs-property">instances</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([inst1, inst2, inst3])
);
</code></pre>
      <p data-en="225">The only way in which we can collect all instances of a given class via a decorator is by wrapping that class. The decorator in the field <code>.install</code> does that by returning a function (line A) that new-calls the decorated <code>value</code> (line B) and collects and returns the result.</p>
      <p data-en="226">Note that we can’t return an arrow function in line A, because arrow functions can’t be new-called.</p>
      <p data-en="227">One downside of this approach is that it breaks <code>instanceof</code>:</p>
      <pre><code class="language-js">assert.<span class="hljs-title function_">equal</span>(
  inst1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyClass</span>,
  <span class="hljs-literal">false</span>
);
</code></pre>
      <p data-en="228">The next subsection explains how we can fix that.</p>
      <h3 id="making-sure-that-instanceof-works" tabindex="-1" data-en="229">Making sure that <code>instanceof</code> works&nbsp;&nbsp;<a class="heading-anchor" href="#making-sure-that-instanceof-works" aria-hidden="true">#</a></h3>
      <p data-en="230">In this section, we use the simple decorator <code>@countInstances</code> to show how we can support <code>instanceof</code> for wrapped classes.</p>
      <h4 id="enabling-instanceof-via-.prototype" tabindex="-1" data-en="231">Enabling <code>instanceof</code> via <code>.prototype</code>&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-.prototype" aria-hidden="true">#</a></h4>
      <p data-en="232">One way of enabling <code>instanceof</code> is to set the <code>.prototype</code> of the wrapper function to the <code>.prototype</code> of the wrapped <code>value</code> (line A):</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">countInstances</span>(<span class="hljs-params">value</span>) {
  <span class="hljs-keyword">const</span> _this = <span class="hljs-variable language_">this</span>;
  <span class="hljs-keyword">let</span> instanceCount = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// The wrapper must be new-callable</span>
  <span class="hljs-keyword">const</span> wrapper = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
    instanceCount++;
    <span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title function_">value</span>(...args);
    <span class="hljs-comment">// Change the instance</span>
    instance.<span class="hljs-property">count</span> = instanceCount;
    <span class="hljs-keyword">return</span> instance;
  };
  wrapper.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = value.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>; <span class="hljs-comment">// (A)</span>
  <span class="hljs-keyword">return</span> wrapper;
}

@countInstances
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {}

<span class="hljs-keyword">const</span> inst1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
assert.<span class="hljs-title function_">ok</span>(inst1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyClass</span>);
assert.<span class="hljs-title function_">equal</span>(inst1.<span class="hljs-property">count</span>, <span class="hljs-number">1</span>);

<span class="hljs-keyword">const</span> inst2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
assert.<span class="hljs-title function_">ok</span>(inst2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyClass</span>);
assert.<span class="hljs-title function_">equal</span>(inst2.<span class="hljs-property">count</span>, <span class="hljs-number">2</span>);
</code></pre>
      <p data-en="233">Why does that work? Because the following expressions are equivalent:</p>
      <pre><code class="language-js">inst <span class="hljs-keyword">instanceof</span> C
C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-title function_">isPrototypeOf</span>(inst)
</code></pre>
      <p data-en="234">For more information on <code>instanceof</code>, see <a href="https://exploringjs.com/js/book/ch_classes.html#instanceof-operator">“Exploring JavaScript”</a>.</p>
      <h4 id="enabling-instanceof-via-symbol.hasinstance" tabindex="-1" data-en="235">Enabling <code>instanceof</code> via <code>Symbol.hasInstance</code>&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-symbol.hasinstance" aria-hidden="true">#</a></h4>
      <p data-en="236">Another option for enabling <code>instanceof</code> is to give the wrapper function a method whose key is <code>Symbol.hasInstance</code> (line A):</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">countInstances</span>(<span class="hljs-params">value</span>) {
  <span class="hljs-keyword">const</span> _this = <span class="hljs-variable language_">this</span>;
  <span class="hljs-keyword">let</span> instanceCount = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// The wrapper must be new-callable</span>
  <span class="hljs-keyword">const</span> wrapper = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
    instanceCount++;
    <span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title function_">value</span>(...args);
    <span class="hljs-comment">// Change the instance</span>
    instance.<span class="hljs-property">count</span> = instanceCount;
    <span class="hljs-keyword">return</span> instance;
  };
  <span class="hljs-comment">// Property is read-only, so we can’t use assignment</span>
  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <span class="hljs-comment">// (A)</span>
    wrapper, <span class="hljs-title class_">Symbol</span>.<span class="hljs-property">hasInstance</span>,
    {
      <span class="hljs-attr">value</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) {
        <span class="hljs-keyword">return</span> x <span class="hljs-keyword">instanceof</span> value; 
      }
    }
  );
  <span class="hljs-keyword">return</span> wrapper;
}

@countInstances
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {}

<span class="hljs-keyword">const</span> inst1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
assert.<span class="hljs-title function_">ok</span>(inst1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyClass</span>);
assert.<span class="hljs-title function_">equal</span>(inst1.<span class="hljs-property">count</span>, <span class="hljs-number">1</span>);

<span class="hljs-keyword">const</span> inst2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
assert.<span class="hljs-title function_">ok</span>(inst2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyClass</span>);
assert.<span class="hljs-title function_">equal</span>(inst2.<span class="hljs-property">count</span>, <span class="hljs-number">2</span>);
</code></pre>
      <p data-en="237">“Exploring JavaScript” has <a href="https://exploringjs.com/js/book/ch_symbols.html#publicly-known-symbols">more information on <code>Symbol.hasInstance</code></a>.</p>
      <h4 id="enabling-instanceof-via-subclassing" tabindex="-1" data-en="238">Enabling <code>instanceof</code> via subclassing&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-subclassing" aria-hidden="true">#</a></h4>
      <p data-en="239">We can also enable <code>instanceof</code> by returning a subclass of <code>value</code> (line A):</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">countInstances</span>(<span class="hljs-params">value</span>) {
  <span class="hljs-keyword">const</span> _this = <span class="hljs-variable language_">this</span>;
  <span class="hljs-keyword">let</span> instanceCount = <span class="hljs-number">0</span>;
  <span class="hljs-comment">// The wrapper must be new-callable</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">extends</span> value { <span class="hljs-comment">// (A)</span>
    <span class="hljs-title function_">constructor</span>(<span class="hljs-params">...args</span>) {
      <span class="hljs-variable language_">super</span>(...args);
      instanceCount++;
      <span class="hljs-comment">// Change the instance</span>
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = instanceCount;
    }
  };
}

@countInstances
<span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> {}

<span class="hljs-keyword">const</span> inst1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
assert.<span class="hljs-title function_">ok</span>(inst1 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyClass</span>);
assert.<span class="hljs-title function_">equal</span>(inst1.<span class="hljs-property">count</span>, <span class="hljs-number">1</span>);

<span class="hljs-keyword">const</span> inst2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyClass</span>();
assert.<span class="hljs-title function_">ok</span>(inst2 <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyClass</span>);
assert.<span class="hljs-title function_">equal</span>(inst2.<span class="hljs-property">count</span>, <span class="hljs-number">2</span>);
</code></pre>
      <h3 id="example-freezing-instances" tabindex="-1" data-en="240">Example: freezing instances&nbsp;&nbsp;<a class="heading-anchor" href="#example-freezing-instances" aria-hidden="true">#</a></h3>
      <p data-en="241">The decorator class <code>@freeze</code> freezes all instances produced by the classes it decorates:</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">freeze</span> (<span class="hljs-params">value, {kind}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'class'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
      <span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">value</span>(...args);
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(inst);
    }
  }
}

@freeze
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
}

<span class="hljs-keyword">const</span> red = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">'red'</span>);
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> red.<span class="hljs-property">name</span> = <span class="hljs-string">'green'</span>,
  <span class="hljs-regexp">/^TypeError: Cannot assign to read only property 'name'/</span>
);
</code></pre>
      <p data-en="242">This decorator has downsides:</p>
      <ul>
        <li data-en="243">It breaks <code>instanceof</code>. We have already seen how to fix this.</li>
        <li>
          <kskb data-en="244" style="display: block;">Subclassing a decorated class doesn’t work well:

          </kskb>
          <ul>
            <li data-en="245">The way in which constructors are connected isn’t ideal – with a wrapped constructor in the mix. This can be partially fixed by returning a subclass of the decorated <code>value</code>.</li>
            <li data-en="246">Subclasses can’t set up properties, because their <code>this</code> is immutable. There is no way to avoid this downside.</li>
          </ul>
        </li>
      </ul>
      <p data-en="247">The last downside could be avoided by giving class decorators access to the instances of the decorated classes after all constructors were executed.</p>
      <p data-en="248">This would change how inheritance works because a superclass could now change properties that were added by subclasses. Therefore, it’s not sure if such a mechanism is in the cards.</p>
      <h3 id="example%3A-making-classes-function-callable" tabindex="-1" data-en="249">Example: making classes function-callable&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-making-classes-function-callable" aria-hidden="true">#</a></h3>
      <p data-en="250">Classes decorated by <code>@functionCallable</code> can be invoked by function calls instead of the <code>new</code> operator:</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">functionCallable</span>(<span class="hljs-params">value, {kind}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'class'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>.<span class="hljs-property">target</span> !== <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">'This function can’t be new-invoked'</span>);
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">value</span>(...args);
    }
  }
}

@functionCallable
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
}
<span class="hljs-keyword">const</span> robin = <span class="hljs-title class_">Person</span>(<span class="hljs-string">'Robin'</span>);
assert.<span class="hljs-title function_">equal</span>(
  robin.<span class="hljs-property">name</span>, <span class="hljs-string">'Robin'</span>
);
</code></pre>
      <h2 id="class-method-decorators" tabindex="-1" data-en="251">Class method decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-method-decorators" aria-hidden="true">#</a></h2>
      <p data-en="252">Class method decorators have the following type signature:</p>
      <pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ClassMethodDecorator</span> = <span class="hljs-function">(<span class="hljs-params">
  <span class="hljs-attr">value</span>: <span class="hljs-title class_">Function</span>,
  <span class="hljs-attr">context</span>: {
    kind: <span class="hljs-string">'method'</span>;
    name: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>;
    <span class="hljs-keyword">static</span>: <span class="hljs-built_in">boolean</span>;
    <span class="hljs-keyword">private</span>: <span class="hljs-built_in">boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in">unknown</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_">Function</span> | <span class="hljs-built_in">void</span>;
</code></pre>
      <p data-en="253">Abilities of a method decorator:</p>
      <ul>
        <li data-en="254">It can change the decorated method by changing <code>value</code>.</li>
        <li data-en="255">It can replace the decorated method by returning a function.</li>
        <li data-en="256">It can register initializers.</li>
        <li data-en="257"><code>context.access</code> only supports getting the value of its property, not setting it.</li>
      </ul>
      <p data-en="258">Constructors can’t be decorated: They look like methods, but they aren’t really methods.</p>
      <h3 id="example-tracing-method-invocations" tabindex="-1" data-en="259">Example: tracing method invocations&nbsp;&nbsp;<a class="heading-anchor" href="#example-tracing-method-invocations" aria-hidden="true">#</a></h3>
      <p data-en="260">The decorator <code>@trace</code> wraps methods so that their invocations and results are logged to the console:</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trace</span>(<span class="hljs-params">value, {kind, name}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'method'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`CALL <span class="hljs-subst">${name}</span>: <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(args)}</span>`</span>);
      <span class="hljs-keyword">const</span> result = value.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'=&gt; '</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(result));
      <span class="hljs-keyword">return</span> result;
    };
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilder</span> {
  #str = <span class="hljs-string">''</span>;
  @trace
  <span class="hljs-title function_">add</span>(<span class="hljs-params">str</span>) {
    <span class="hljs-variable language_">this</span>.#str += str;
  }
  @trace
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#str;
  }
}

<span class="hljs-keyword">const</span> sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();
sb.<span class="hljs-title function_">add</span>(<span class="hljs-string">'Home'</span>);
sb.<span class="hljs-title function_">add</span>(<span class="hljs-string">'page'</span>);
assert.<span class="hljs-title function_">equal</span>(
  sb.<span class="hljs-title function_">toString</span>(), <span class="hljs-string">'Homepage'</span>
);

<span class="hljs-comment">// Output:</span>
<span class="hljs-comment">// CALL add: ["Home"]</span>
<span class="hljs-comment">// =&gt; undefined</span>
<span class="hljs-comment">// CALL add: ["page"]</span>
<span class="hljs-comment">// =&gt; undefined</span>
<span class="hljs-comment">// CALL toString: []</span>
<span class="hljs-comment">// =&gt; "Homepage"</span>
</code></pre>
      <h3 id="example%3A-binding-methods-to-instances" tabindex="-1" data-en="261">Example: binding methods to instances&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-binding-methods-to-instances" aria-hidden="true">#</a></h3>
      <p data-en="262">Normally, extracting methods (line A) means that we can’t function-call them because that sets <code>this</code> to <code>undefined</code>:</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color1</span> {
  #name;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.#name = name;
  }
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Color(<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.#name}</span>)`</span>;
  }
}

<span class="hljs-keyword">const</span> green1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color1</span>(<span class="hljs-string">'green'</span>);
<span class="hljs-keyword">const</span> toString1 = green1.<span class="hljs-property">toString</span>; <span class="hljs-comment">// (A)</span>
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">toString1</span>(),
  <span class="hljs-regexp">/^TypeError: Cannot read properties of undefined/</span>
);
</code></pre>
      <p data-en="263">We can fix that via the decorator <code>@bind</code>:</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bind</span>(<span class="hljs-params">value, {kind, name, addInitializer}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'method'</span>) {
    <span class="hljs-title function_">addInitializer</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) { <span class="hljs-comment">// (B)</span>
      <span class="hljs-variable language_">this</span>[name] = value.<span class="hljs-title function_">bind</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">// (C)</span>
    });
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Color2</span> {
  #name;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.#name = name;
  }
  @bind
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Color(<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.#name}</span>)`</span>;
  }
}

<span class="hljs-keyword">const</span> green2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color2</span>(<span class="hljs-string">'green'</span>);
<span class="hljs-keyword">const</span> toString2 = green2.<span class="hljs-property">toString</span>;
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title function_">toString2</span>(), <span class="hljs-string">'Color(green)'</span>
);

<span class="hljs-comment">// The own property green2.toString is different</span>
<span class="hljs-comment">// from Color2.prototype.toString</span>
assert.<span class="hljs-title function_">ok</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(green2, <span class="hljs-string">'toString'</span>));
assert.<span class="hljs-title function_">notEqual</span>(
  green2.<span class="hljs-property">toString</span>,
  <span class="hljs-title class_">Color2</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>
);
</code></pre>
      <p data-en="264">Per decorated method, the initializer registered in line B is invoked whenever an instance is created and adds an own property whose value is a function with a fixed <code>this</code> (line C).</p>
      <h3 id="example%3A-applying-functions-to-methods" tabindex="-1" data-en="265">Example: applying functions to methods&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-applying-functions-to-methods" aria-hidden="true">#</a></h3>
      <p data-en="266">The library <code>core-decorators</code> has <a href="https://github.com/jayphelps/core-decorators#decorate">a decorator</a> that lets us apply functions to methods. That enables us to use helper functions such as Lodash’s <code>memoize()</code>. The following code shows an implementation <code>@applyFunction</code> of such a decorator:</p>
      <pre><code class="language-js"><span class="hljs-keyword">import</span> { memoize } <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash-es'</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">applyFunction</span>(<span class="hljs-params">functionFactory</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">value, {kind}</span>) =&gt;</span> { <span class="hljs-comment">// decorator function</span>
    <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'method'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">functionFactory</span>(value);
    }
  };
}

<span class="hljs-keyword">let</span> invocationCount = <span class="hljs-number">0</span>;

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> {
  @<span class="hljs-title function_">applyFunction</span>(memoize)
  <span class="hljs-title function_">expensiveOperation</span>(<span class="hljs-params">str</span>) {
    invocationCount++;
    <span class="hljs-comment">// Expensive processing of `str` 😀</span>
    <span class="hljs-keyword">return</span> str + str;
  }
}

<span class="hljs-keyword">const</span> task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>();
assert.<span class="hljs-title function_">equal</span>(
  task.<span class="hljs-title function_">expensiveOperation</span>(<span class="hljs-string">'abc'</span>),
  <span class="hljs-string">'abcabc'</span>
);
assert.<span class="hljs-title function_">equal</span>(
  task.<span class="hljs-title function_">expensiveOperation</span>(<span class="hljs-string">'abc'</span>),
  <span class="hljs-string">'abcabc'</span>
);
assert.<span class="hljs-title function_">equal</span>(
  invocationCount, <span class="hljs-number">1</span>
);
</code></pre>
      <h2 id="class-getter-decorators%2C-class-setter-decorators" tabindex="-1" data-en="267">Class getter decorators, class setter decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-getter-decorators%2C-class-setter-decorators" aria-hidden="true">#</a></h2>
      <p data-en="268">These are the type signatures of getter decorators and setter decorators:</p>
      <pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ClassGetterDecorator</span> = <span class="hljs-function">(<span class="hljs-params">
  <span class="hljs-attr">value</span>: <span class="hljs-title class_">Function</span>,
  <span class="hljs-attr">context</span>: {
    kind: <span class="hljs-string">'getter'</span>;
    name: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>;
    <span class="hljs-keyword">static</span>: <span class="hljs-built_in">boolean</span>;
    <span class="hljs-keyword">private</span>: <span class="hljs-built_in">boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in">unknown</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_">Function</span> | <span class="hljs-built_in">void</span>;

<span class="hljs-keyword">type</span> <span class="hljs-title class_">ClassSetterDecorator</span> = <span class="hljs-function">(<span class="hljs-params">
  <span class="hljs-attr">value</span>: <span class="hljs-title class_">Function</span>,
  <span class="hljs-attr">context</span>: {
    kind: <span class="hljs-string">'setter'</span>;
    name: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>;
    <span class="hljs-keyword">static</span>: <span class="hljs-built_in">boolean</span>;
    <span class="hljs-keyword">private</span>: <span class="hljs-built_in">boolean</span>;
    access: { set: (value: <span class="hljs-built_in">unknown</span>) =&gt; <span class="hljs-built_in">void</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_">Function</span> | <span class="hljs-built_in">void</span>;
</code></pre>
      <p data-en="269">Getter decorators and setter decorators have similar abilities to method decorators.</p>
      <h3 id="example%3A-computing-values-lazily" tabindex="-1" data-en="270">Example: computing values lazily&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-computing-values-lazily" aria-hidden="true">#</a></h3>
      <p data-en="271">To implement a property whose value is computed <em>lazily</em> (on demand), we use two techniques:</p>
      <ul>
        <li>
          <kskb data-en="272" style="display: block;">

          </kskb>
          <p data-en="273">We implement the property via a getter. That way, the code that computes its value, is only executed if the property is read.</p>
        </li>
        <li>
          <kskb data-en="274" style="display: block;">

          </kskb>
          <p data-en="275">The decorator <code>@lazy</code> wraps the original getter: When the wrapper is invoked for the first time, it invokes the getter and creates an own data property whose value is the result. From now on, the own property overrides the inherited getter whenever someone reads the property.</p>
        </li>
      </ul>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  @lazy
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'COMPUTING'</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-string">'Result of computation'</span>;
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">lazy</span>(<span class="hljs-params">value, {kind, name, addInitializer}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'getter'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">const</span> result = value.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>( <span class="hljs-comment">// (A)</span>
        <span class="hljs-variable language_">this</span>, name,
        {
          <span class="hljs-attr">value</span>: result,
          <span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>,
        }
      );
      <span class="hljs-keyword">return</span> result;
    };
  }
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'1 new C()'</span>);
<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'2 inst.value'</span>);
assert.<span class="hljs-title function_">equal</span>(inst.<span class="hljs-property">value</span>, <span class="hljs-string">'Result of computation'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'3 inst.value'</span>);
assert.<span class="hljs-title function_">equal</span>(inst.<span class="hljs-property">value</span>, <span class="hljs-string">'Result of computation'</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'4 end'</span>);

<span class="hljs-comment">// Output:</span>
<span class="hljs-comment">// 1 new C()</span>
<span class="hljs-comment">// 2 inst.value</span>
<span class="hljs-comment">// COMPUTING</span>
<span class="hljs-comment">// 3 inst.value</span>
<span class="hljs-comment">// 4 end</span>
</code></pre>
      <p data-en="276">Note that property <code>.[name]</code> is immutable (because there is only a getter), which is why we have to define the property (line A) and can’t use assignment.</p>
      <h2 id="class-field-decorators" tabindex="-1" data-en="277">Class field decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-field-decorators" aria-hidden="true">#</a></h2>
      <p data-en="278">Class field decorators have the following type signature:</p>
      <pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ClassFieldDecorator</span> = <span class="hljs-function">(<span class="hljs-params">
  <span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>,
  <span class="hljs-attr">context</span>: {
    kind: <span class="hljs-string">'field'</span>;
    name: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>;
    <span class="hljs-keyword">static</span>: <span class="hljs-built_in">boolean</span>;
    <span class="hljs-keyword">private</span>: <span class="hljs-built_in">boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in">unknown</span>, set: (value: <span class="hljs-built_in">unknown</span>) =&gt; <span class="hljs-built_in">void</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">initialValue</span>: <span class="hljs-built_in">unknown</span></span>) =&gt;</span> <span class="hljs-built_in">unknown</span> | <span class="hljs-built_in">void</span>;
</code></pre>
      <p data-en="279">Abilities of a field decorator:</p>
      <ul>
        <li>
          <kskb data-en="280" style="display: block;">

          </kskb>
          <p data-en="281">It cannot change or replace its field. If we need that functionality, we have to use an <em>auto-accessor</em> (what that is, is described <a href="#auto-accessors">later</a>).</p>
        </li>
        <li>
          <kskb data-en="282" style="display: block;">
            <p data-en="283">It can change the value with which “its” field is initialized, by returning a function that receives the original initialization value and returns a new initialization value.</p>

          </kskb>
          <ul>
            <li data-en="284">Inside that function, <code>this</code> refers to the current instance.</li>
          </ul>
        </li>
        <li>
          <kskb data-en="285" style="display: block;">

          </kskb>
          <p data-en="286">It can register initializers. That is a recent change (post-2022-03) of the decorators API and wasn’t possible before.</p>
        </li>
      </ul>
      <ul>
        <li data-en="287">It can expose access to its field (even if it’s private) via <code>context.access</code>.</li>
      </ul>
      <h3 id="example%3A-changing-initialization-values-of-fields" tabindex="-1" data-en="288">Example: changing initialization values of fields&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-changing-initialization-values-of-fields" aria-hidden="true">#</a></h3>
      <p data-en="289">The decorator <code>@twice</code> doubles the original initialization value of a field by returning a function that performs this change:</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">twice</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">initialValue</span> =&gt;</span> initialValue * <span class="hljs-number">2</span>;
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  @twice
  field = <span class="hljs-number">3</span>;
}

<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();
assert.<span class="hljs-title function_">equal</span>(
  inst.<span class="hljs-property">field</span>, <span class="hljs-number">6</span>
);
</code></pre>
      <h3 id="read-only-fields" tabindex="-1" data-en="290">Example: read-only fields (instance public fields)&nbsp;&nbsp;<a class="heading-anchor" href="#read-only-fields" aria-hidden="true">#</a></h3>
      <p data-en="291">The decorator <code>@readOnly</code> makes a field immutable. It waits until the field was completely set up (either via an assignment or via the constructor) before it does so.</p>
      <pre><code class="language-js"><span class="hljs-keyword">const</span> readOnlyFieldKeys = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'readOnlyFieldKeys'</span>);

@readOnly
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {
  @readOnly
  name;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
}

<span class="hljs-keyword">const</span> blue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">'blue'</span>);
assert.<span class="hljs-title function_">equal</span>(blue.<span class="hljs-property">name</span>, <span class="hljs-string">'blue'</span>);
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> blue.<span class="hljs-property">name</span> = <span class="hljs-string">'brown'</span>,
  <span class="hljs-regexp">/^TypeError: Cannot assign to read only property 'name'/</span>
);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">readOnly</span>(<span class="hljs-params">value, {kind, name}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'field'</span>) { <span class="hljs-comment">// (A)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>[readOnlyFieldKeys]) {
        <span class="hljs-variable language_">this</span>[readOnlyFieldKeys] = [];
      }
      <span class="hljs-variable language_">this</span>[readOnlyFieldKeys].<span class="hljs-title function_">push</span>(name);
    };
  }
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'class'</span>) { <span class="hljs-comment">// (B)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
      <span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">value</span>(...args);
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">of</span> inst[readOnlyFieldKeys]) {
        <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(inst, key, {<span class="hljs-attr">writable</span>: <span class="hljs-literal">false</span>});
      }
      <span class="hljs-keyword">return</span> inst;
    }
  }
}
</code></pre>
      <p data-en="292">We need two steps to implement the functionality of <code>@readOnly</code> (which is why the class is also decorated):</p>
      <ul>
        <li data-en="293">We first collect all keys of read-only fields (line A).</li>
        <li data-en="294">Then we wait until the instance was completely set up and make the fields, whose keys we collected, non-writable (line B). We need to wrap the class because decorator initializers are executed too early.</li>
      </ul>
      <p data-en="295">Similarly to making instances immutable, this decorator breaks <code>instanceof</code>. The same workaround can be used here, too.</p>
      <p data-en="296">We’ll later see <a href="#read-only-auto-accessors">a version <code>@readOnly</code> that works with auto-accessors</a> instead of fields. That implementation does not require the class to be decorated.</p>
      <h3 id="example%3A-dependency-injection-(instance-public-fields)" tabindex="-1" data-en="297">Example: dependency injection (instance public fields)&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-dependency-injection-(instance-public-fields)" aria-hidden="true">#</a></h3>
      <p data-en="298"><em>Dependency injection</em> is motivated by the following observation: If we provide the constructor of a class with its dependencies (vs. the constructor setting them up itself), then it’s easier to adapt the dependencies to different environments, including testing.</p>
      <p data-en="299">This is an <em>inversion of control</em>: The constructor does not do its own setup, we do it for it. Approaches for doing dependency injection:</p>
      <ol>
        <li data-en="300">Manually, by creating dependencies and passing them to the constructor.</li>
        <li data-en="301">Via “contexts” in frontend frameworks such as React</li>
        <li data-en="302">Via decorators and a <em>dependency injection registry</em> (a minor variation of <em>dependency injection containers</em>)</li>
      </ol>
      <p data-en="303">The following code is a simple implementation of approach #3:</p>
      <pre><code class="language-js"><span class="hljs-keyword">const</span> {registry, inject} = <span class="hljs-title function_">createRegistry</span>();

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Logger</span> {
  <span class="hljs-title function_">log</span>(<span class="hljs-params">str</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(str);
  }
}
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> {
  @inject logger;
  <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">logger</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Hello!'</span>);
  }
}

registry.<span class="hljs-title function_">register</span>(<span class="hljs-string">'logger'</span>, <span class="hljs-title class_">Logger</span>);
<span class="hljs-keyword">new</span> <span class="hljs-title class_">Main</span>().<span class="hljs-title function_">run</span>();

<span class="hljs-comment">// Output:</span>
<span class="hljs-comment">// Hello!</span>
</code></pre>
      <p data-en="304">This is how <code>createRegistry()</code> is implemented:</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createRegistry</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> nameToClass = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  <span class="hljs-keyword">const</span> nameToInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
  <span class="hljs-keyword">const</span> registry = {
    <span class="hljs-title function_">register</span>(<span class="hljs-params">name, componentClass</span>) {
      nameToClass.<span class="hljs-title function_">set</span>(name, componentClass);
    },
    <span class="hljs-title function_">getInstance</span>(<span class="hljs-params">name</span>) {
      <span class="hljs-keyword">if</span> (nameToInstance.<span class="hljs-title function_">has</span>(name)) {
        <span class="hljs-keyword">return</span> nameToInstance.<span class="hljs-title function_">get</span>(name);
      }
      <span class="hljs-keyword">const</span> componentClass = nameToClass.<span class="hljs-title function_">get</span>(name);
      <span class="hljs-keyword">if</span> (componentClass === <span class="hljs-literal">undefined</span>) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Unknown component name: '</span> + name);
      }
      <span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">componentClass</span>();
      nameToInstance.<span class="hljs-title function_">set</span>(name, inst);
      <span class="hljs-keyword">return</span> inst;
    },
  }; 
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">inject</span> (<span class="hljs-params">_value, {kind, name}</span>) {
    <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'field'</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> registry.<span class="hljs-title function_">getInstance</span>(name);
    }
  }
  <span class="hljs-keyword">return</span> {registry, inject};
}
</code></pre>
      <h3 id="example-friend-visibility" tabindex="-1" data-en="305">Example: “friend”&nbsp;visibility (instance private fields)&nbsp;&nbsp;<a class="heading-anchor" href="#example-friend-visibility" aria-hidden="true">#</a></h3>
      <p data-en="306">We can change the visibility of some class members by making them private. That prevents them from being accessed publicly. There are more useful kinds of visibility, though. For example, <em>friend visibility</em> lets a group of <em>friends</em> (functions, other classes, etc.) access the member.</p>
      <p data-en="307">There are many ways in which friends can be specified. In the following example, everyone who has access to <code>friendName</code>, is a friend of <code>classWithSecret.#name</code>. The idea is that a module contains classes and functions that collaborate and that there is some instance data that only the collaborators should be able see.</p>
      <pre><code class="language-js"><span class="hljs-keyword">const</span> friendName = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Friend</span>();

<span class="hljs-keyword">class</span> <span class="hljs-title class_">ClassWithSecret</span> {
  @friendName.<span class="hljs-property">install</span> #name = <span class="hljs-string">'Rumpelstiltskin'</span>;
  <span class="hljs-title function_">getName</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#name;
  }
}

<span class="hljs-comment">// Everyone who has access to `secret`, can access inst.#name</span>
<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassWithSecret</span>();
assert.<span class="hljs-title function_">equal</span>(
  friendName.<span class="hljs-title function_">get</span>(inst), <span class="hljs-string">'Rumpelstiltskin'</span>
);
friendName.<span class="hljs-title function_">set</span>(inst, <span class="hljs-string">'Joe'</span>);
assert.<span class="hljs-title function_">equal</span>(
  inst.<span class="hljs-title function_">getName</span>(), <span class="hljs-string">'Joe'</span>
);
</code></pre>
      <p data-en="308">This is how class <code>Friend</code> is implemented:</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Friend</span> {
  #access = <span class="hljs-literal">undefined</span>;
  #<span class="hljs-title function_">getAccessOrThrow</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.#access === <span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'The friend decorator wasn’t used yet'</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#access;
  }
  <span class="hljs-comment">// An instance property whose value is a function whose `this`</span>
  <span class="hljs-comment">// is fixed (bound to the instance).</span>
  install = <span class="hljs-function">(<span class="hljs-params">_value, {kind, access}</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'field'</span>) {
      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.#access) {
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'This decorator can only be used once'</span>);
      }
      <span class="hljs-variable language_">this</span>.#access = access;
    }
  }
  <span class="hljs-title function_">get</span>(<span class="hljs-params">inst</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">getAccessOrThrow</span>().<span class="hljs-property">get</span>.<span class="hljs-title function_">call</span>(inst);
  }
  <span class="hljs-title function_">set</span>(<span class="hljs-params">inst, value</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#<span class="hljs-title function_">getAccessOrThrow</span>().<span class="hljs-property">set</span>.<span class="hljs-title function_">call</span>(inst, value);
  }
}
</code></pre>
      <h3 id="example%3A-enums-(static-public-fields)" tabindex="-1" data-en="309">Example: enums (static public fields)&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-enums-(static-public-fields)" aria-hidden="true">#</a></h3>
      <p data-en="310">There are many ways to implement enums. An OOP-style approach is to use a class and static properties (<a href="https://2ality.com/2016/01/enumify.html">more information on this approach</a>):</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {
  <span class="hljs-keyword">static</span> red = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">'red'</span>);
  <span class="hljs-keyword">static</span> green = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">'green'</span>);
  <span class="hljs-keyword">static</span> blue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">'blue'</span>);
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">enumKey</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">enumKey</span> = enumKey;
  }
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Color(<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.enumKey}</span>)`</span>;
  }
}
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Color</span>.<span class="hljs-property">green</span>.<span class="hljs-title function_">toString</span>(),
  <span class="hljs-string">'Color(green)'</span>
);
</code></pre>
      <p data-en="311">We can use a decorator to automatically:</p>
      <ul>
        <li data-en="312">Create a Map from “enum keys” (the names of their fields) to enum values.</li>
        <li data-en="313">Add enum keys to enum values – without having to pass them to the constructor.</li>
      </ul>
      <p data-en="314">That looks as follows:</p>
      <pre><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">enumEntry</span>(<span class="hljs-params">value, {kind, name}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'field'</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">initialValue</span>) {
      <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-string">'enumFields'</span>)) {
        <span class="hljs-variable language_">this</span>.<span class="hljs-property">enumFields</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>();
      }
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">enumFields</span>.<span class="hljs-title function_">set</span>(name, initialValue);
      initialValue.<span class="hljs-property">enumKey</span> = name;
      <span class="hljs-keyword">return</span> initialValue;
    };
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {
  @enumEntry <span class="hljs-keyword">static</span> red = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>();
  @enumEntry <span class="hljs-keyword">static</span> green = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>();
  @enumEntry <span class="hljs-keyword">static</span> blue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>();
  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`Color(<span class="hljs-subst">${<span class="hljs-variable language_">this</span>.enumKey}</span>)`</span>;
  }
}
assert.<span class="hljs-title function_">equal</span>(
  <span class="hljs-title class_">Color</span>.<span class="hljs-property">green</span>.<span class="hljs-title function_">toString</span>(),
  <span class="hljs-string">'Color(green)'</span>
);
assert.<span class="hljs-title function_">deepEqual</span>(
  <span class="hljs-title class_">Color</span>.<span class="hljs-property">enumFields</span>,
  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([
    [<span class="hljs-string">'red'</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">red</span>],
    [<span class="hljs-string">'green'</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">green</span>],
    [<span class="hljs-string">'blue'</span>, <span class="hljs-title class_">Color</span>.<span class="hljs-property">blue</span>],
  ])
);
</code></pre>
      <h2 id="auto-accessors" tabindex="-1" data-en="315">Auto-accessors: a new member of class definitions&nbsp;&nbsp;<a class="heading-anchor" href="#auto-accessors" aria-hidden="true">#</a></h2>
      <p data-en="316">The decorators proposal introduces a new language feature: <em>auto-accessors</em>. An auto-accessor is created by putting the keyword <code>accessor</code> before a class field. It is used like a field but implemented differently at runtime. That helps decorators as we’ll see soon. This is what auto-accessors look like:</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  <span class="hljs-keyword">static</span> accessor myField1;
  <span class="hljs-keyword">static</span> accessor #myField2;
  accessor myField3;
  accessor #myField4;
}
</code></pre>
      <p data-en="317">How do fields and auto-accessors differ?</p>
      <ul>
        <li>
          <kskb data-en="318" style="display: block;">A field creates either:

          </kskb>
          <ul>
            <li data-en="319">Properties (static or instance)</li>
            <li data-en="320">Private slots (static or instance)</li>
          </ul>
        </li>
        <li>
          <kskb data-en="321" style="display: block;">An auto-accessor creates a private slot (static or instance) for the data and:

          </kskb>
          <ul>
            <li data-en="322">A public getter-setter pair (static or prototype)</li>
            <li>
              <kskb data-en="323" style="display: block;">A private getter-setter pair (static or instance)

              </kskb>
              <ul>
                <li data-en="324">Private slots are not inherited and therefore never located in prototypes.</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <p data-en="325">Consider the following class:</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  accessor str = <span class="hljs-string">'abc'</span>;
}
<span class="hljs-keyword">const</span> inst = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();
assert.<span class="hljs-title function_">equal</span>(
  inst.<span class="hljs-property">str</span>, <span class="hljs-string">'abc'</span>
);
inst.<span class="hljs-property">str</span> = <span class="hljs-string">'def'</span>;
assert.<span class="hljs-title function_">equal</span>(
  inst.<span class="hljs-property">str</span>, <span class="hljs-string">'def'</span>
);
</code></pre>
      <p data-en="326">Internally, it looks like this:</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  #str = <span class="hljs-string">'abc'</span>;
  <span class="hljs-keyword">get</span> <span class="hljs-title function_">str</span>() {
    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.#str;
  }
  <span class="hljs-keyword">set</span> <span class="hljs-title function_">str</span>(<span class="hljs-params">value</span>) {
    <span class="hljs-variable language_">this</span>.#str = value;
  }
}
</code></pre>
      <p data-en="327">The following code shows where the getters and setters of auto-accessors are located:</p>
      <pre><code class="language-js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span> {
  <span class="hljs-keyword">static</span> accessor myField1;
  <span class="hljs-keyword">static</span> accessor #myField2;
  accessor myField3;
  accessor #myField4;

  <span class="hljs-keyword">static</span> {
    <span class="hljs-comment">// Static getter and setter</span>
    assert.<span class="hljs-title function_">ok</span>(
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(C, <span class="hljs-string">'myField1'</span>), <span class="hljs-string">'myField1'</span>
    );
    <span class="hljs-comment">// Static getter and setter</span>
    assert.<span class="hljs-title function_">ok</span>(
      #myField2 <span class="hljs-keyword">in</span> C, <span class="hljs-string">'#myField2'</span>
    );

    <span class="hljs-comment">// Prototype getter and setter</span>
    assert.<span class="hljs-title function_">ok</span>(
      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">hasOwn</span>(C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>, <span class="hljs-string">'myField3'</span>), <span class="hljs-string">'myField3'</span>
    );
    <span class="hljs-comment">// Private getter and setter</span>
    <span class="hljs-comment">// (stored in instances, but shared between instances)</span>
    assert.<span class="hljs-title function_">ok</span>(
      #myField4 <span class="hljs-keyword">in</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(), <span class="hljs-string">'#myField4'</span>
    );
  }
}
</code></pre>
      <p data-en="328">For more information on why the slots of private getters, private setters and private methods are stored in instances, see <a href="https://exploringjs.com/js/book/ch_classes.html#private-methods-accessors">section “Private methods and accessors”</a> in “Exploring JavaScript”.</p>
      <h3 id="why-are-auto-accessors-needed%3F" tabindex="-1" data-en="329">Why are auto-accessors needed?&nbsp;&nbsp;<a class="heading-anchor" href="#why-are-auto-accessors-needed%3F" aria-hidden="true">#</a></h3>
      <p data-en="330">Auto-accessors are needed by decorators:</p>
      <ul>
        <li data-en="331">They can only influence the values fields are initialized with.</li>
        <li data-en="332">But they can completely replace auto-accessors.</li>
      </ul>
      <p data-en="333">Therefore, we have to use auto-accessors instead of fields whenever a decorator needs more control than it has with fields.</p>
      <h2 id="class-auto-accessor-decorators" tabindex="-1" data-en="334">Class auto-accessor decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-auto-accessor-decorators" aria-hidden="true">#</a></h2>
      <p data-en="335">Class auto-accessor decorators have the following type signature:</p>
      <pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">ClassAutoAccessorDecorator</span> = <span class="hljs-function">(<span class="hljs-params">
  <span class="hljs-attr">value</span>: {
    get: () =&gt; <span class="hljs-built_in">unknown</span>;
    set: (value: <span class="hljs-built_in">unknown</span>) =&gt; <span class="hljs-built_in">void</span>;
  },
  <span class="hljs-attr">context</span>: {
    kind: <span class="hljs-string">'accessor'</span>;
    name: <span class="hljs-built_in">string</span> | <span class="hljs-built_in">symbol</span>;
    <span class="hljs-keyword">static</span>: <span class="hljs-built_in">boolean</span>;
    <span class="hljs-keyword">private</span>: <span class="hljs-built_in">boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in">unknown</span>, set: (value: <span class="hljs-built_in">unknown</span>) =&gt; <span class="hljs-built_in">void</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in">void</span>): <span class="hljs-built_in">void</span>;
  }
</span>) =&gt;</span> {
  <span class="hljs-attr">get</span>?: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">unknown</span>;
  <span class="hljs-attr">set</span>?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">value</span>: <span class="hljs-built_in">unknown</span></span>) =&gt;</span> <span class="hljs-built_in">void</span>;
  <span class="hljs-attr">init</span>?: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">initialValue</span>: <span class="hljs-built_in">unknown</span></span>) =&gt;</span> <span class="hljs-built_in">unknown</span>;
} | <span class="hljs-built_in">void</span>;
</code></pre>
      <p data-en="336">Abilities of an auto-accessor decorator:</p>
      <ul>
        <li>
          <kskb data-en="337" style="display: block;">It receives the getter and the setter of the auto-accessor via its parameter <code>value</code>.

          </kskb>
          <ul>
            <li data-en="338"><code>context.access</code> provides the same functionality.</li>
          </ul>
        </li>
        <li data-en="339">It can replace the decorated auto-accessor by returning an object with the methods <code>.get()</code> and/or <code>.set()</code>.</li>
        <li data-en="340">It can influence the initial value of the auto-accessor by returning an object with the method <code>.init()</code>.</li>
        <li data-en="341">It can register initializers.</li>
      </ul>
      <h3 id="read-only-auto-accessors" tabindex="-1" data-en="342">Example: read-only auto-accessors&nbsp;&nbsp;<a class="heading-anchor" href="#read-only-auto-accessors" aria-hidden="true">#</a></h3>
      <p data-en="343">We have already implemented <a href="#read-only-fields">a decorator <code>@readOnly</code> for fields</a>. Let’s do the same for auto-accessors:</p>
      <pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">UNINITIALIZED</span> = <span class="hljs-title class_">Symbol</span>(<span class="hljs-string">'UNINITIALIZED'</span>);
<span class="hljs-keyword">function</span> <span class="hljs-title function_">readOnly</span>(<span class="hljs-params">{get,set}, {name, kind}</span>) {
  <span class="hljs-keyword">if</span> (kind === <span class="hljs-string">'accessor'</span>) {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-title function_">init</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">UNINITIALIZED</span>;
      },
      <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">const</span> value = get.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);
        <span class="hljs-keyword">if</span> (value === <span class="hljs-variable constant_">UNINITIALIZED</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(
            <span class="hljs-string">`Accessor <span class="hljs-subst">${name}</span> hasn’t been initialized yet`</span>
          );
        }
        <span class="hljs-keyword">return</span> value;
      },
      <span class="hljs-title function_">set</span>(<span class="hljs-params">newValue</span>) {
        <span class="hljs-keyword">const</span> oldValue = get.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>);
        <span class="hljs-keyword">if</span> (oldValue !== <span class="hljs-variable constant_">UNINITIALIZED</span>) {
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(
            <span class="hljs-string">`Accessor <span class="hljs-subst">${name}</span> can only be set once`</span>
          );
        }
        set.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">this</span>, newValue);
      },
    };
  }
}

<span class="hljs-keyword">class</span> <span class="hljs-title class_">Color</span> {
  @readOnly
  accessor name;
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;
  }
}

<span class="hljs-keyword">const</span> blue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">'blue'</span>);
assert.<span class="hljs-title function_">equal</span>(blue.<span class="hljs-property">name</span>, <span class="hljs-string">'blue'</span>);
assert.<span class="hljs-title function_">throws</span>(
  <span class="hljs-function">() =&gt;</span> blue.<span class="hljs-property">name</span> = <span class="hljs-string">'yellow'</span>,
  <span class="hljs-regexp">/^TypeError: Accessor name can only be set once$/</span>
);

<span class="hljs-keyword">const</span> orange = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Color</span>(<span class="hljs-string">'orange'</span>);
assert.<span class="hljs-title function_">equal</span>(orange.<span class="hljs-property">name</span>, <span class="hljs-string">'orange'</span>);
</code></pre>
      <p data-en="344">Compared to the field version, this decorator has one considerable advantage: It does not need to wrap the class to ensure that the decorated constructs become read-only.</p>
      <h2 id="faq" tabindex="-1" data-en="345">Frequently asked questions&nbsp;&nbsp;<a class="heading-anchor" href="#faq" aria-hidden="true">#</a></h2>
      <h3 id="function-decorators" tabindex="-1" data-en="346">Why can’t functions be decorated?&nbsp;&nbsp;<a class="heading-anchor" href="#function-decorators" aria-hidden="true">#</a></h3>
      <p data-en="347">The current proposal focuses on classes as a starting point. <a href="#more-decorator-related-proposals">Decorators for function expressions were proposed.</a> However, there hasn’t been much progress since then and there is no proposal for function <em>declarations</em>.</p>
      <p data-en="348">On the other hand, functions are relatively easy to decorate “manually”:</p>
      <pre><code class="language-js"><span class="hljs-keyword">const</span> decoratedFunc = <span class="hljs-title function_">decorator</span>(<span class="hljs-function">(<span class="hljs-params">x, y</span>) =&gt;</span> {});
</code></pre>
      <p data-en="349">This looks even better with <a href="https://2ality.com/2022/01/pipe-operator.html">the proposed pipeline operator</a>:</p>
      <pre><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">decoratedFunc</span> = (<span class="hljs-params">x, y</span>) =&gt; {} |&gt; <span class="hljs-title function_">decorator</span>(%);
</code></pre>
      <h2 id="more-decorator-related-proposals" tabindex="-1" data-en="350">More decorator-related proposals&nbsp;&nbsp;<a class="heading-anchor" href="#more-decorator-related-proposals" aria-hidden="true">#</a></h2>
      <p data-en="351">The following ECMAScript proposals provide more decorator-related features:</p>
      <ul>
        <li>
          <kskb data-en="352" style="display: block;">Stage 2: <a href="https://github.com/tc39/proposal-decorator-metadata">“Decorator Metadata”</a> by Chris Garrett (last update: 2022-04-11)

          </kskb>
          <ul>
            <li data-en="353">Quote: “This proposal seeks to extend the Decorators proposal by adding the ability for decorators to associate metadata with the value being decorated.”</li>
          </ul>
        </li>
        <li data-en="354">Stage 0: <a href="https://docs.google.com/document/d/1ikxIP5-RVYq6d_f8lAvf3pKC00W78ueyp-xIZ6q67uU">“Function Expression Decorators”</a> by Igor Minar (last update: 2016-01-25)</li>
        <li data-en="355">Stage 0: <a href="https://docs.google.com/document/d/1Qpkqf_8NzAwfD8LdnqPjXAQ2wwh8BBUGynhn-ZlCWT0">“Method Parameter Decorators”</a> by Igor Minar (last update: 2016-01-25)</li>
      </ul>
      <h2 id="resources" tabindex="-1" data-en="356">Resources&nbsp;&nbsp;<a class="heading-anchor" href="#resources" aria-hidden="true">#</a></h2>
      <h3 id="decorator-implementations" tabindex="-1" data-en="357">Implementations&nbsp;&nbsp;<a class="heading-anchor" href="#decorator-implementations" aria-hidden="true">#</a></h3>
      <ul>
        <li>
          <kskb data-en="358" style="display: block;">Babel currently has the best support for stage 3 decorators, via <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators"><code>@babel/plugin-proposal-decorators</code></a>.

          </kskb>
          <ul>
            <li data-en="359">Be sure to pick <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators#version">the latest decorator version</a>.</li>
            <li data-en="360">All the code in this blog post was developed via Babel.</li>
          </ul>
        </li>
        <li>
          <kskb data-en="361" style="display: block;">TypeScript currently supports stage 1 decorators behind a flag.

          </kskb>
          <ul>
            <li data-en="362">There is <a href="https://github.com/microsoft/TypeScript/pull/50820">a pull request by Ron Buckton</a> that supports stage 3 decorators and will likely ship in the release after TypeScript 4.9.</li>
          </ul>
        </li>
      </ul>
      <h3 id="libraries-with-decorators" tabindex="-1" data-en="363">Libraries with decorators&nbsp;&nbsp;<a class="heading-anchor" href="#libraries-with-decorators" aria-hidden="true">#</a></h3>
      <p data-en="364">These are libraries with decorators. They currently only support stage 1 decorators but can serve as inspirations for what’s possible:</p>
      <ul>
        <li data-en="365"><a href="https://github.com/jayphelps/core-decorators.js">core-decorators.js</a> by Jay Phelps (targets Babel)</li>
        <li data-en="366"><a href="https://github.com/NetanelBasal/helpful-decorators">“Helpful Decorators For TypeScript Projects”</a> by Netanel Basal</li>
      </ul>
      <h2 id="acknowledgements" tabindex="-1" data-en="367">Acknowledgements&nbsp;&nbsp;<a class="heading-anchor" href="#acknowledgements" aria-hidden="true">#</a></h2>
      <ul>
        <li data-en="368">Thanks to Chris Garrett for answering my questions about decorators.</li>
      </ul>
      <h2 id="further-reading" tabindex="-1" data-en="369">Further reading&nbsp;&nbsp;<a class="heading-anchor" href="#further-reading" aria-hidden="true">#</a></h2>
      <ul>
        <li>
          <kskb data-en="370" style="display: block;">

          </kskb>
          <p data-en="371"><a href="https://exploringjs.com/js/book/ch_callables.html">Chapter “Callable values”</a> [ordinary functions, arrow functions, classes, methods] in “Exploring JavaScript”</p>
        </li>
        <li>
          <kskb data-en="372" style="display: block;">

          </kskb>
          <p data-en="373"><a href="https://exploringjs.com/js/book/ch_classes.html">Chapter “Classes”</a> in “Exploring JavaScript”</p>
        </li>
      </ul>
    </div>
  </div>
</body>
<script purpose="标记中文元素index">
  () => {
    const list = ['P', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'UL', 'LI', 'OL', 'A', 'TABLE'];
    const has = (el, tag) => el.tagName === tag && /[\u4e00-\u9fa5]/.test(el.textContent);

    const indexes = [];
    let index = 0;
    document.querySelectorAll('*').forEach((el) => {
      if (list.some((tag) => has(el, tag))) {
        el.setAttribute('zh', index);
        indexes.push(index);
      }
      index++;
    });
    console.log(indexes.join());
  }
</script>
<script purpose="把index标在英文上">
  {
    let index = 0;
    const list = '9,11,12,13,14,16,27,29,31,32,33,34,35,36,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,142,143,144,145,146,147,149,150,151,152,153,154,155,156,157,159,160,161,162,163,164,165,167,168,170,172,174,175,176,177,179,180,181,182,184,185,186,187,189,191,192,193,194,195,197,198,200,201,203,204,205,207,208,209,210,212,213,215,216,219,220,221,222,223,225,226,228,229,231,232,234,235,237,247,249,256,272,274,276,277,279,281,282,283,285,311,312,313,315,318,319,323,326,328,344,356,357,358,360,362,363,365,366,367,368,370,371,372,373,374,377,378,382,383,386,387,389,391,426,428,459,461,499,502,504,505,549,551,586,588,589,591,592,595,596,599,614,616,617,618,620,621,622,623,624,676,679,681,682,683,684,685,686,687,688,689,690,691,693,695,696,697,698,699,700,701,704,705,706,707,708,710,711,712,820,822,823,825,849,850,852,854,855,857,885,887,888,889,891,923,927,930,932,949,950,951,953,954,955,957,959,1002,1004,1005,1013,1014,1017,1020,1024,1074,1081,1084,1088,1142,1143,1145,1148,1191,1193,1226,1227,1228,1230,1231,1232,1234,1236,1237,1238,1240,1276,1278,1300,1301,1302,1304,1305,1306,1308,1309,1311,1365,1367,1394,1442,1445,1447,1489,1491,1533,1534,1536,1537,1538,1539,1540,1541,1600,1602,1604,1632,1633,1634,1635,1637,1638,1639,1640,1642,1643,1644,1645,1647,1649,1669,1671,1727,1728,1730,1732,1733,1735,1742,1749,1751,1752,1753,1757,1759,1761,1763,1765,1766,1769,1770,1771,1772,1773,1774,1775,1776,1777,1779,1785,1787,1788,1789,1791,1792,1793,1794,1795,1796,1797'.split(',').map(n => Number(n));
    document.querySelectorAll('*').forEach((el) => {
      if (list.includes(index)) {
        el.setAttribute('en', index);
      }
      index++;
    });

  }
</script>

</html>