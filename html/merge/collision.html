<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <div id="page-core-content" class="number-headings">
    <h1>使用 2022-03 装饰器 API 进行 JavaScript 元编程</h1>
    <div>
      <p>JavaScript 装饰器终于进入了 <a href="https://exploringjs.com/js/book/ch_history.html#tc39-process">第 3 阶段</a>！最新版本已经被 Babel 支持，<a href="#decorator-implementations">很快也会被 TypeScript 支持</a>。</p>
      <p>本文介绍了 ECMAScript 提案 <a href="https://github.com/tc39/proposal-decorators">“Decorators”</a>（2022-03 版本，第 3 阶段），作者为 Daniel Ehrenberg 和 Chris Garrett。</p>
      <p>装饰器是以 <code>@</code> 符号开头的关键字，可以用于类和类成员（如方法）前。例如，<code>@trace</code> 就是一个装饰器：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
  @trace
  <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-string" >'C'</span>;
  }
}
</code>
</pre>
      <p>装饰器会改变被装饰结构的行为。在这个例子中，每次调用 <code>.toString()</code> 都会被“追踪”（参数和结果会被输出到控制台）。<a href="#example-tracing-method-invocations">稍后我们会看到 <code>@trace</code> 的实现。</a></p>
      <!--more-->
      <p>装饰器主要是面向对象的特性，在 Ember、Angular、Vue、Web 组件框架和 MobX 等 OOP 框架和库中非常流行。</p>
      <p>关于装饰器，有两个相关角色：</p>
      <ul>
        <li>库作者需要了解装饰器 API，以便实现它们。</li>
        <li>库使用者只需知道如何应用装饰器。</li>
      </ul>
      <p>本文主要面向库作者：我们将学习装饰器的工作原理，并用这些知识实现几个装饰器。</p>
      <nav class="table-of-contents">
        <ul>
          <li>
            <a href="#history-of-decorators">装饰器的历史（可选章节）</a>
            <ul>
              <li>
                <a href="#the-history-of-decorators">装饰器的历史</a>
              </li>
              <li>
                <a href="#the-history-of-babel%E2%80%99s-decorator-implementation">Babel 装饰器实现的历史</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#what-are-decorators%3F">什么是装饰器？</a>
            <ul>
              <li>
                <a href="#the-shape-of-decorator-functions">装饰器函数的结构</a>
              </li>
              <li>
                <a href="#what-can-decorators-do%3F">装饰器能做什么？</a>
              </li>
              <li>
                <a href="#summary-tables">总结表格</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)">装饰器语法与语义的更多信息（可选章节）</a>
            <ul>
              <li>
                <a href="#the-syntax-of-decorator-expressions">装饰器表达式的语法</a>
              </li>
              <li>
                <a href="#how-are-decorators-executed%3F">装饰器如何执行？</a>
              </li>
              <li>
                <a href="#decorator-initializer-execution">装饰器初始化器何时运行？</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#techniques-for-exposing-data-from-decorators">装饰器暴露数据的技巧</a>
            <ul>
              <li>
                <a href="#storing-exposed-data-in-a-surrounding-scope">在外部作用域存储暴露的数据</a>
              </li>
              <li>
                <a href="#managing-exposed-data-via-a-factory-function">通过工厂函数管理暴露的数据</a>
              </li>
              <li>
                <a href="#managing-exposed-data-via-a-class">通过类管理暴露的数据</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#class-decorators">类装饰器</a>
            <ul>
              <li>
                <a href="#example%3A-collecting-instances">示例：收集实例</a>
              </li>
              <li>
                <a href="#making-sure-that-instanceof-works">确保 <code>instanceof</code> 正常工作</a>
              </li>
              <li>
                <a href="#example-freezing-instances">示例：冻结实例</a>
              </li>
              <li>
                <a href="#example%3A-making-classes-function-callable">示例：让类可函数调用</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#class-method-decorators">类方法装饰器</a>
            <ul>
              <li>
                <a href="#example-tracing-method-invocations">示例：追踪方法调用</a>
              </li>
              <li>
                <a href="#example%3A-binding-methods-to-instances">示例：将方法绑定到实例</a>
              </li>
              <li>
                <a href="#example%3A-applying-functions-to-methods">示例：对方法应用函数</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#class-getter-decorators%2C-class-setter-decorators">类 getter 装饰器、setter 装饰器</a>
            <ul>
              <li>
                <a href="#example%3A-computing-values-lazily">示例：惰性计算值</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#class-field-decorators">类字段装饰器</a>
            <ul>
              <li>
                <a href="#example%3A-changing-initialization-values-of-fields">示例：改变字段初始化值</a>
              </li>
              <li>
                <a href="#read-only-fields">示例：只读字段（实例公有字段）</a>
              </li>
              <li>
                <a href="#example%3A-dependency-injection-(instance-public-fields)">示例：依赖注入（实例公有字段）</a>
              </li>
              <li>
                <a href="#example-friend-visibility">示例：“友元”可见性（实例私有字段）</a>
              </li>
              <li>
                <a href="#example%3A-enums-(static-public-fields)">示例：枚举（静态公有字段）</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#auto-accessors">自动访问器：类定义的新成员</a>
            <ul>
              <li>
                <a href="#why-are-auto-accessors-needed%3F">为什么需要自动访问器？</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#class-auto-accessor-decorators">类自动访问器装饰器</a>
            <ul>
              <li>
                <a href="#read-only-auto-accessors">示例：只读自动访问器</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#faq">常见问题</a>
            <ul>
              <li>
                <a href="#function-decorators">为什么函数不能被装饰？</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#more-decorator-related-proposals">更多与装饰器相关的提案</a>
          </li>
          <li>
            <a href="#resources">资源</a>
            <ul>
              <li>
                <a href="#decorator-implementations">实现</a>
              </li>
              <li>
                <a href="#libraries-with-decorators">带装饰器的库</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#acknowledgements">致谢</a>
          </li>
          <li>
            <a href="#further-reading">延伸阅读</a>
          </li>
        </ul>
      </nav>
      <h2 id="history-of-decorators" tabindex="-1">装饰器的历史（可选章节）&nbsp;&nbsp;<a class="heading-anchor" href="#history-of-decorators" aria-hidden="true">#</a></h2>
      <p>(本章节为可选内容。如果您跳过此章节，仍然可以理解后续内容。)</p>
      <p>让我们从装饰器的历史开始。主要回答以下两个问题：</p>
      <ul>
        <li>为什么这个提案花了这么长时间？</li>
        <li>为什么感觉 JavaScript 似乎已经有装饰器很多年了？</li>
      </ul>
      <h3 id="the-history-of-decorators" tabindex="-1">装饰器的历史&nbsp;&nbsp;<a class="heading-anchor" href="#the-history-of-decorators" aria-hidden="true">#</a></h3>
      <p>以下历史描述了：</p>
      <ul>
        <li>各个团体如何在各自的项目中工作，并在 TC39 提案上进行协作。</li>
        <li>TC39 提案如何通过 <a href="https://exploringjs.com/js/book/ch_history.html#tc39-process">TC39 过程</a> 的各个阶段（从 0 开始，到 4 结束，提案准备添加到 ECMAScript 中）。在此过程中，提案经历了多次变更。</li>
      </ul>
      <p>以下是相关事件的时间顺序：</p>
      <ul>
        <li>
          <p><a href="https://github.com/tc39/notes/blob/main/meetings/2014-04/apr-10.md">2014-04-10</a>：Yehuda Katz 向 TC39 提出了装饰器提案。该提案晋升为第 0 阶段。</p>
          <ul>
            <li>Katz 的提案是与 Ron Buckton 合作创建的。关于该提案的讨论可以追溯到 <a href="https://twitter.com/rbuckton/status/1581292852532813825">2013 年 7 月</a>。</li>
          </ul>
        </li>
        <li>
          <p>2014-10-22（ngEurope 大会，巴黎）：Angular 团队宣布 Angular 2.0 正在使用 AtScript 编写，并编译为 JavaScript（通过 Traceur）和 Dart。计划包括基于 TypeScript 的 AtScript，同时添加：</p>
          <ul>
            <li>三种类型的 <em>注解</em>：
              <ul>
                <li><em>类型注解</em></li>
                <li><em>字段注解</em> 显式声明字段。</li>
                <li><em>元数据注解</em> 语法与装饰器相同，但仅添加元数据，不改变被注解结构的工作方式。</li>
              </ul>
            </li>
            <li>运行时类型检查</li>
            <li>类型反射</li>
          </ul>
        </li>
        <li>
          <p><a href="https://github.com/tc39/notes/blob/main/meetings/2015-01/jan-28.md">2015-01-28</a>：Yehuda Katz 和 Jonathan Turner 报告说 Katz 和 TypeScript 团队正在交流想法。</p>
        </li>
        <li>
          <p>2015-03-05（ng-conf，盐湖城）：Angular 团队和 TypeScript 团队宣布 Angular 将从 AtScript 切换到 TypeScript，并且 TypeScript 将采用 AtScript 的一些特性（特别是装饰器）。</p>
        </li>
        <li>
          <p><a href="https://github.com/tc39/notes/blob/main/meetings/2015-03/mar-24.md">2015-03-24</a>：装饰器提案进入第 1 阶段。彼时，他们在 GitHub 上有 <a href="https://github.com/wycats/javascript-decorators">一个仓库</a>（由 Yehuda Katz 创建），后来迁移到 <a href="https://github.com/tc39/proposal-decorators">当前所在位置</a>。</p>
        </li>
        <li>
          <p>2015-07-20：<a href="https://devblogs.microsoft.com/typescript/announcing-typescript-1-5/">TypeScript 1.5</a> 发布，支持通过 <a href="https://www.typescriptlang.org/docs/handbook/decorators.html">第 1 阶段装饰器</a>，需开启标志 <code>--experimentalDecorators</code>。</p>
          <p>多个 JavaScript 项目（如 Angular 和 MobX）使用了这个 TypeScript 特性，这使得 JavaScript 看起来已经有装饰器。</p>
          <p>到目前为止，TypeScript 尚未支持更新版本的装饰器 API。<a href="https://github.com/microsoft/TypeScript/pull/50820">Ron Buckton 的一个拉取请求提供了对第 3 阶段装饰器的支持</a>，可能会在 v4.9 之后的版本中发布。</p>
        </li>
        <li>
          <p><a href="https://github.com/tc39/notes/blob/main/meetings/2016-07/jul-28.md">2016-07-28</a>：在 Yehuda Katz 和 Brian Terlson 的介绍后，提案进入第 2 阶段。</p>
        </li>
        <li>
          <p><a href="https://github.com/tc39/notes/blob/main/meetings/2017-07/jul-27.md">2017-07-27</a>：Daniel Ehrenberg 在几个月前加入提案后首次进行了装饰器的介绍。他推动了提案的演变，持续了好几年。</p>
        </li>
        <li>
          <p>随后，Chris Garrett 加入了提案，并帮助其进入第 3 阶段，该阶段发生在 <a href="https://github.com/tc39/notes/blob/main/meetings/2022-03/mar-28.md">2022-03-28</a>。装饰器元数据被移至 <a href="https://github.com/tc39/proposal-decorator-metadata">一个单独的提案</a>，该提案从第 2 阶段开始。</p>
        </li>
      </ul>
      <p>之所以花了很长时间才进入第 3 阶段，是因为很难让所有利益相关者就 API 达成一致。人们关心的包括与其他特性（如类成员和私有状态）的相互作用以及性能等问题。</p>
      <h3 id="the-history-of-babel%E2%80%99s-decorator-implementation" tabindex="-1">Babel 装饰器实现的历史&nbsp;&nbsp;<a class="heading-anchor" href="#the-history-of-babel%E2%80%99s-decorator-implementation" aria-hidden="true">#</a></h3>
      <p>Babel 紧密跟踪了装饰器提案的演变，这要感谢 Logan Smyth、Nicolò Ribaudo 和其他人的努力：</p>
      <ul>
        <li>
          <p><a href="https://babeljs.io/blog/2015/03/31/5.0.0">2015-03-31</a>：Babel 5.0.0 支持第 1 阶段装饰器。</p>
        </li>
        <li>
          <p><a href="https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy">2015-11-29</a> Logan Smyth 的一个外部插件将第 1 阶段装饰器带到了 Babel 6。</p>
        </li>
        <li>
          <p><a href="https://babeljs.io/blog/2018/08/27/7.0.0">2018-08-27</a> Babel 7.0.0 通过官方的 <code>@babel/plugin-proposal-decorators</code> 支持第 2 阶段装饰器。</p>
        </li>
        <li>
          <p>官方插件目前支持 <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators#version">以下版本</a>：</p>
          <ul>
            <li><code>"legacy"</code>: <a href="https://github.com/wycats/javascript-decorators/blob/e1bf8d41bfa2591d949dd3bbf013514c8904b913/README.md">第 1 阶段装饰器</a></li>
            <li><code>"2018-09"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/7fa580b40f2c19c561511ea2c978e307ae689a1b">第 2 阶段装饰器</a></li>
            <li><code>"2021-12"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/d6c056fa061646178c34f361bad33d583316dc85">第 2 阶段装饰器的更新版本</a></li>
            <li><code>"2022-03"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/8ca65c046dd5e9aa3846a1fe5df343a6f7efd9f8">第 3 阶段装饰器</a></li>
          </ul>
        </li>
      </ul>
      <h2 id="what-are-decorators%3F" tabindex="-1">什么是装饰器？&nbsp;&nbsp;<a class="heading-anchor" href="#what-are-decorators%3F" aria-hidden="true">#</a></h2>
      <p>装饰器让我们可以改变 JavaScript 结构（如类和方法）的工作方式。让我们回顾一下使用装饰器 <code>@trace</code>:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
  @trace
  <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-string" >'C'</span>;
  }
}
</code></pre>
      <p>要实现 <code>@trace</code>，我们只需编写一个函数 (<a href="#example-tracing-method-invocations">确切的实现稍后会展示</a>):</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >trace</span>(<span class="hljs-params" >decoratedMethod</span>) {
  <span class="hljs-comment" >// // 返回一个替换 `decoratedMethod` 的函数。</span>
}
</code></pre>
      <p>带有装饰器方法的类大致等同于以下代码：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
  <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-string" >'C'</span>;
  }
}
C.<span class="hljs-property" ><span class="hljs-keyword" >prototype</span></span>.<span class="hljs-property" >toString</span> = <span class="hljs-title function_" >trace</span>(C.<span class="hljs-property" ><span class="hljs-keyword" >prototype</span></span>.<span class="hljs-property" >toString</span>);
</code></pre>
      <p>换句话说：装饰器是一个可以应用于语言结构的函数。我们通过在它们前面加上 <code>@</code> 和它的名字来实现这一点。</p>
      <p>编写和使用装饰器是<em>元编程</em>：</p>
      <ul>
        <li>我们不是编写处理用户数据的代码（<em>编程</em>）。</li>
        <li>我们编写处理处理用户数据的代码（<em>元编程</em>）。</li>
      </ul>
      <p>有关元编程的更多信息，请参见“深度 JavaScript”中的<a href="https://exploringjs.com/deep-js/ch_proxies.html#programming-vs-metaprogramming">“编程与元编程”部分</a>。</p>
      <h3 id="the-shape-of-decorator-functions" tabindex="-1">装饰器函数的结构&nbsp;&nbsp;<a class="heading-anchor" href="#the-shape-of-decorator-functions" aria-hidden="true">#</a></h3>
      <p>在我们探索装饰器函数的示例之前，我想先看看它们的 TypeScript 类型签名：</p>
      <pre><code class="language-ts" ><span class="hljs-keyword" >type</span> <span class="hljs-title class_" >Decorator</span> = <span class="hljs-function" >(<span class="hljs-params" >
  <span class="hljs-attr" >value</span>: <span class="hljs-title class_" >DecoratedValue</span>, <span class="hljs-comment" >// 字段不同</span>
  <span class="hljs-attr" >context</span>: {
    kind: <span class="hljs-built_in" >string</span>;
    name: <span class="hljs-built_in" >string</span> | <span class="hljs-built_in" >symbol</span>;
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" >void</span>): <span class="hljs-built_in" >void</span>;

    // Don’t always exist:
    <span class="hljs-keyword" >static</span>: <span class="hljs-built_in" >boolean</span>;
    <span class="hljs-keyword" >private</span>: <span class="hljs-built_in" >boolean</span>;
    access: {get: () =&gt; <span class="hljs-built_in" >unknown</span>, set: (value: <span class="hljs-built_in" >unknown</span>) =&gt; <span class="hljs-built_in" >void</span>};
  }
</span>) =&gt;</span> <span class="hljs-built_in" >void</span> | <span class="hljs-title class_" >ReplacementValue</span>; <span class="hljs-comment" >// 仅字段不同</span>
</code></pre>
      <p>也就是说，装饰器就是一个函数。它的参数是：</p>
      <ul>
        <li>装饰器应用于的 <code>value</code>。</li>
        <li>包含 <code>value</code> 附加信息的对象 <code>context</code>，具有：
          <ul>
            <li>关于 <code>value</code> 的附加信息（<code>.static</code>、<code>.private</code>）</li>
            <li>一个小型 API（<code>.access</code>、<code>.addInitializer</code>），具有元编程功能</li>
          </ul>
        </li>
      </ul>
      <p>属性 <code>.kind</code> 告诉装饰器它被应用于哪种类型的 JavaScript 结构。我们可以对多种结构使用相同的函数。</p>
      <p>目前，装饰器可以应用于类、方法、getter、setter、字段和 <em>自动访问器</em>（稍后将解释的一种新类成员）。<code>.kind</code> 的值反映了这一点：</p>
      <ul>
        <li><code>'class'</code></li>
        <li><code>'method'</code></li>
        <li><code>'getter'</code></li>
        <li><code>'setter'</code></li>
        <li><code>'accessor'</code></li>
        <li><code>'field'</code></li>
      </ul>
      <p>以下是 <code>Decorator</code> 的确切类型：</p>
      <pre><code class="language-ts" ><span class="hljs-keyword" >type</span> <span class="hljs-title class_" >Decorator</span> =
  | <span class="hljs-title class_" >ClassDecorator</span>
  | <span class="hljs-title class_" >ClassMethodDecorator</span>
  | <span class="hljs-title class_" >ClassGetterDecorator</span>
  | <span class="hljs-title class_" >ClassSetterDecorator</span>
  | <span class="hljs-title class_" >ClassAutoAccessorDecorator</span>
  | <span class="hljs-title class_" >ClassFieldDecorator</span>
;
</code></pre>
      <p>我们很快会遇到这些装饰器及其类型签名 – 只有这些部分会有所不同：</p>
      <ul>
        <li><code>value</code> 的类型</li>
        <li><code>context</code> 的某些属性</li>
        <li>返回类型</li>
      </ul>
      <h3 id="what-can-decorators-do%3F" tabindex="-1">装饰器能做什么？&nbsp;&nbsp;<a class="heading-anchor" href="#what-can-decorators-do%3F" aria-hidden="true">#</a></h3>
      <p>每个装饰器最多有四种能力：</p>
      <ul>
        <li>
          <p>通过改变参数 <code>value</code> 来改变被装饰的实体。</p>
        </li>
        <li>
          <p>通过返回兼容的值来替换被装饰的实体：
          <ul>
            <li>“兼容”&nbsp;意味着返回的值必须与被装饰值具有相同的类型 – 例如，类装饰器必须返回可调用的值。</li>
            <li>如果装饰器不想替换被装饰的值，它可以返回 <code>undefined</code> – 可以是显式返回，也可以是通过不返回任何内容隐式返回。</li>
          </ul>
          </p>
        </li>
        <li>
          <p>向其他人暴露对被装饰实体的访问。<code>context.access</code> 使其能够通过其方法 <code>.get()</code> 和 <code>.set()</code> 来实现。</p>
        </li>
        <li>
          <p>在被装饰实体及其容器（如果有的话）存在后处理它们：该功能由 <code>context.addInitializer</code> 提供。它允许装饰器注册一个 <em>初始化器</em> – 在一切准备就绪时调用的回调（更多细节在<a href="#decorator-initializer-execution">稍后解释</a>）。</p>
        </li>
      </ul>
      <p>接下来的小节将演示这些能力。起初我们不会使用 <code>context.kind</code> 来检查装饰器应用于哪种类型的构造。稍后我们会这样做。</p>
      <h4 id="ability%3A-replacing-the-decorated-entity" tabindex="-1">能力：替换被装饰实体&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-replacing-the-decorated-entity" aria-hidden="true">#</a></h4>
      <p>在下面的示例中，装饰器 <code>@replaceMethod</code> 用它返回的函数替换了方法 <code>.hello()</code>（B 行）。</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >replaceMethod</span>(<span class="hljs-params" ></span>) {
  <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" ></span>) { <span class="hljs-comment" >// (A)</span>
    <span class="hljs-keyword" >return</span> <span class="hljs-string" >`How are you, <span class="hljs-subst" >${<span class="hljs-variable language_" >this</span>.name}</span>?`</span>;
  }
}

<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Person</span> {
  <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >name</span>) {
    <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >name</span> = name;
  }
  @replaceMethod
  <span class="hljs-title function_" >hello</span>(<span class="hljs-params" ></span>) { <span class="hljs-comment" >// (B)</span>
    <span class="hljs-keyword" >return</span> <span class="hljs-string" >`Hi <span class="hljs-subst" >${<span class="hljs-variable language_" >this</span>.name}</span>!`</span>;
  }
}

<span class="hljs-keyword" >const</span> robin = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Person</span>(<span class="hljs-string" >'Robin'</span>);
assert.<span class="hljs-title function_" >equal</span>(
  robin.<span class="hljs-title function_" >hello</span>(), <span class="hljs-string" >'How are you, Robin?'</span>
);
</code></pre>
      <h4 id="ability%3A-exposing-access-to-the-decorated-entity-to-others" tabindex="-1">能力：向其他人暴露对被装饰实体的访问&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-exposing-access-to-the-decorated-entity-to-others" aria-hidden="true">#</a></h4>
      <p>在下一个示例中，装饰器 <code>@exposeAccess</code> 将一个对象存储在变量 <code>acc</code> 中，使我们能够访问 <code>Color</code> 实例的 <code>.green</code> 属性。</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >let</span> acc;
<span class="hljs-keyword" >function</span> <span class="hljs-title function_" >exposeAccess</span>(<span class="hljs-params" >_value, {access}</span>) {
  acc = access;
}

<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Color</span> {
  @exposeAccess
  name = <span class="hljs-string" >'green'</span>
}

<span class="hljs-keyword" >const</span> green = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>();
assert.<span class="hljs-title function_" >equal</span>(
  green.<span class="hljs-property" >name</span>, <span class="hljs-string" >'green'</span>
);
<span class="hljs-comment" >// 使用 `acc` 获取和设置 `green.name`</span>
assert.<span class="hljs-title function_" >equal</span>(
  acc.<span class="hljs-property" >get</span>.<span class="hljs-title function_" >call</span>(green), <span class="hljs-string" >'green'</span>
);
acc.<span class="hljs-property" >set</span>.<span class="hljs-title function_" >call</span>(green, <span class="hljs-string" >'red'</span>);
assert.<span class="hljs-title function_" >equal</span>(
  green.<span class="hljs-property" >name</span>, <span class="hljs-string" >'red'</span>
);
</code></pre>
      <h4 id="ability%3A-processing-the-decorated-entity-and-its-container" tabindex="-1">能力：处理被装饰实体及其容器&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-processing-the-decorated-entity-and-its-container" aria-hidden="true">#</a></h4>
      <p>在以下代码中，我们使用装饰器 <code>@collect</code> 将被装饰方法的键存储在实例属性 <code>.collectedMethodKeys</code> 中：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >collect</span>(<span class="hljs-params" >_value, {name, addInitializer}</span>) {
  <span class="hljs-title function_" >addInitializer</span>(<span class="hljs-keyword" >function</span> (<span class="hljs-params" ></span>) { <span class="hljs-comment" >// (A)</span>
    <span class="hljs-keyword" >if</span> (!<span class="hljs-variable language_" >this</span>.<span class="hljs-property" >collectedMethodKeys</span>) {
      <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >collectedMethodKeys</span> = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>();
    }
    <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >collectedMethodKeys</span>.<span class="hljs-title function_" >add</span>(name);
  });
}

<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
  @collect
  <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {}
  @collect
  [<span class="hljs-title class_" >Symbol</span>.<span class="hljs-property" >iterator</span>]() {}
}
<span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >C</span>();
assert.<span class="hljs-title function_" >deepEqual</span>(
  inst.<span class="hljs-property" >collectedMethodKeys</span>,
  <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>([<span class="hljs-string" >'toString'</span>, <span class="hljs-title class_" >Symbol</span>.<span class="hljs-property" >iterator</span>])
);
</code></pre>
      <p>在 A 行添加的初始化函数必须是普通函数，因为需要访问隐式参数 <code>this</code>。箭头函数无法提供此访问权限 – 它们的 <code>this</code> 是静态作用域的（像任何普通变量一样）。</p>
      <h3 id="summary-tables" tabindex="-1">总结表格&nbsp;&nbsp;<a class="heading-anchor" href="#summary-tables" aria-hidden="true">#</a></h3>
      <p>类型签名：</p>
      <table class="framed">
        <thead>
          <tr>
            <th>装饰器种类</th>
            <th><code>(input) =&gt; output</code></th>
            <th><code>.access</code></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Class</td>
            <td><code>(func) =&gt; func2</code></td>
            <td>–</td>
          </tr>
          <tr>
            <td>Method</td>
            <td><code>(func) =&gt; func2</code></td>
            <td><code>{get}</code></td>
          </tr>
          <tr>
            <td>Getter</td>
            <td><code>(func) =&gt; func2</code></td>
            <td><code>{get}</code></td>
          </tr>
          <tr>
            <td>Setter</td>
            <td><code>(func) =&gt; func2</code></td>
            <td><code>{set}</code></td>
          </tr>
          <tr>
            <td>Auto-accessor</td>
            <td><code>({get,set}) =&gt; {get,set,init}</code></td>
            <td><code>{get,set}</code></td>
          </tr>
          <tr>
            <td>Field</td>
            <td><code>() =&gt; (initValue)=&gt;initValue2</code></td>
            <td><code>{get,set}</code></td>
          </tr>
        </tbody>
      </table>
      <p>函数中 <code>this</code> 的值：</p>
      <table class="framed">
        <thead>
          <tr>
            <th><code>this</code> 是 →</th>
            <th><code>undefined</code></th>
            <th>Class</th>
            <th>Instance</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Decorator function</td>
            <td>✔</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>Static initializer</td>
            <td></td>
            <td>✔</td>
            <td></td>
          </tr>
          <tr>
            <td>Non-static initializer</td>
            <td></td>
            <td></td>
            <td>✔</td>
          </tr>
          <tr>
            <td>Static field decorator result</td>
            <td></td>
            <td>✔</td>
            <td></td>
          </tr>
          <tr>
            <td>Non-static field decorator result</td>
            <td></td>
            <td></td>
            <td>✔</td>
          </tr>
        </tbody>
      </table>
      <h2 id="more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)" tabindex="-1">装饰器语法与语义的更多信息（可选章节）&nbsp;&nbsp;<a class="heading-anchor" href="#more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)" aria-hidden="true">#</a></h2>
      <p>(本章节为可选内容。如果您跳过此章节，仍然可以理解后续内容。)</p>
      <h3 id="the-syntax-of-decorator-expressions" tabindex="-1">装饰器表达式的语法&nbsp;&nbsp;<a class="heading-anchor" href="#the-syntax-of-decorator-expressions" aria-hidden="true">#</a></h3>
      <ul>
        <li>装饰器表达式以一个或多个标识符的链开始，标识符之间用点分隔。除第一个标识符外，每个标识符都可以是私有的（前缀为 <code>#</code>）。不允许使用方括号 <code>[]</code>。</li>
        <li>可选：末尾可以加上括号中的函数调用参数。下一小节将解释这意味着什么。</li>
        <li>如果我们把它放在括号中，我们可以使用任何表达式：
          <pre><code class="language-js">@(«expr»)
      </code></pre>
        </li>
      </ul>
      <p>无论装饰器允许在哪里，我们都可以使用多个装饰器。以下代码演示了装饰器语法:</p>
      <pre><code class="language-js" ><span class="hljs-comment" >// 五个 MyClass 的装饰器</span>

@myFunc
@<span class="hljs-title function_" >myFuncFactory</span>(<span class="hljs-string" >'arg1'</span>, <span class="hljs-string" >'arg2'</span>)

@libraryModule.<span class="hljs-property" >prop</span>
@someObj.<span class="hljs-title function_" >method</span>(<span class="hljs-number" >123</span>)

@(<span class="hljs-title function_" >wrap</span>(dict[<span class="hljs-string" >'prop'</span>])) <span class="hljs-comment" >// 任意表达式</span>

<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >MyClass</span> {}
</code></pre>
      <h3 id="how-are-decorators-executed%3F" tabindex="-1">装饰器如何执行？&nbsp;&nbsp;<a class="heading-anchor" href="#how-are-decorators-executed%3F" aria-hidden="true">#</a></h3>
      <ul>
        <li>
          <p>评估：<code>@</code> 符号后面的表达式在类定义的执行过程中被评估，与计算属性键和静态字段一起（见代码）。结果必须是函数。它们被存储在临时位置（可以认为是局部变量），以便稍后调用。</p>
        </li>
        <li>
          <p>调用：装饰器函数在类定义的执行过程中稍后被调用，在方法被评估后，但在构造函数和原型被组装之前。结果再次存储在临时位置。</p>
        </li>
        <li>
          <p>应用：在所有装饰器函数被调用后，使用它们的结果，这可能会影响构造函数和原型。类装饰器在所有方法和字段装饰器之后应用。</p>
        </li>
      </ul>
      <p>以下代码说明了装饰器表达式、计算属性键和字段初始化器的评估顺序：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >decorate</span>(<span class="hljs-params" >str</span>) {
  <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >`EVALUATE @decorate(): <span class="hljs-subst" >${str}</span>`</span>);
  <span class="hljs-keyword" >return</span> <span class="hljs-function" >() =&gt;</span> <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >`APPLY @decorate(): <span class="hljs-subst" >${str}</span>`</span>); <span class="hljs-comment" >// (A)</span>
}
<span class="hljs-keyword" >function</span> <span class="hljs-title function_" >log</span>(<span class="hljs-params" >str</span>) {
  <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(str);
  <span class="hljs-keyword" >return</span> str;
}

@<span class="hljs-title function_" >decorate</span>(<span class="hljs-string" >'class'</span>)
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >TheClass</span> {

  @<span class="hljs-title function_" >decorate</span>(<span class="hljs-string" >'static field'</span>)
  <span class="hljs-keyword" >static</span> staticField = <span class="hljs-title function_" >log</span>(<span class="hljs-string" >'static field value'</span>);

  @<span class="hljs-title function_" >decorate</span>(<span class="hljs-string" >'prototype method'</span>)
  [<span class="hljs-title function_" >log</span>(<span class="hljs-string" >'computed key'</span>)]() {}

  @<span class="hljs-title function_" >decorate</span>(<span class="hljs-string" >'instance field'</span>)
  instanceField = <span class="hljs-title function_" >log</span>(<span class="hljs-string" >'instance field value'</span>);
    <span class="hljs-comment" >// 仅在我们实例化类时，此初始化器才会运行</span>
}

<span class="hljs-comment" >// Output:</span>
<span class="hljs-comment" >// EVALUATE @decorate(): class</span>
<span class="hljs-comment" >// EVALUATE @decorate(): static field</span>
<span class="hljs-comment" >// EVALUATE @decorate(): prototype method</span>
<span class="hljs-comment" >// computed key</span>
<span class="hljs-comment" >// EVALUATE @decorate(): instance field</span>
<span class="hljs-comment" >// APPLY @decorate(): prototype method</span>
<span class="hljs-comment" >// APPLY @decorate(): static field</span>
<span class="hljs-comment" >// APPLY @decorate(): instance field</span>
<span class="hljs-comment" >// APPLY @decorate(): class</span>
<span class="hljs-comment" >// static field value</span>
</code></pre>
      <p>函数 <code>decorate</code> 在每次评估 <code>decorate()</code> 表达式时被调用。在 A行，它返回实际的装饰器函数，该函数稍后会被应用。</p>
      <h3 id="decorator-initializer-execution" tabindex="-1">装饰器初始化器何时运行？&nbsp;&nbsp;<a class="heading-anchor" href="#decorator-initializer-execution" aria-hidden="true">#</a></h3>
      <p>装饰器初始化器的运行时间取决于装饰器的种类：</p>
      <ul>
        <li>
          <p>类装饰器初始化器在类完全定义并且所有静态字段初始化后运行。</p>
        </li>
        <li>
          <p>非静态类元素装饰器的初始化器在实例化期间运行，在实例字段初始化之前。</p>
        </li>
        <li>
          <p>静态类元素装饰器的初始化器在类定义期间运行，在静态字段定义之前，但在所有其他类元素定义之后。</p>
        </li>
      </ul>
      <p>为什么会这样？对于非静态初始化器，我们有五个选项 – 它们可以在以下时机运行：</p>
      <ol>
        <li>在 <code>super</code> 之前</li>
        <li>在 <code>super</code> 之后，字段初始化之前</li>
        <li>按定义顺序交错在字段之间</li>
        <li>在字段初始化之后，子类实例化之前</li>
        <li>在子类实例化之后</li>
      </ol>
      <p>为什么选择了第 2 种方案？</p>
      <ul>
        <li>
          <p>第 1 种方案被拒绝，因为装饰器初始化器必须能够访问 <code>this</code>，而在 <code>super</code> 运行之前无法做到这一点。</p>
        </li>
        <li>
          <p>第 3 种方案被拒绝，因为同时运行所有装饰器初始化器比确保它们正确交错要简单。</p>
        </li>
      </ul>
      <ul>
        <li>
          <p>第 4 种方案被拒绝，因为在字段之前运行装饰器初始化器可以确保字段在被装饰方法完全初始化之前不会被访问。例如，如果有 <code>@bind</code> 装饰器，则字段初始化器可以依赖于被装饰的方法已被绑定。</p>
        </li>
        <li>
          <p>第 5 种方案被拒绝，因为它允许超类干扰子类，这会破坏超类不应意识到其子类的规则。</p>
        </li>
      </ul>
      <p>以下代码演示了 Babel 当前如何调用装饰器初始化器。请注意，Babel 尚不支持类字段装饰器的初始化器（这是对装饰器 API 的最近更改）。</p>
      <pre><code class="language-js" ><span class="hljs-comment" >// 我们在记录步骤时等待实例化后,</span>
<span class="hljs-comment" >// 这样我们就可以将`this`的值与实例进行比较。</span>
<span class="hljs-keyword" >const</span> steps = [];
<span class="hljs-keyword" >function</span> <span class="hljs-title function_" >push</span>(<span class="hljs-params" >msg, _this</span>) {
  steps.<span class="hljs-title function_" >push</span>({msg, _this});
}
<span class="hljs-keyword" >function</span> <span class="hljs-title function_" >pushStr</span>(<span class="hljs-params" >str</span>) {
  steps.<span class="hljs-title function_" >push</span>(str);
}

<span class="hljs-keyword" >function</span> <span class="hljs-title function_" >init</span>(<span class="hljs-params" >_value, {name, addInitializer}</span>) {
  <span class="hljs-title function_" >pushStr</span>(<span class="hljs-string" >`@init <span class="hljs-subst" >${name}</span>`</span>);
  <span class="hljs-keyword" >if</span> (addInitializer) {
    <span class="hljs-title function_" >addInitializer</span>(<span class="hljs-keyword" >function</span> (<span class="hljs-params" ></span>) {
      <span class="hljs-title function_" >push</span>(<span class="hljs-string" >`DECORATOR INITIALIZER <span class="hljs-subst" >${name}</span>`</span>, <span class="hljs-variable language_" >this</span>);
    });
  }
}

@init <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >TheClass</span> {
  <span class="hljs-comment" >//--- 静态 ---</span>

  <span class="hljs-keyword" >static</span> {
    <span class="hljs-title function_" >pushStr</span>(<span class="hljs-string" >'static block'</span>);
  }

  @init <span class="hljs-keyword" >static</span> <span class="hljs-title function_" >staticMethod</span>(<span class="hljs-params" ></span>) {}
  @init <span class="hljs-keyword" >static</span> accessor staticAcc = <span class="hljs-title function_" >pushStr</span>(<span class="hljs-string" >'staticAcc'</span>);
  @init <span class="hljs-keyword" >static</span> staticField = <span class="hljs-title function_" >pushStr</span>(<span class="hljs-string" >'staticField'</span>);

  <span class="hljs-comment" >//--- 非静态 ---</span>

  @init <span class="hljs-title function_" >prototypeMethod</span>(<span class="hljs-params" ></span>) {}
  @init accessor instanceAcc = <span class="hljs-title function_" >pushStr</span>(<span class="hljs-string" >'instanceAcc'</span>);
  @init instanceField = <span class="hljs-title function_" >pushStr</span>(<span class="hljs-string" >'instanceField'</span>);

  <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" ></span>) {
    <span class="hljs-title function_" >pushStr</span>(<span class="hljs-string" >'constructor'</span>);
  }
}

<span class="hljs-title function_" >pushStr</span>(<span class="hljs-string" >'===== 实例化 ====='</span>);
<span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >TheClass</span>();

<span class="hljs-keyword" >for</span> (<span class="hljs-keyword" >const</span> step <span class="hljs-keyword" >of</span> steps) {
  <span class="hljs-keyword" >if</span> (<span class="hljs-keyword" >typeof</span> step === <span class="hljs-string" >'string'</span>) {
    <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(step);
    <span class="hljs-keyword" >continue</span>;
  }
  <span class="hljs-keyword" >let</span> thisDesc = <span class="hljs-string" >'???'</span>;
  <span class="hljs-keyword" >if</span> (step.<span class="hljs-property" >_this</span> === <span class="hljs-title class_" >TheClass</span>) {
    thisDesc = <span class="hljs-title class_" >TheClass</span>.<span class="hljs-property" >name</span>;
  } <span class="hljs-keyword" >else</span> <span class="hljs-keyword" >if</span> (step.<span class="hljs-property" >_this</span> === inst) {
    thisDesc = <span class="hljs-string" >'inst'</span>;
  } <span class="hljs-keyword" >else</span> <span class="hljs-keyword" >if</span> (step.<span class="hljs-property" >_this</span> === <span class="hljs-literal" >undefined</span>) {
    thisDesc = <span class="hljs-string" >'undefined'</span>;
  }
  <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >`<span class="hljs-subst" >${step.msg}</span> (this===<span class="hljs-subst" >${thisDesc}</span>)`</span>);
}

<span class="hljs-comment" >// 输出：</span>
<span class="hljs-comment" >// @init staticMethod</span>
<span class="hljs-comment" >// @init staticAcc</span>
<span class="hljs-comment" >// @init prototypeMethod</span>
<span class="hljs-comment" >// @init instanceAcc</span>
<span class="hljs-comment" >// @init staticField</span>
<span class="hljs-comment" >// @init instanceField</span>
<span class="hljs-comment" >// @init TheClass</span>
<span class="hljs-comment" >// DECORATOR INITIALIZER staticMethod (this===TheClass)</span>
<span class="hljs-comment" >// DECORATOR INITIALIZER staticAcc (this===TheClass)</span>
<span class="hljs-comment" >// static block</span>
<span class="hljs-comment" >// staticAcc</span>
<span class="hljs-comment" >// staticField</span>
<span class="hljs-comment" >// DECORATOR INITIALIZER TheClass (this===TheClass)</span>
<span class="hljs-comment" >// ===== Instantiation =====</span>
<span class="hljs-comment" >// DECORATOR INITIALIZER prototypeMethod (this===inst)</span>
<span class="hljs-comment" >// DECORATOR INITIALIZER instanceAcc (this===inst)</span>
<span class="hljs-comment" >// instanceAcc</span>
<span class="hljs-comment" >// instanceField</span>
<span class="hljs-comment" >// constructor</span>
</code></pre>
      <h2 id="techniques-for-exposing-data-from-decorators" tabindex="-1">装饰器暴露数据的技巧&nbsp;&nbsp;<a class="heading-anchor" href="#techniques-for-exposing-data-from-decorators" aria-hidden="true">#</a></h2>
      <p>有时装饰器会收集数据。让我们探索它们如何将这些数据提供给其他方。</p>
      <h3 id="storing-exposed-data-in-a-surrounding-scope" tabindex="-1">在外部作用域存储暴露的数据&nbsp;&nbsp;<a class="heading-anchor" href="#storing-exposed-data-in-a-surrounding-scope" aria-hidden="true">#</a></h3>
      <p>最简单的解决方案是将数据存储在外部作用域的某个位置。例如，装饰器 <code>@collect</code> 收集类并将它们存储在 Set <code>classes</code> 中（A 行）：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >const</span> classes = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>(); <span class="hljs-comment" >// (A)</span>

<span class="hljs-keyword" >function</span> <span class="hljs-title function_" >collect</span>(<span class="hljs-params" >value, {kind, addInitializer}</span>) {
  <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'class'</span>) {
    classes.<span class="hljs-title function_" >add</span>(value);
  }
}

@collect
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >A</span> {}
@collect
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >B</span> {}
@collect
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {}

assert.<span class="hljs-title function_" >deepEqual</span>(
  classes, <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>([A, B, C])
);
</code></pre>
      <p>此方法的缺点是，如果装饰器来自另一个模块，则此方法无效。</p>
      <h3 id="managing-exposed-data-via-a-factory-function" tabindex="-1">通过工厂函数管理暴露的数据&nbsp;&nbsp;<a class="heading-anchor" href="#managing-exposed-data-via-a-factory-function" aria-hidden="true">#</a></h3>
      <p>一种更复杂的方法是使用工厂函数 <code>createClassCollector()</code>，该函数返回：</p>
      <ul>
        <li>一个类装饰器 <code>collect</code></li>
        <li>一个 Set <code>classes</code>，装饰器将把收集到的类添加到其中</li>
      </ul>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >createClassCollector</span>(<span class="hljs-params" ></span>) {
  <span class="hljs-keyword" >const</span> classes = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>();
  <span class="hljs-keyword" >function</span> <span class="hljs-title function_" >collect</span>(<span class="hljs-params" >value, {kind, addInitializer}</span>) {
    <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'class'</span>) {
      classes.<span class="hljs-title function_" >add</span>(value);
    }
  }
  <span class="hljs-keyword" >return</span> {
    classes,
    collect,
  };
}

<span class="hljs-keyword" >const</span> {classes, collect} = <span class="hljs-title function_" >createClassCollector</span>();

@collect
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >A</span> {}
@collect
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >B</span> {}
@collect
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {}

assert.<span class="hljs-title function_" >deepEqual</span>(
  classes, <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>([A, B, C])
);
</code></pre>
      <h3 id="managing-exposed-data-via-a-class" tabindex="-1">通过类管理暴露的数据&nbsp;&nbsp;<a class="heading-anchor" href="#managing-exposed-data-via-a-class" aria-hidden="true">#</a></h3>
      <p>我们也可以使用类来代替工厂函数。它有两个成员：</p>
      <ul>
        <li><code>.classes</code>，一个包含收集到的类的 Set</li>
        <li><code>.install</code>，一个类装饰器</li>
      </ul>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >ClassCollector</span> {
  classes = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>();
  install = <span class="hljs-function" >(<span class="hljs-params" >value, {kind}</span>) =&gt;</span> { <span class="hljs-comment" >// (A)</span>
    <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'class'</span>) {
      <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >classes</span>.<span class="hljs-title function_" >add</span>(value); <span class="hljs-comment" >// (B)</span>
    }
  };
}

<span class="hljs-keyword" >const</span> collector = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >ClassCollector</span>();

@collector.<span class="hljs-property" >install</span>
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >A</span> {}
@collector.<span class="hljs-property" >install</span>
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >B</span> {}
@collector.<span class="hljs-property" >install</span>
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {}

assert.<span class="hljs-title function_" >deepEqual</span>(
  collector.<span class="hljs-property" >classes</span>, <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>([A, B, C])
);
</code></pre>
      <p>我们通过将一个箭头函数分配给公共实例字段来实现 <code>.install</code>（A 行）。实例字段初始化器在 <code>this</code> 指向当前实例的作用域中运行。这也是箭头函数的外部作用域，解释了为什么 <code>this</code> 在 B 行具有该值。</p>
      <p>我们也可以通过 getter 来实现 <code>.install</code>，但那样的话，每次读取 <code>.install</code> 时都必须返回一个新函数。</p>
      <h2 id="class-decorators" tabindex="-1">类装饰器&nbsp;&nbsp;<a class="heading-anchor" href="#class-decorators" aria-hidden="true">#</a></h2>
      <p>类装饰器具有以下类型签名：</p>
      <pre><code class="language-ts" ><span class="hljs-keyword" >type</span> <span class="hljs-title class_" >ClassDecorator</span> = <span class="hljs-function" >(<span class="hljs-params" >
  <span class="hljs-attr" >value</span>: <span class="hljs-title class_" >Function</span>,
  <span class="hljs-attr" >context</span>: {
    kind: <span class="hljs-string" >'class'</span>;
    name: <span class="hljs-built_in" >string</span> | <span class="hljs-literal" >undefined</span>;
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" >void</span>): <span class="hljs-built_in" >void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_" >Function</span> | <span class="hljs-built_in" >void</span>;
</code></pre>
      <p>类装饰器的能力：</p>
      <ul>
        <li>它可以通过改变 <code>value</code> 来改变被装饰的类。</li>
        <li>它可以通过返回可调用的值来替换被装饰的类。</li>
        <li>它可以注册初始化器，初始化器在被装饰的类完全设置后调用。</li>
        <li>由于类不是其他语言结构的成员（而方法是类的成员），因此它不获取 <code>context.access</code>。</li>
      </ul>
      <h3 id="example%3A-collecting-instances" tabindex="-1">示例：收集实例&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-collecting-instances" aria-hidden="true">#</a></h3>
      <p>在下面的示例中，我们使用装饰器收集所有被装饰类的实例：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >InstanceCollector</span> {
  instances = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>();
  install = <span class="hljs-function" >(<span class="hljs-params" >value, {kind}</span>) =&gt;</span> {
    <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'class'</span>) {
      <span class="hljs-keyword" >const</span> _this = <span class="hljs-variable language_" >this</span>;
      <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" >...args</span>) { <span class="hljs-comment" >// (A)</span>
        <span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >value</span>(...args); <span class="hljs-comment" >// (B)</span>
        _this.<span class="hljs-property" >instances</span>.<span class="hljs-title function_" >add</span>(inst);
        <span class="hljs-keyword" >return</span> inst;
      };
    }
  };
}

<span class="hljs-keyword" >const</span> collector = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >InstanceCollector</span>();

@collector.<span class="hljs-property" >install</span>
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >MyClass</span> {}

<span class="hljs-keyword" >const</span> inst1 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();
<span class="hljs-keyword" >const</span> inst2 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();
<span class="hljs-keyword" >const</span> inst3 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();

assert.<span class="hljs-title function_" >deepEqual</span>(
  collector.<span class="hljs-property" >instances</span>, <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>([inst1, inst2, inst3])
);
</code></pre>
      <p>我们通过将一个函数包装在 <code>.install</code> 中来实现收集实例。该函数在实例化时被调用，并将新创建的实例添加到收集器的实例集合中。</p>
      <p>请注意，我们不能在 A 行返回一个箭头函数，因为箭头函数不能被 new 调用。</p>
      <p>此方法的一个缺点是，它破坏了 <code>instanceof</code>：</p>
      <pre><code class="language-js" >assert.<span class="hljs-title function_" >equal</span>(
  inst1 <span class="hljs-keyword" >instanceof</span> <span class="hljs-title class_" >MyClass</span>,
  <span class="hljs-literal" >false</span>
);
</code></pre>
      <p>下一小节将解释我们如何修复这个问题。</p>
      <h3 id="making-sure-that-instanceof-works" tabindex="-1">确保 <code>instanceof</code> 正常工作&nbsp;&nbsp;<a class="heading-anchor" href="#making-sure-that-instanceof-works" aria-hidden="true">#</a></h3>
      <p>在本节中，我们将使用简单的装饰器 <code>@countInstances</code> 来演示如何使被包装的类支持 <code>instanceof</code>。</p>
      <h4 id="enabling-instanceof-via-.prototype" tabindex="-1">通过 <code>.prototype</code> 启用 <code>instanceof</code>&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-.prototype" aria-hidden="true">#</a></h4>
      <p>启用 <code>instanceof</code> 的一种方法是将包装函数的 <code>.prototype</code> 设置为被包装的 <code>value</code> 的 <code>.prototype</code>（A 行）：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >countInstances</span>(<span class="hljs-params" >value</span>) {
  <span class="hljs-keyword" >const</span> _this = <span class="hljs-variable language_" >this</span>;
  <span class="hljs-keyword" >let</span> instanceCount = <span class="hljs-number" >0</span>;
  <span class="hljs-comment" >// 包装器必须是可通过 new 调用的</span>
  <span class="hljs-keyword" >const</span> wrapper = <span class="hljs-keyword" >function</span> (<span class="hljs-params" >...args</span>) {
    instanceCount++;
    <span class="hljs-keyword" >const</span> instance = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >value</span>(...args);
    <span class="hljs-comment" >// 修改实例</span>
    instance.<span class="hljs-property" >count</span> = instanceCount;
    <span class="hljs-keyword" >return</span> instance;
  };
  wrapper.<span class="hljs-property" ><span class="hljs-keyword" >prototype</span></span> = value.<span class="hljs-property" ><span class="hljs-keyword" >prototype</span></span>; <span class="hljs-comment" >// (A)</span>
  <span class="hljs-keyword" >return</span> wrapper;
}

@countInstances
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >MyClass</span> {}

<span class="hljs-keyword" >const</span> inst1 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();
assert.<span class="hljs-title function_" >ok</span>(inst1 <span class="hljs-keyword" >instanceof</span> <span class="hljs-title class_" >MyClass</span>);
assert.<span class="hljs-title function_" >equal</span>(inst1.<span class="hljs-property" >count</span>, <span class="hljs-number" >1</span>);

<span class="hljs-keyword" >const</span> inst2 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();
assert.<span class="hljs-title function_" >ok</span>(inst2 <span class="hljs-keyword" >instanceof</span> <span class="hljs-title class_" >MyClass</span>);
assert.<span class="hljs-title function_" >equal</span>(inst2.<span class="hljs-property" >count</span>, <span class="hljs-number" >2</span>);
</code></pre>
      <p>这是有效的，原因如下：</p>
      <pre><code class="language-js" >inst <span class="hljs-keyword" >instanceof</span> C
C.<span class="hljs-property" ><span class="hljs-keyword" >prototype</span></span>.<span class="hljs-title function_" >isPrototypeOf</span>(inst)
</code></pre>
      <p>有关 <code>instanceof</code> 的更多信息，请参见 <a href="https://exploringjs.com/js/book/ch_classes.html#instanceof-operator">《探索 JavaScript》</a>。</p>
      <h4 id="enabling-instanceof-via-symbol.hasinstance" tabindex="-1">通过 <code>Symbol.hasInstance</code> 启用 <code>instanceof</code>&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-symbol.hasinstance" aria-hidden="true">#</a></h4>
      <p>启用 <code>instanceof</code> 的另一种选择是给包装函数一个键为 <code>Symbol.hasInstance</code> 的方法（A 行）：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >countInstances</span>(<span class="hljs-params" >value</span>) {
  <span class="hljs-keyword" >const</span> _this = <span class="hljs-variable language_" >this</span>;
  <span class="hljs-keyword" >let</span> instanceCount = <span class="hljs-number" >0</span>;
  <span class="hljs-comment" >// 包装器必须是可通过 new 调用的</span>
  <span class="hljs-keyword" >const</span> wrapper = <span class="hljs-keyword" >function</span> (<span class="hljs-params" >...args</span>) {
    instanceCount++;
    <span class="hljs-keyword" >const</span> instance = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >value</span>(...args);
    <span class="hljs-comment" >// 修改实例</span>
    instance.<span class="hljs-property" >count</span> = instanceCount;
    <span class="hljs-keyword" >return</span> instance;
  };
  <span class="hljs-comment" >// 属性是只读的，因此我们不能使用赋值</span>
  <span class="hljs-title class_" >Object</span>.<span class="hljs-title function_" >defineProperty</span>( <span class="hljs-comment" >// (A)</span>
    wrapper, <span class="hljs-title class_" >Symbol</span>.<span class="hljs-property" >hasInstance</span>,
    {
      <span class="hljs-attr" >value</span>: <span class="hljs-keyword" >function</span> (<span class="hljs-params" >x</span>) {
        <span class="hljs-keyword" >return</span> x <span class="hljs-keyword" >instanceof</span> value; 
      }
    }
  );
  <span class="hljs-keyword" >return</span> wrapper;
}

@countInstances
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >MyClass</span> {}

<span class="hljs-keyword" >const</span> inst1 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();
assert.<span class="hljs-title function_" >ok</span>(inst1 <span class="hljs-keyword" >instanceof</span> <span class="hljs-title class_" >MyClass</span>);
assert.<span class="hljs-title function_" >equal</span>(inst1.<span class="hljs-property" >count</span>, <span class="hljs-number" >1</span>);

<span class="hljs-keyword" >const</span> inst2 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();
assert.<span class="hljs-title function_" >ok</span>(inst2 <span class="hljs-keyword" >instanceof</span> <span class="hljs-title class_" >MyClass</span>);
assert.<span class="hljs-title function_" >equal</span>(inst2.<span class="hljs-property" >count</span>, <span class="hljs-number" >2</span>);
</code></pre>
      <p>《探索 JavaScript》 中有<a href="https://exploringjs.com/js/book/ch_symbols.html#publicly-known-symbols">关于 <code>Symbol.hasInstance</code> 的更多信息</a>。</p>
      <h4 id="enabling-instanceof-via-subclassing" tabindex="-1">通过子类化启用 <code>instanceof</code>&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-subclassing" aria-hidden="true">#</a></h4>
      <p>我们还可以通过返回 <code>value</code> 的子类来启用 <code>instanceof</code>（A 行）：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >countInstances</span>(<span class="hljs-params" >value</span>) {
  <span class="hljs-keyword" >const</span> _this = <span class="hljs-variable language_" >this</span>;
  <span class="hljs-keyword" >let</span> instanceCount = <span class="hljs-number" >0</span>;
  <span class="hljs-comment" >// 包装器必须是可通过 new 调用的</span>
  <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >extends</span> value { <span class="hljs-comment" >// (A)</span>
    <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >...args</span>) {
      <span class="hljs-variable language_" >super</span>(...args);
      instanceCount++;
      <span class="hljs-comment" >// 修改实例</span>
      <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >count</span> = instanceCount;
    }
  };
}

@countInstances
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >MyClass</span> {}

<span class="hljs-keyword" >const</span> inst1 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();
assert.<span class="hljs-title function_" >ok</span>(inst1 <span class="hljs-keyword" >instanceof</span> <span class="hljs-title class_" >MyClass</span>);
assert.<span class="hljs-title function_" >equal</span>(inst1.<span class="hljs-property" >count</span>, <span class="hljs-number" >1</span>);

<span class="hljs-keyword" >const</span> inst2 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();
assert.<span class="hljs-title function_" >ok</span>(inst2 <span class="hljs-keyword" >instanceof</span> <span class="hljs-title class_" >MyClass</span>);
assert.<span class="hljs-title function_" >equal</span>(inst2.<span class="hljs-property" >count</span>, <span class="hljs-number" >2</span>);
</code></pre>
      <h3 id="example-freezing-instances" tabindex="-1">示例：冻结实例&nbsp;&nbsp;<a class="heading-anchor" href="#example-freezing-instances" aria-hidden="true">#</a></h3>
      <p>装饰器类 <code>@freeze</code> 通过冻结它所装饰的类生成的所有实例来实现：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >freeze</span> (<span class="hljs-params" >value, {kind}</span>) {
  <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'class'</span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" >...args</span>) {
      <span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >value</span>(...args);
      <span class="hljs-keyword" >return</span> <span class="hljs-title class_" >Object</span>.<span class="hljs-title function_" >freeze</span>(inst);
    }
  }
}

@freeze
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Color</span> {
  <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >name</span>) {
    <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >name</span> = name;
  }
}

<span class="hljs-keyword" >const</span> red = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>(<span class="hljs-string" >'red'</span>);
assert.<span class="hljs-title function_" >throws</span>(
  <span class="hljs-function" >() =&gt;</span> red.<span class="hljs-property" >name</span> = <span class="hljs-string" >'green'</span>,
  <span class="hljs-regexp" >/^TypeError: Cannot assign to read only property 'name'/</span>
);
</code></pre>
      <p>此装饰器有以下缺点：</p>
      <ul>
        <li>它破坏了 <code>instanceof</code>。我们已经看到如何修复这个问题。</li>
        <li>对装饰类的子类化效果不佳：
          <ul>
            <li>构造函数的连接方式并不理想，因为混合了包装构造函数。这可以通过返回被装饰的 <code>value</code> 的子类来部分修复。</li>
            <li>子类无法设置属性，因为它们的 <code>this</code> 是不可变的。无法避免此缺点。</li>
          </ul>
        </li>
      </ul>
      <p>最后一个缺点可以通过在所有构造函数执行后让类装饰器访问装饰类的实例来避免。</p>
      <p>这将改变继承的工作方式，因为超类现在可以更改由子类添加的属性。因此，未来是否会有这样的机制尚不确定。</p>
      <h3 id="example%3A-making-classes-function-callable" tabindex="-1">示例：让类可函数调用&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-making-classes-function-callable" aria-hidden="true">#</a></h3>
      <p>被 <code>@functionCallable</code> 装饰的类可以通过函数调用而不是 <code>new</code> 操作符来调用：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >functionCallable</span>(<span class="hljs-params" >value, {kind}</span>) {
  <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'class'</span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" >...args</span>) {
      <span class="hljs-keyword" >if</span> (<span class="hljs-keyword" >new</span>.<span class="hljs-property" >target</span> !== <span class="hljs-literal" >undefined</span>) {
        <span class="hljs-keyword" >throw</span> <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >TypeError</span>(<span class="hljs-string" >'This function can’t be new-invoked'</span>);
      }
      <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >value</span>(...args);
    }
  }
}

@functionCallable
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Person</span> {
  <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >name</span>) {
    <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >name</span> = name;
  }
}
<span class="hljs-keyword" >const</span> robin = <span class="hljs-title class_" >Person</span>(<span class="hljs-string" >'Robin'</span>);
assert.<span class="hljs-title function_" >equal</span>(
  robin.<span class="hljs-property" >name</span>, <span class="hljs-string" >'Robin'</span>
);
</code></pre>
      <h2 id="class-method-decorators" tabindex="-1">类方法装饰器&nbsp;&nbsp;<a class="heading-anchor" href="#class-method-decorators" aria-hidden="true">#</a></h2>
      <p>类方法装饰器具有以下类型签名：</p>
      <pre><code class="language-ts" ><span class="hljs-keyword" >type</span> <span class="hljs-title class_" >ClassMethodDecorator</span> = <span class="hljs-function" >(<span class="hljs-params" >
  <span class="hljs-attr" >value</span>: <span class="hljs-title class_" >Function</span>,
  <span class="hljs-attr" >context</span>: {
    kind: <span class="hljs-string" >'method'</span>;
    name: <span class="hljs-built_in" >string</span> | <span class="hljs-built_in" >symbol</span>;
    <span class="hljs-keyword" >static</span>: <span class="hljs-built_in" >boolean</span>;
    <span class="hljs-keyword" >private</span>: <span class="hljs-built_in" >boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in" >unknown</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" >void</span>): <span class="hljs-built_in" >void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_" >Function</span> | <span class="hljs-built_in" >void</span>;
</code></pre>
      <p>方法装饰器的能力：</p>
      <ul>
        <li>它可以通过改变 <code>value</code> 来改变被装饰的方法。</li>
        <li>它可以通过返回一个函数来替换被装饰的方法。</li>
        <li>它可以注册初始化器。</li>
        <li><code>context.access</code> 仅支持获取其属性的值，而不支持设置。</li>
      </ul>
      <p>构造函数不能被装饰：它们看起来像方法，但实际上并不是真正的方法。</p>
      <h3 id="example-tracing-method-invocations" tabindex="-1">示例：追踪方法调用&nbsp;&nbsp;<a class="heading-anchor" href="#example-tracing-method-invocations" aria-hidden="true">#</a></h3>
      <p>装饰器 <code>@trace</code> 包装方法，以便将它们的调用及结果记录到控制台：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >trace</span>(<span class="hljs-params" >value, {kind, name}</span>) {
  <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'method'</span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" >...args</span>) {
      <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >`CALL <span class="hljs-subst" >${name}</span>: <span class="hljs-subst" >${<span class="hljs-built_in" >JSON</span>.stringify(args)}</span>`</span>);
      <span class="hljs-keyword" >const</span> result = value.<span class="hljs-title function_" >apply</span>(<span class="hljs-variable language_" >this</span>, args);
      <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >'=&gt; '</span> + <span class="hljs-title class_" >JSON</span>.<span class="hljs-title function_" >stringify</span>(result));
      <span class="hljs-keyword" >return</span> result;
    };
  }
}

<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >StringBuilder</span> {
  #str = <span class="hljs-string" >''</span>;
  @trace
  <span class="hljs-title function_" >add</span>(<span class="hljs-params" >str</span>) {
    <span class="hljs-variable language_" >this</span>.#str += str;
  }
  @trace
  <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-variable language_" >this</span>.#str;
  }
}

<span class="hljs-keyword" >const</span> sb = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >StringBuilder</span>();
sb.<span class="hljs-title function_" >add</span>(<span class="hljs-string" >'Home'</span>);
sb.<span class="hljs-title function_" >add</span>(<span class="hljs-string" >'page'</span>);
assert.<span class="hljs-title function_" >equal</span>(
  sb.<span class="hljs-title function_" >toString</span>(), <span class="hljs-string" >'Homepage'</span>
);

<span class="hljs-comment" >// 输出：</span>
<span class="hljs-comment" >// CALL add: ["Home"]</span>
<span class="hljs-comment" >// =&gt; undefined</span>
<span class="hljs-comment" >// CALL add: ["page"]</span>
<span class="hljs-comment" >// =&gt; undefined</span>
<span class="hljs-comment" >// CALL toString: []</span>
<span class="hljs-comment" >// =&gt; "Homepage"</span>
</code></pre>
      <h3 id="example%3A-binding-methods-to-instances" tabindex="-1">示例：将方法绑定到实例&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-binding-methods-to-instances" aria-hidden="true">#</a></h3>
      <p>通常，提取方法（A 行）意味着我们无法函数调用它们，因为这会将 <code>this</code> 设置为 <code>undefined</code>：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Color1</span> {
  #name;
  <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >name</span>) {
    <span class="hljs-variable language_" >this</span>.#name = name;
  }
  <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-string" >`Color(<span class="hljs-subst" >${<span class="hljs-variable language_" >this</span>.#name}</span>)`</span>;
  }
}

<span class="hljs-keyword" >const</span> green1 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color1</span>(<span class="hljs-string" >'green'</span>);
<span class="hljs-keyword" >const</span> toString1 = green1.<span class="hljs-property" >toString</span>; <span class="hljs-comment" >// (A)</span>
assert.<span class="hljs-title function_" >throws</span>(
  <span class="hljs-function" >() =&gt;</span> <span class="hljs-title function_" >toString1</span>(),
  <span class="hljs-regexp" >/^TypeError: Cannot read properties of undefined/</span>
);
</code></pre>
      <p>我们可以通过装饰器 <code>@bind</code> 修复这个问题：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >bind</span>(<span class="hljs-params" >value, {kind, name, addInitializer}</span>) {
  <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'method'</span>) {
    <span class="hljs-title function_" >addInitializer</span>(<span class="hljs-keyword" >function</span> (<span class="hljs-params" ></span>) { <span class="hljs-comment" >// (B)</span>
      <span class="hljs-variable language_" >this</span>[name] = value.<span class="hljs-title function_" >bind</span>(<span class="hljs-variable language_" >this</span>); <span class="hljs-comment" >// (C)</span>
    });
  }
}

<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Color2</span> {
  #name;
  <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >name</span>) {
    <span class="hljs-variable language_" >this</span>.#name = name;
  }
  @bind
  <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-string" >`Color(<span class="hljs-subst" >${<span class="hljs-variable language_" >this</span>.#name}</span>)`</span>;
  }
}

<span class="hljs-keyword" >const</span> green2 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color2</span>(<span class="hljs-string" >'green'</span>);
<span class="hljs-keyword" >const</span> toString2 = green2.<span class="hljs-property" >toString</span>;
assert.<span class="hljs-title function_" >equal</span>(
  <span class="hljs-title function_" >toString2</span>(), <span class="hljs-string" >'Color(green)'</span>
);

<span class="hljs-comment" >// 自有属性 green2.toString 与</span>
<span class="hljs-comment" >// Color2.prototype.toString 不同</span>
assert.<span class="hljs-title function_" >ok</span>(<span class="hljs-title class_" >Object</span>.<span class="hljs-title function_" >hasOwn</span>(green2, <span class="hljs-string" >'toString'</span>));
assert.<span class="hljs-title function_" >notEqual</span>(
  green2.<span class="hljs-property" >toString</span>,
  <span class="hljs-title class_" >Color2</span>.<span class="hljs-property" ><span class="hljs-keyword" >prototype</span></span>.<span class="hljs-property" >toString</span>
);
</code></pre>
      <p>通过将 A 行的初始化器注册为普通函数，我们可以在实例化时访问 <code>this</code>。这也解释了为什么 B 行的 <code>this</code> 具有该值。(line C)</p>
      <h3 id="example%3A-applying-functions-to-methods" tabindex="-1">示例：对方法应用函数&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-applying-functions-to-methods" aria-hidden="true">#</a></h3>
      <p>库 <code>core-decorators</code> 提供了一个装饰器，允许我们对方法应用函数。这使我们能够使用像 Lodash 的 <code>memoize()</code> 这样的辅助函数。以下代码展示了装饰器 <code>@applyFunction</code> 的实现：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >import</span> { memoize } <span class="hljs-keyword" >from</span> <span class="hljs-string" >'lodash-es'</span>;

<span class="hljs-keyword" >function</span> <span class="hljs-title function_" >applyFunction</span>(<span class="hljs-params" >functionFactory</span>) {
  <span class="hljs-keyword" >return</span> <span class="hljs-function" >(<span class="hljs-params" >value, {kind}</span>) =&gt;</span> { <span class="hljs-comment" >// 装饰器函数</span>
    <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'method'</span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-title function_" >functionFactory</span>(value);
    }
  };
}

<span class="hljs-keyword" >let</span> invocationCount = <span class="hljs-number" >0</span>;

<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Task</span> {
  @<span class="hljs-title function_" >applyFunction</span>(memoize)
  <span class="hljs-title function_" >expensiveOperation</span>(<span class="hljs-params" >str</span>) {
    invocationCount++;
    <span class="hljs-comment" >// str` 的昂贵开销 😀</span>
    <span class="hljs-keyword" >return</span> str + str;
  }
}

<span class="hljs-keyword" >const</span> task = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Task</span>();
assert.<span class="hljs-title function_" >equal</span>(
  task.<span class="hljs-title function_" >expensiveOperation</span>(<span class="hljs-string" >'abc'</span>),
  <span class="hljs-string" >'abcabc'</span>
);
assert.<span class="hljs-title function_" >equal</span>(
  task.<span class="hljs-title function_" >expensiveOperation</span>(<span class="hljs-string" >'abc'</span>),
  <span class="hljs-string" >'abcabc'</span>
);
assert.<span class="hljs-title function_" >equal</span>(
  invocationCount, <span class="hljs-number" >1</span>
);
</code></pre>
      <h2 id="class-getter-decorators%2C-class-setter-decorators" tabindex="-1">类 getter 装饰器、setter 装饰器&nbsp;&nbsp;<a class="heading-anchor" href="#class-getter-decorators%2C-class-setter-decorators" aria-hidden="true">#</a></h2>
      <p>这些是 getter 装饰器和 setter 装饰器的类型签名：</p>
      <pre><code class="language-ts" ><span class="hljs-keyword" >type</span> <span class="hljs-title class_" >ClassGetterDecorator</span> = <span class="hljs-function" >(<span class="hljs-params" >
  <span class="hljs-attr" >value</span>: <span class="hljs-title class_" >Function</span>,
  <span class="hljs-attr" >context</span>: {
    kind: <span class="hljs-string" >'getter'</span>;
    name: <span class="hljs-built_in" >string</span> | <span class="hljs-built_in" >symbol</span>;
    <span class="hljs-keyword" >static</span>: <span class="hljs-built_in" >boolean</span>;
    <span class="hljs-keyword" >private</span>: <span class="hljs-built_in" >boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in" >unknown</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" >void</span>): <span class="hljs-built_in" >void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_" >Function</span> | <span class="hljs-built_in" >void</span>;

<span class="hljs-keyword" >type</span> <span class="hljs-title class_" >ClassSetterDecorator</span> = <span class="hljs-function" >(<span class="hljs-params" >
  <span class="hljs-attr" >value</span>: <span class="hljs-title class_" >Function</span>,
  <span class="hljs-attr" >context</span>: {
    kind: <span class="hljs-string" >'setter'</span>;
    name: <span class="hljs-built_in" >string</span> | <span class="hljs-built_in" >symbol</span>;
    <span class="hljs-keyword" >static</span>: <span class="hljs-built_in" >boolean</span>;
    <span class="hljs-keyword" >private</span>: <span class="hljs-built_in" >boolean</span>;
    access: { set: (value: <span class="hljs-built_in" >unknown</span>) =&gt; <span class="hljs-built_in" >void</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" >void</span>): <span class="hljs-built_in" >void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_" >Function</span> | <span class="hljs-built_in" >void</span>;
</code></pre>
      <p>getter 装饰器和 setter 装饰器的能力类似于方法装饰器。</p>
      <h3 id="example%3A-computing-values-lazily" tabindex="-1">示例：惰性计算值&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-computing-values-lazily" aria-hidden="true">#</a></h3>
      <p>惰性计算属性值的实现需要两种技术：</p>
      <ul>
        <li>
          <p>我们通过 getter 实现该属性。这样，计算其值的代码仅在读取属性时执行。</p>
        </li>
        <li>
          <p>装饰器 <code>@lazy</code> 包装原始 getter：当包装器第一次被调用时，它调用 getter 并创建一个自身数据属性，其值为计算结果。从此以后，无论何时有人读取该属性，自身属性都会覆盖继承的 getter。</p>
        </li>
      </ul>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
  @lazy
  <span class="hljs-keyword" >get</span> <span class="hljs-title function_" >value</span>() {
    <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >'COMPUTING'</span>);
    <span class="hljs-keyword" >return</span> <span class="hljs-string" >'Result of computation'</span>;
  }
}

<span class="hljs-keyword" >function</span> <span class="hljs-title function_" >lazy</span>(<span class="hljs-params" >value, {kind, name, addInitializer}</span>) {
  <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'getter'</span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" ></span>) {
      <span class="hljs-keyword" >const</span> result = value.<span class="hljs-title function_" >call</span>(<span class="hljs-variable language_" >this</span>);
      <span class="hljs-title class_" >Object</span>.<span class="hljs-title function_" >defineProperty</span>( <span class="hljs-comment" >// (A)</span>
        <span class="hljs-variable language_" >this</span>, name,
        {
          <span class="hljs-attr" >value</span>: result,
          <span class="hljs-attr" >writable</span>: <span class="hljs-literal" >false</span>,
        }
      );
      <span class="hljs-keyword" >return</span> result;
    };
  }
}

<span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >'1 new C()'</span>);
<span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >C</span>();
<span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >'2 inst.value'</span>);
assert.<span class="hljs-title function_" >equal</span>(inst.<span class="hljs-property" >value</span>, <span class="hljs-string" >'Result of computation'</span>);
<span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >'3 inst.value'</span>);
assert.<span class="hljs-title function_" >equal</span>(inst.<span class="hljs-property" >value</span>, <span class="hljs-string" >'Result of computation'</span>);
<span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >'4 end'</span>);

<span class="hljs-comment" >// 输出：</span>
<span class="hljs-comment" >// 1 new C()</span>
<span class="hljs-comment" >// 2 inst.value</span>
<span class="hljs-comment" >// COMPUTING</span>
<span class="hljs-comment" >// 3 inst.value</span>
<span class="hljs-comment" >// 4 end</span>
</code></pre>
      <p>请注意，属性 <code>.[name]</code> 是不可变的（因为只有一个 getter），这就是为什么我们必须在 A 行定义该属性，而不能使用赋值的原因。</p>
      <h2 id="class-field-decorators" tabindex="-1">类字段装饰器&nbsp;&nbsp;<a class="heading-anchor" href="#class-field-decorators" aria-hidden="true">#</a></h2>
      <p>类字段装饰器具有以下类型签名：</p>
      <pre><code class="language-ts" ><span class="hljs-keyword" >type</span> <span class="hljs-title class_" >ClassFieldDecorator</span> = <span class="hljs-function" >(<span class="hljs-params" >
  <span class="hljs-attr" >value</span>: <span class="hljs-literal" >undefined</span>,
  <span class="hljs-attr" >context</span>: {
    kind: <span class="hljs-string" >'field'</span>;
    name: <span class="hljs-built_in" >string</span> | <span class="hljs-built_in" >symbol</span>;
    <span class="hljs-keyword" >static</span>: <span class="hljs-built_in" >boolean</span>;
    <span class="hljs-keyword" >private</span>: <span class="hljs-built_in" >boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in" >unknown</span>, set: (value: <span class="hljs-built_in" >unknown</span>) =&gt; <span class="hljs-built_in" >void</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" >void</span>): <span class="hljs-built_in" >void</span>;
  }
</span>) =&gt;</span> <span class="hljs-function" >(<span class="hljs-params" ><span class="hljs-attr" >initialValue</span>: <span class="hljs-built_in" >unknown</span></span>) =&gt;</span> <span class="hljs-built_in" >unknown</span> | <span class="hljs-built_in" >void</span>;
</code></pre>
      <p>字段装饰器的能力：</p>
      <ul>
        <li>
          <p>它不能改变或替换它的字段。如果我们需要该功能，我们必须使用 <em>自动访问器</em>（稍后将解释的内容）。</p>
        </li>
        <li>
          <p>通过返回一个接收原始初始化值并返回新初始化值的函数来改变字段的初始化值。</p>
          <ul>
            <li>在该函数内部，<code>this</code> 指向当前实例。</li>
          </ul>
        </li>
        <li>
          <p>注册初始化器。这是装饰器 API 的一个最近更改（2022-03 之后），之前是不可行的。</p>
        </li>
      </ul>
      <ul>
        <li>它可以通过 <code>context.access</code> 暴露对其字段的访问（即使是私有字段）。</li>
      </ul>
      <h3 id="example%3A-changing-initialization-values-of-fields" tabindex="-1">示例：改变字段初始化值&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-changing-initialization-values-of-fields" aria-hidden="true">#</a></h3>
      <p>装饰器 <code>@twice</code> 通过返回一个函数来改变字段的原始初始化值，该函数接收原始值并返回新值：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >twice</span>(<span class="hljs-params" ></span>) {
  <span class="hljs-keyword" >return</span> <span class="hljs-function" ><span class="hljs-params" >initialValue</span> =&gt;</span> initialValue * <span class="hljs-number" >2</span>;
}

<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
  @twice
  field = <span class="hljs-number" >3</span>;
}

<span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >C</span>();
assert.<span class="hljs-title function_" >equal</span>(
  inst.<span class="hljs-property" >field</span>, <span class="hljs-number" >6</span>
);
</code></pre>
      <h3 id="read-only-fields" tabindex="-1">示例：只读字段（实例公有字段）&nbsp;&nbsp;<a class="heading-anchor" href="#read-only-fields" aria-hidden="true">#</a></h3>
      <p>装饰器 <code>@readOnly</code> 通过在字段完全设置后（通过赋值或构造函数）使其不可变来实现。</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >const</span> readOnlyFieldKeys = <span class="hljs-title class_" >Symbol</span>(<span class="hljs-string" >'readOnlyFieldKeys'</span>);

@readOnly
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Color</span> {
  @readOnly
  name;
  <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >name</span>) {
    <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >name</span> = name;
  }
}

<span class="hljs-keyword" >const</span> blue = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>(<span class="hljs-string" >'blue'</span>);
assert.<span class="hljs-title function_" >equal</span>(blue.<span class="hljs-property" >name</span>, <span class="hljs-string" >'blue'</span>);
assert.<span class="hljs-title function_" >throws</span>(
  <span class="hljs-function" >() =&gt;</span> blue.<span class="hljs-property" >name</span> = <span class="hljs-string" >'brown'</span>,
  <span class="hljs-regexp" >/^TypeError: Cannot assign to read only property 'name'/</span>
);

<span class="hljs-keyword" >function</span> <span class="hljs-title function_" >readOnly</span>(<span class="hljs-params" >value, {kind, name}</span>) {
  <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'field'</span>) { <span class="hljs-comment" >// (A)</span>
    <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" ></span>) {
      <span class="hljs-keyword" >if</span> (!<span class="hljs-variable language_" >this</span>[readOnlyFieldKeys]) {
        <span class="hljs-variable language_" >this</span>[readOnlyFieldKeys] = [];
      }
      <span class="hljs-variable language_" >this</span>[readOnlyFieldKeys].<span class="hljs-title function_" >push</span>(name);
    };
  }
  <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'class'</span>) { <span class="hljs-comment" >// (B)</span>
    <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" >...args</span>) {
      <span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >value</span>(...args);
      <span class="hljs-keyword" >for</span> (<span class="hljs-keyword" >const</span> key <span class="hljs-keyword" >of</span> inst[readOnlyFieldKeys]) {
        <span class="hljs-title class_" >Object</span>.<span class="hljs-title function_" >defineProperty</span>(inst, key, {<span class="hljs-attr" >writable</span>: <span class="hljs-literal" >false</span>});
      }
      <span class="hljs-keyword" >return</span> inst;
    }
  }
}
</code></pre>
      <p>我们需要两步来让 <code>@readOnly</code> 生效(这也是类也被装饰了的原因):</p>
      <ul>
        <li>我们首先收集所有要变成只读的字段 (line A).</li>
        <li>等实例已经创建完成，我们再把收集的字段设为不可写(line B)。我们需要把类包起来因为装饰器初始化器执行得太早了。</li>
      </ul>
      <p>和不可变类似，这个装饰器也会破坏<code>instanceof</code>的行为。 变通方法也是一样的。</p>
      <p>我们一会会看到， <a href="#read-only-auto-accessors"> <code>@readOnly</code>能够和auto-accessor互动而非和字段互动的版本</a>。而且使用过程不需要装饰类。</p>
      <h3 id="example%3A-dependency-injection-(instance-public-fields)" tabindex="-1">示例：依赖注入（实例public字段）&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-dependency-injection-(instance-public-fields)" aria-hidden="true">#</a></h3>
      <p><em>依赖注入（Dependency Injection）</em> 是由以下观察推动的：如果我们提供类的构造函数其依赖项（而不是构造函数自己设置它们），那么就更容易适应不同的环境，包括测试。</p>
      <p>这是一种​<em>​控制反转（Inversion of Control）</em>​​：构造函数本身不执行初始化操作，而是由我们代为完成。以下是实现依赖注入的几种方法：</p>
      <ol>
        <li>手动创建依赖项并传递给构造函数</li>
        <li>通过前端框架（如React）中的"contexts"实现</li>
        <li>通过装饰器和<em>依赖注入注册表</em>（<em>依赖注入容器</em>的一种变体）实现</li>
      </ol>
      <p>以下代码是方法 #3 的一个简单实现：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >const</span> {registry, inject} = <span class="hljs-title function_" >createRegistry</span>();

<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Logger</span> {
  <span class="hljs-title function_" >log</span>(<span class="hljs-params" >str</span>) {
    <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(str);
  }
}
<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Main</span> {
  @inject logger;
  <span class="hljs-title function_" >run</span>(<span class="hljs-params" ></span>) {
    <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >logger</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >'Hello!'</span>);
  }
}

registry.<span class="hljs-title function_" >register</span>(<span class="hljs-string" >'logger'</span>, <span class="hljs-title class_" >Logger</span>);
<span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Main</span>().<span class="hljs-title function_" >run</span>();

<span class="hljs-comment" >// 输出：</span>
<span class="hljs-comment" >// Hello!</span>
</code></pre>
      <p>这就是 <code>createRegistry()</code> 的实装方法:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >createRegistry</span>(<span class="hljs-params" ></span>) {
  <span class="hljs-keyword" >const</span> nameToClass = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Map</span>();
  <span class="hljs-keyword" >const</span> nameToInstance = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Map</span>();
  <span class="hljs-keyword" >const</span> registry = {
    <span class="hljs-title function_" >register</span>(<span class="hljs-params" >name, componentClass</span>) {
      nameToClass.<span class="hljs-title function_" >set</span>(name, componentClass);
    },
    <span class="hljs-title function_" >getInstance</span>(<span class="hljs-params" >name</span>) {
      <span class="hljs-keyword" >if</span> (nameToInstance.<span class="hljs-title function_" >has</span>(name)) {
        <span class="hljs-keyword" >return</span> nameToInstance.<span class="hljs-title function_" >get</span>(name);
      }
      <span class="hljs-keyword" >const</span> componentClass = nameToClass.<span class="hljs-title function_" >get</span>(name);
      <span class="hljs-keyword" >if</span> (componentClass === <span class="hljs-literal" >undefined</span>) {
        <span class="hljs-keyword" >throw</span> <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Error</span>(<span class="hljs-string" >'Unknown component name: '</span> + name);
      }
      <span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >componentClass</span>();
      nameToInstance.<span class="hljs-title function_" >set</span>(name, inst);
      <span class="hljs-keyword" >return</span> inst;
    },
  }; 
  <span class="hljs-keyword" >function</span> <span class="hljs-title function_" >inject</span> (<span class="hljs-params" >_value, {kind, name}</span>) {
    <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'field'</span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-function" >() =&gt;</span> registry.<span class="hljs-title function_" >getInstance</span>(name);
    }
  }
  <span class="hljs-keyword" >return</span> {registry, inject};
}
</code></pre>
      <h3 id="example-friend-visibility" tabindex="-1">示例：“友元”可见性（实例私有字段）&nbsp;&nbsp;<a class="heading-anchor" href="#example-friend-visibility" aria-hidden="true">#</a></h3>
      <p>我们可以通过将某些类成员设为私有来改变其可见性，从而防止它们被公开访问。不过，还有更多有用的可见性类型。例如，<em>友元可见性</em>允许一组<em>友元</em>（函数、其他类等）访问该成员。</p>
      <p>有多种方式可以指定友元。在以下示例中，所有能访问<code>friendName</code>的对象都是<code>classWithSecret.#name</code>的友元。其核心思想是：一个模块中包含相互协作的类和函数，而某些实例数据应该仅对这些协作者可见。</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >const</span> friendName = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Friend</span>();

<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >ClassWithSecret</span> {
  @friendName.<span class="hljs-property" >install</span> #name = <span class="hljs-string" >'Rumpelstiltskin'</span>;
  <span class="hljs-title function_" >getName</span>(<span class="hljs-params" ></span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-variable language_" >this</span>.#name;
  }
}

<span class="hljs-comment" >// 能访问 `secret`的，也能访问 inst.#name</span>
<span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >ClassWithSecret</span>();
assert.<span class="hljs-title function_" >equal</span>(
  friendName.<span class="hljs-title function_" >get</span>(inst), <span class="hljs-string" >'Rumpelstiltskin'</span>
);
friendName.<span class="hljs-title function_" >set</span>(inst, <span class="hljs-string" >'Joe'</span>);
assert.<span class="hljs-title function_" >equal</span>(
  inst.<span class="hljs-title function_" >getName</span>(), <span class="hljs-string" >'Joe'</span>
);
</code></pre>
      <p>这是<code>Friend</code>类实装的过程：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Friend</span> {
  #access = <span class="hljs-literal" >undefined</span>;
  #<span class="hljs-title function_" >getAccessOrThrow</span>(<span class="hljs-params" ></span>) {
    <span class="hljs-keyword" >if</span> (<span class="hljs-variable language_" >this</span>.#access === <span class="hljs-literal" >undefined</span>) {
      <span class="hljs-keyword" >throw</span> <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Error</span>(<span class="hljs-string" >'The friend decorator wasn’t used yet'</span>);
    }
    <span class="hljs-keyword" >return</span> <span class="hljs-variable language_" >this</span>.#access;
  }
  <span class="hljs-comment" >// 一个`this`已经被绑定好了的类属性（绑定到了这个实例上）</span>
  install = <span class="hljs-function" >(<span class="hljs-params" >_value, {kind, access}</span>) =&gt;</span> {
    <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'field'</span>) {
      <span class="hljs-keyword" >if</span> (<span class="hljs-variable language_" >this</span>.#access) {
        <span class="hljs-keyword" >throw</span> <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Error</span>(<span class="hljs-string" >'This decorator can only be used once'</span>);
      }
      <span class="hljs-variable language_" >this</span>.#access = access;
    }
  }
  <span class="hljs-title function_" >get</span>(<span class="hljs-params" >inst</span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-variable language_" >this</span>.#<span class="hljs-title function_" >getAccessOrThrow</span>().<span class="hljs-property" >get</span>.<span class="hljs-title function_" >call</span>(inst);
  }
  <span class="hljs-title function_" >set</span>(<span class="hljs-params" >inst, value</span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-variable language_" >this</span>.#<span class="hljs-title function_" >getAccessOrThrow</span>().<span class="hljs-property" >set</span>.<span class="hljs-title function_" >call</span>(inst, value);
  }
}
</code></pre>
      <h3 id="example%3A-enums-(static-public-fields)" tabindex="-1">示例：枚举（静态公有字段）&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-enums-(static-public-fields)" aria-hidden="true">#</a></h3>
      <p>实现枚举的方式有很多种。一种面向对象风格的实现方式是使用类和静态属性（<a href="https://2ality.com/2016/01/enumify.html">关于此方法的更多信息</a>）：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Color</span> {
  <span class="hljs-keyword" >static</span> red = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>(<span class="hljs-string" >'red'</span>);
  <span class="hljs-keyword" >static</span> green = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>(<span class="hljs-string" >'green'</span>);
  <span class="hljs-keyword" >static</span> blue = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>(<span class="hljs-string" >'blue'</span>);
  <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >enumKey</span>) {
    <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >enumKey</span> = enumKey;
  }
  <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-string" >`Color(<span class="hljs-subst" >${<span class="hljs-variable language_" >this</span>.enumKey}</span>)`</span>;
  }
}
assert.<span class="hljs-title function_" >equal</span>(
  <span class="hljs-title class_" >Color</span>.<span class="hljs-property" >green</span>.<span class="hljs-title function_" >toString</span>(),
  <span class="hljs-string" >'Color(green)'</span>
);
</code></pre>
      <p>我们可以使用装饰器自动实现以下功能：</p>
      <ul>
        <li>创建一个从"枚举键"（字段名称）到枚举值的映射(Map)</li>
        <li>将枚举键添加到枚举值中 - 无需通过构造函数传递</li>
      </ul>
      <p>实现方式如下所示：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >enumEntry</span>(<span class="hljs-params" >value, {kind, name}</span>) {
  <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'field'</span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" >initialValue</span>) {
      <span class="hljs-keyword" >if</span> (!<span class="hljs-title class_" >Object</span>.<span class="hljs-title function_" >hasOwn</span>(<span class="hljs-variable language_" >this</span>, <span class="hljs-string" >'enumFields'</span>)) {
        <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >enumFields</span> = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Map</span>();
      }
      <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >enumFields</span>.<span class="hljs-title function_" >set</span>(name, initialValue);
      initialValue.<span class="hljs-property" >enumKey</span> = name;
      <span class="hljs-keyword" >return</span> initialValue;
    };
  }
}

<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Color</span> {
  @enumEntry <span class="hljs-keyword" >static</span> red = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>();
  @enumEntry <span class="hljs-keyword" >static</span> green = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>();
  @enumEntry <span class="hljs-keyword" >static</span> blue = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>();
  <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-string" >`Color(<span class="hljs-subst" >${<span class="hljs-variable language_" >this</span>.enumKey}</span>)`</span>;
  }
}
assert.<span class="hljs-title function_" >equal</span>(
  <span class="hljs-title class_" >Color</span>.<span class="hljs-property" >green</span>.<span class="hljs-title function_" >toString</span>(),
  <span class="hljs-string" >'Color(green)'</span>
);
assert.<span class="hljs-title function_" >deepEqual</span>(
  <span class="hljs-title class_" >Color</span>.<span class="hljs-property" >enumFields</span>,
  <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Map</span>([
    [<span class="hljs-string" >'red'</span>, <span class="hljs-title class_" >Color</span>.<span class="hljs-property" >red</span>],
    [<span class="hljs-string" >'green'</span>, <span class="hljs-title class_" >Color</span>.<span class="hljs-property" >green</span>],
    [<span class="hljs-string" >'blue'</span>, <span class="hljs-title class_" >Color</span>.<span class="hljs-property" >blue</span>],
  ])
);
</code></pre>
      <h2 id="auto-accessors" tabindex="-1">自动访问器：类定义的新成员&nbsp;&nbsp;<a class="heading-anchor" href="#auto-accessors" aria-hidden="true">#</a></h2>
      <p>装饰器提案引入了一项新的语言特性：<em>自动访问器(auto-accessors)</em>。通过在类字段前添加<code>accessor</code>关键字即可创建自动访问器。它使用起来像普通字段，但在运行时采用不同的实现方式。这将有助于装饰器的使用，我们稍后会看到。以下是自动访问器的示例：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
  <span class="hljs-keyword" >static</span> accessor myField1;
  <span class="hljs-keyword" >static</span> accessor #myField2;
  accessor myField3;
  accessor #myField4;
}
</code></pre>
      <p>字段和自动访问器有何区别？</p>
      <ul>
        <li>字段会创建以下两种结构之一：
          <ul>
            <li>属性（静态或实例）</li>
            <li>私有槽位（静态或实例）</li>
          </ul>
        </li>
        <li>自动访问器会为数据创建一个私有槽位（静态或实例），并同时创建：
          <ul>
            <li>公共的getter-setter对（静态或原型）</li>
            <li>私有的getter-setter对（静态或实例）
              <ul>
                <li>私有槽位不可继承，因此永远不会存在于原型中</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <p>请看以下类示例：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
  accessor str = <span class="hljs-string" >'abc'</span>;
}
<span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >C</span>();
assert.<span class="hljs-title function_" >equal</span>(
  inst.<span class="hljs-property" >str</span>, <span class="hljs-string" >'abc'</span>
);
inst.<span class="hljs-property" >str</span> = <span class="hljs-string" >'def'</span>;
assert.<span class="hljs-title function_" >equal</span>(
  inst.<span class="hljs-property" >str</span>, <span class="hljs-string" >'def'</span>
);
</code></pre>
      <p>其内部实现如下所示：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
  #str = <span class="hljs-string" >'abc'</span>;
  <span class="hljs-keyword" >get</span> <span class="hljs-title function_" >str</span>() {
    <span class="hljs-keyword" >return</span> <span class="hljs-variable language_" >this</span>.#str;
  }
  <span class="hljs-keyword" >set</span> <span class="hljs-title function_" >str</span>(<span class="hljs-params" >value</span>) {
    <span class="hljs-variable language_" >this</span>.#str = value;
  }
}
</code></pre>
      <p>以下代码展示了自动访问器的getter和setter所在的位置：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
  <span class="hljs-keyword" >static</span> accessor myField1;
  <span class="hljs-keyword" >static</span> accessor #myField2;
  accessor myField3;
  accessor #myField4;

  <span class="hljs-keyword" >static</span> {
    <span class="hljs-comment" >// 静态 getter 和 setter</span>
    assert.<span class="hljs-title function_" >ok</span>(
      <span class="hljs-title class_" >Object</span>.<span class="hljs-title function_" >hasOwn</span>(C, <span class="hljs-string" >'myField1'</span>), <span class="hljs-string" >'myField1'</span>
    );
    <span class="hljs-comment" >// 静态 getter 和 setter</span>
    assert.<span class="hljs-title function_" >ok</span>(
      #myField2 <span class="hljs-keyword" >in</span> C, <span class="hljs-string" >'#myField2'</span>
    );

    <span class="hljs-comment" >// Prototype getter 和 setter</span>
    assert.<span class="hljs-title function_" >ok</span>(
      <span class="hljs-title class_" >Object</span>.<span class="hljs-title function_" >hasOwn</span>(C.<span class="hljs-property" ><span class="hljs-keyword" >prototype</span></span>, <span class="hljs-string" >'myField3'</span>), <span class="hljs-string" >'myField3'</span>
    );
    <span class="hljs-comment" >// Private getter 和 setter</span>
    <span class="hljs-comment" >// （保存在实例上，但在各个实例之间共享）</span>
    assert.<span class="hljs-title function_" >ok</span>(
      #myField4 <span class="hljs-keyword" >in</span> <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >C</span>(), <span class="hljs-string" >'#myField4'</span>
    );
  }
}
</code></pre>
      <p>有关私有getter、私有setter和私有方法的槽位为何存储在实例中的更多信息，请参阅<a href="https://exploringjs.com/js/book/ch_classes.html#private-methods-accessors">《探索JavaScript》中的"私有方法和访问器"章节</a>。</p>
      <h3 id="why-are-auto-accessors-needed%3F" tabindex="-1">为什么需要自动访问器？&nbsp;&nbsp;<a class="heading-anchor" href="#why-are-auto-accessors-needed%3F" aria-hidden="true">#</a></h3>
      <p>自动访问器是装饰器所必需的：</p>
      <ul>
        <li>装饰器只能影响字段的初始值</li>
        <li>但可以完全替换自动访问器</li>
      </ul>
      <p>因此，当装饰器需要比字段更多的控制权时，我们必须使用自动访问器而非字段。</p>
      <h2 id="class-auto-accessor-decorators" tabindex="-1">类自动访问器装饰器（Class auto-accessor）&nbsp;&nbsp;<a class="heading-anchor" href="#class-auto-accessor-decorators" aria-hidden="true">#</a></h2>
      <p>类自动访问器装饰器具有以下类型签名：</p>
      <pre><code class="language-ts" ><span class="hljs-keyword" >type</span> <span class="hljs-title class_" >ClassAutoAccessorDecorator</span> = <span class="hljs-function" >(<span class="hljs-params" >
  <span class="hljs-attr" >value</span>: {
    get: () =&gt; <span class="hljs-built_in" >unknown</span>;
    set: (value: <span class="hljs-built_in" >unknown</span>) =&gt; <span class="hljs-built_in" >void</span>;
  },
  <span class="hljs-attr" >context</span>: {
    kind: <span class="hljs-string" >'accessor'</span>;
    name: <span class="hljs-built_in" >string</span> | <span class="hljs-built_in" >symbol</span>;
    <span class="hljs-keyword" >static</span>: <span class="hljs-built_in" >boolean</span>;
    <span class="hljs-keyword" >private</span>: <span class="hljs-built_in" >boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in" >unknown</span>, set: (value: <span class="hljs-built_in" >unknown</span>) =&gt; <span class="hljs-built_in" >void</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" >void</span>): <span class="hljs-built_in" >void</span>;
  }
</span>) =&gt;</span> {
  <span class="hljs-attr" >get</span>?: <span class="hljs-function" >() =&gt;</span> <span class="hljs-built_in" >unknown</span>;
  <span class="hljs-attr" >set</span>?: <span class="hljs-function" >(<span class="hljs-params" ><span class="hljs-attr" >value</span>: <span class="hljs-built_in" >unknown</span></span>) =&gt;</span> <span class="hljs-built_in" >void</span>;
  <span class="hljs-attr" >init</span>?: <span class="hljs-function" >(<span class="hljs-params" ><span class="hljs-attr" >initialValue</span>: <span class="hljs-built_in" >unknown</span></span>) =&gt;</span> <span class="hljs-built_in" >unknown</span>;
} | <span class="hljs-built_in" >void</span>;
</code></pre>
      <p>自动访问器装饰器的能力：</p>
      <ul>
        <li>通过参数<code>value</code>接收自动访问器的getter和setter
          <ul>
            <li><code>context.access</code>提供相同的功能</li>
          </ul>
        </li>
        <li>可以通过返回包含<code>.get()</code>和/或<code>.set()</code>方法的对象来替换被装饰的自动访问器</li>
        <li>可以通过返回包含<code>.init()</code>方法的对象来影响自动访问器的初始值</li>
        <li>可以注册初始化器</li>
      </ul>
      <h3 id="read-only-auto-accessors" tabindex="-1">示例：只读自动访问器&nbsp;&nbsp;<a class="heading-anchor" href="#read-only-auto-accessors" aria-hidden="true">#</a></h3>
      <p>我们已经实现了<a href="#read-only-fields">字段的装饰器<code>@readOnly</code></a>。现在为自动访问器实现同样的功能：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >const</span> <span class="hljs-variable constant_" >UNINITIALIZED</span> = <span class="hljs-title class_" >Symbol</span>(<span class="hljs-string" >'UNINITIALIZED'</span>);
<span class="hljs-keyword" >function</span> <span class="hljs-title function_" >readOnly</span>(<span class="hljs-params" >{get,set}, {name, kind}</span>) {
  <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'accessor'</span>) {
    <span class="hljs-keyword" >return</span> {
      <span class="hljs-title function_" >init</span>(<span class="hljs-params" ></span>) {
        <span class="hljs-keyword" >return</span> <span class="hljs-variable constant_" >UNINITIALIZED</span>;
      },
      <span class="hljs-title function_" >get</span>(<span class="hljs-params" ></span>) {
        <span class="hljs-keyword" >const</span> value = get.<span class="hljs-title function_" >call</span>(<span class="hljs-variable language_" >this</span>);
        <span class="hljs-keyword" >if</span> (value === <span class="hljs-variable constant_" >UNINITIALIZED</span>) {
          <span class="hljs-keyword" >throw</span> <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >TypeError</span>(
            <span class="hljs-string" >`Accessor <span class="hljs-subst" >${name}</span> hasn’t been initialized yet`</span>
          );
        }
        <span class="hljs-keyword" >return</span> value;
      },
      <span class="hljs-title function_" >set</span>(<span class="hljs-params" >newValue</span>) {
        <span class="hljs-keyword" >const</span> oldValue = get.<span class="hljs-title function_" >call</span>(<span class="hljs-variable language_" >this</span>);
        <span class="hljs-keyword" >if</span> (oldValue !== <span class="hljs-variable constant_" >UNINITIALIZED</span>) {
          <span class="hljs-keyword" >throw</span> <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >TypeError</span>(
            <span class="hljs-string" >`Accessor <span class="hljs-subst" >${name}</span> can only be set once`</span>
          );
        }
        set.<span class="hljs-title function_" >call</span>(<span class="hljs-variable language_" >this</span>, newValue);
      },
    };
  }
}

<span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Color</span> {
  @readOnly
  accessor name;
  <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >name</span>) {
    <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >name</span> = name;
  }
}

<span class="hljs-keyword" >const</span> blue = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>(<span class="hljs-string" >'blue'</span>);
assert.<span class="hljs-title function_" >equal</span>(blue.<span class="hljs-property" >name</span>, <span class="hljs-string" >'blue'</span>);
assert.<span class="hljs-title function_" >throws</span>(
  <span class="hljs-function" >() =&gt;</span> blue.<span class="hljs-property" >name</span> = <span class="hljs-string" >'yellow'</span>,
  <span class="hljs-regexp" >/^TypeError: Accessor name can only be set once$/</span>
);

<span class="hljs-keyword" >const</span> orange = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>(<span class="hljs-string" >'orange'</span>);
assert.<span class="hljs-title function_" >equal</span>(orange.<span class="hljs-property" >name</span>, <span class="hljs-string" >'orange'</span>);
</code></pre>
      <p>与字段版本相比，此装饰器有一个显著的优点：它不需要包装类即可确保被装饰的结构变为只读。</p>
      <h2 id="faq" tabindex="-1">常见问题&nbsp;&nbsp;<a class="heading-anchor" href="#faq" aria-hidden="true">#</a></h2>
      <h3 id="function-decorators" tabindex="-1">为什么函数不能被装饰？&nbsp;&nbsp;<a class="heading-anchor" href="#function-decorators" aria-hidden="true">#</a></h3>
      <p>当前提案是以“类”为出发点的。<a href="#more-decorator-related-proposals">函数表达式的装饰器提案已经提出。</a> 然而，自那以后进展不大，并且尚未有函数 <em>声明</em> 的提案。</p>
      <p>另一方面，装饰函数相对简单：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >const</span> decoratedFunc = <span class="hljs-title function_" >decorator</span>(<span class="hljs-function" >(<span class="hljs-params" >x, y</span>) =&gt;</span> {});
</code></pre>
      <p>甚至 <a href="https://2ality.com/2022/01/pipe-operator.html">管道运算符提案</a>看起来更好：</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >const</span> <span class="hljs-title function_" >decoratedFunc</span> = (<span class="hljs-params" >x, y</span>) =&gt; {} |&gt; <span class="hljs-title function_" >decorator</span>(%);
</code></pre>
      <h2 id="more-decorator-related-proposals" tabindex="-1">More decorator-related proposals&nbsp;&nbsp;<a class="heading-anchor" href="#more-decorator-related-proposals" aria-hidden="true">#</a></h2>
      <p>以下这些ECMAScript提案，提供了更多装饰器相关的特性：</p>
      <ul>
        <li>Stage 2: <a href="https://github.com/tc39/proposal-decorator-metadata">“Decorator Metadata”</a> by Chris Garrett (last update: 2022-04-11)
          <ul>
            <li>Quote: “This proposal seeks to extend the Decorators proposal by adding the ability for decorators to associate metadata with the value being decorated.”</li>
          </ul>
        </li>
        <li>Stage 0: <a href="https://docs.google.com/document/d/1ikxIP5-RVYq6d_f8lAvf3pKC00W78ueyp-xIZ6q67uU">“Function Expression Decorators”</a> by Igor Minar (last update: 2016-01-25)</li>
        <li>Stage 0: <a href="https://docs.google.com/document/d/1Qpkqf_8NzAwfD8LdnqPjXAQ2wwh8BBUGynhn-ZlCWT0">“Method Parameter Decorators”</a> by Igor Minar (last update: 2016-01-25)</li>
      </ul>
      <h2 id="resources" tabindex="-1">资源&nbsp;&nbsp;<a class="heading-anchor" href="#resources" aria-hidden="true">#</a></h2>
      <h3 id="decorator-implementations" tabindex="-1">实现&nbsp;&nbsp;<a class="heading-anchor" href="#decorator-implementations" aria-hidden="true">#</a></h3>
      <ul>
        <li>Babel 目前通过 <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators"><code>@babel/plugin-proposal-decorators</code></a> 对第 3 阶段装饰器提供了最佳支持。
          <ul>
            <li>确保选择 <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators#version">最新的装饰器版本</a>。</li>
            <li>本文中所有代码均通过 Babel 开发。</li>
          </ul>
        </li>
        <li>TypeScript 目前在一个标志后面支持第 1 阶段装饰器。
          <ul>
            <li>有 <a href="https://github.com/microsoft/TypeScript/pull/50820">Ron Buckton 的一个 PR</a> 支持第 3 阶段装饰器，并可能在 TypeScript 4.9 之后的版本中发布。</li>
          </ul>
        </li>
      </ul>
      <h3 id="libraries-with-decorators" tabindex="-1">带装饰器的库&nbsp;&nbsp;<a class="heading-anchor" href="#libraries-with-decorators" aria-hidden="true">#</a></h3>
      <p>这些是带装饰器的库。目前它们仅支持第 1 阶段装饰器，但可以作为可能性的灵感：</p>
      <ul>
        <li><a href="https://github.com/jayphelps/core-decorators.js">core-decorators.js</a> by Jay Phelps (targets Babel)</li>
        <li><a href="https://github.com/NetanelBasal/helpful-decorators">“Helpful Decorators For TypeScript Projects”</a> by Netanel Basal</li>
      </ul>
      <h2 id="acknowledgements" tabindex="-1">致谢&nbsp;&nbsp;<a class="heading-anchor" href="#acknowledgements" aria-hidden="true">#</a></h2>
      <ul>
        <li>感谢 Chris Garrett 解答我关于装饰器的问题。</li>
      </ul>
      <h2 id="further-reading" tabindex="-1">延伸阅读&nbsp;&nbsp;<a class="heading-anchor" href="#further-reading" aria-hidden="true">#</a></h2>
      <ul>
        <li>
          <p><a href="https://exploringjs.com/js/book/ch_callables.html">章节：Callables</a> [普通函数、箭头函数、类、方法] 在《探索 JavaScript》中</p>
        </li>
        <li>
          <p><a href="https://exploringjs.com/js/book/ch_classes.html">章节：Classes</a> 在《探索 JavaScript》中</p>
        </li>
      </ul>
    </div>
  </div>
  <div id="page-core-content2" class="number-headings">
    <h1>JavaScript metaprogramming with the 2022-03 decorators API</h1>
    <div>
      <p>JavaScript decorators have finally reached <a href="https://exploringjs.com/js/book/ch_history.html#tc39-process">stage 3</a>! Their latest version is already supported by Babel and <a href="#decorator-implementations">will soon be supported by TypeScript</a>.</p>
      <p>This blog post covers the 2022-03 version (stage 3) of the ECMAScript proposal <a href="https://github.com/tc39/proposal-decorators">“Decorators”</a> by Daniel Ehrenberg and Chris Garrett.</p>
      <p>A decorator is a keyword that starts with an <code>@</code> symbol and can be put in front of classes and class members (such as methods). For example, <code>@trace</code> is a decorator:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
    @trace
    <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-string" >'C'</span>;
    }
  }
  </code>
  </pre>
      <p>A decorator changes how the decorated construct works. In this case, every invocation of <code>.toString()</code> will be “traced” (arguments and result will be logged to the console). <a href="#example-tracing-method-invocations">We’ll see how <code>@trace</code> is implemented later.</a></p>
      <!--more-->
      <p>Decorators are mostly an object-oriented feature and popular in OOP frameworks and libraries such as Ember, Angular, Vue, web component frameworks and MobX.</p>
      <p>There are two stakeholders when it comes to decorators:</p>
      <ul>
        <li>Library authors have to know their API so that they can implement them.</li>
        <li>Library users only have to know how to apply them.</li>
      </ul>
      <p>This blog post is intended for library authors: We’ll learn how decorators work and use our knowledge to implement several of them.</p>
      <nav class="table-of-contents">
        <ul>
          <li>
            <a href="#history-of-decorators">The history of decorators (optional section)</a>
            <ul>
              <li>
                <a href="#the-history-of-decorators">The history of decorators</a>
              </li>
              <li>
                <a href="#the-history-of-babel%E2%80%99s-decorator-implementation">The history of Babel’s decorator implementation</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#what-are-decorators%3F">What are decorators?</a>
            <ul>
              <li>
                <a href="#the-shape-of-decorator-functions">The shape of decorator functions</a>
              </li>
              <li>
                <a href="#what-can-decorators-do%3F">What can decorators do?</a>
              </li>
              <li>
                <a href="#summary-tables">Summary tables</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)">More information on the syntax and semantics of decorators (optional section)</a>
            <ul>
              <li>
                <a href="#the-syntax-of-decorator-expressions">The syntax of decorator expressions</a>
              </li>
              <li>
                <a href="#how-are-decorators-executed%3F">How are decorators executed?</a>
              </li>
              <li>
                <a href="#decorator-initializer-execution">When do decorator initializers run?</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#techniques-for-exposing-data-from-decorators">Techniques for exposing data from decorators</a>
            <ul>
              <li>
                <a href="#storing-exposed-data-in-a-surrounding-scope">Storing exposed data in a surrounding scope</a>
              </li>
              <li>
                <a href="#managing-exposed-data-via-a-factory-function">Managing exposed data via a factory function</a>
              </li>
              <li>
                <a href="#managing-exposed-data-via-a-class">Managing exposed data via a class</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#class-decorators">Class decorators</a>
            <ul>
              <li>
                <a href="#example%3A-collecting-instances">Example: collecting instances</a>
              </li>
              <li>
                <a href="#making-sure-that-instanceof-works">Making sure that <code>instanceof</code> works</a>
              </li>
              <li>
                <a href="#example-freezing-instances">Example: freezing instances</a>
              </li>
              <li>
                <a href="#example%3A-making-classes-function-callable">Example: making classes function-callable</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#class-method-decorators">Class method decorators</a>
            <ul>
              <li>
                <a href="#example-tracing-method-invocations">Example: tracing method invocations</a>
              </li>
              <li>
                <a href="#example%3A-binding-methods-to-instances">Example: binding methods to instances</a>
              </li>
              <li>
                <a href="#example%3A-applying-functions-to-methods">Example: applying functions to methods</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#class-getter-decorators%2C-class-setter-decorators">Class getter decorators, class setter decorators</a>
            <ul>
              <li>
                <a href="#example%3A-computing-values-lazily">Example: computing values lazily</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#class-field-decorators">Class field decorators</a>
            <ul>
              <li>
                <a href="#example%3A-changing-initialization-values-of-fields">Example: changing initialization values of fields</a>
              </li>
              <li>
                <a href="#read-only-fields">Example: read-only fields (instance public fields)</a>
              </li>
              <li>
                <a href="#example%3A-dependency-injection-(instance-public-fields)">Example: dependency injection (instance public fields)</a>
              </li>
              <li>
                <a href="#example-friend-visibility">Example: “friend”&nbsp;visibility (instance private fields)</a>
              </li>
              <li>
                <a href="#example%3A-enums-(static-public-fields)">Example: enums (static public fields)</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#auto-accessors">Auto-accessors: a new member of class definitions</a>
            <ul>
              <li>
                <a href="#why-are-auto-accessors-needed%3F">Why are auto-accessors needed?</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#class-auto-accessor-decorators">Class auto-accessor decorators</a>
            <ul>
              <li>
                <a href="#read-only-auto-accessors">Example: read-only auto-accessors</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#faq">Frequently asked questions</a>
            <ul>
              <li>
                <a href="#function-decorators">Why can’t functions be decorated?</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#more-decorator-related-proposals">More decorator-related proposals</a>
          </li>
          <li>
            <a href="#resources">Resources</a>
            <ul>
              <li>
                <a href="#decorator-implementations">Implementations</a>
              </li>
              <li>
                <a href="#libraries-with-decorators">Libraries with decorators</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#acknowledgements">Acknowledgements</a>
          </li>
          <li>
            <a href="#further-reading">Further reading</a>
          </li>
        </ul>
      </nav>
      <h2 id="history-of-decorators" tabindex="-1">The history of decorators (optional section)&nbsp;&nbsp;<a class="heading-anchor" href="#history-of-decorators" aria-hidden="true">#</a></h2>
      <p>(This section is optional. If you skip it, you can still understand the remaining content.)</p>
      <p>Let’s start by looking at the history of decorators. Among others, two questions will be answered:</p>
      <ul>
        <li>Why is this proposal taking so long?</li>
        <li>Why does it feel like JavaScript has already had decorators for years?</li>
      </ul>
      <h3 id="the-history-of-decorators" tabindex="-1">The history of decorators&nbsp;&nbsp;<a class="heading-anchor" href="#the-history-of-decorators" aria-hidden="true">#</a></h3>
      <p>The following history describes:</p>
      <ul>
        <li>How various groups both worked on their own projects and collaborated on the TC39 proposal.</li>
        <li>How the TC39 proposal advanced through the stages of <a href="https://exploringjs.com/js/book/ch_history.html#tc39-process">the TC39 process</a> (which start at 0 and end at 4, when the proposal is ready to be added to ECMAScript). Along the way, the proposal changed in numerous ways.</li>
      </ul>
      <p>This is a chronological account of relevant events:</p>
      <ul>
        <li>
          <p><a href="https://github.com/tc39/notes/blob/main/meetings/2014-04/apr-10.md">2014-04-10</a>: Decorators were proposed to TC39 by Yehuda Katz. The proposal advanced to stage 0.</p>
          <ul>
            <li>Katz’s proposal was created in collaboration with Ron Buckton. Discussions about that proposal date back as far as <a href="https://twitter.com/rbuckton/status/1581292852532813825">July 2013</a>.</li>
          </ul>
        </li>
        <li>
          <p>2014-10-22 (ngEurope conference, Paris): The Angular team announced that Angular 2.0 was being written in AtScript and compiled to JavaScript (via Traceur) and Dart. Plans included basing AtScript on TypeScript while adding:</p>
          <ul>
            <li>Three kinds of <em>annotations</em>:
              <ul>
                <li><em>Type annotations</em></li>
                <li><em>Field annotations</em> explicitly declare fields.</li>
                <li><em>Metadata annotations</em> have the same syntax as decorators but only add metadata and don’t change how annotated constructs work.</li>
              </ul>
            </li>
            <li>Runtime type checking</li>
            <li>Type introspection</li>
          </ul>
        </li>
        <li>
          <p><a href="https://github.com/tc39/notes/blob/main/meetings/2015-01/jan-28.md">2015-01-28</a>: Yehuda Katz and Jonathan Turner reported that Katz and the TypeScript team were exchanging ideas.</p>
        </li>
        <li>
          <p>2015-03-05 (ng-conf, Salt Lake City): The Angular team and the TypeScript team announced that Angular would switch from AtScript to TypeScript and that TypeScript would adopt some of AtScript’s features (especially decorators).</p>
        </li>
        <li>
          <p><a href="https://github.com/tc39/notes/blob/main/meetings/2015-03/mar-24.md">2015-03-24</a>: The decorator proposal reached stage 1. At that time, they had <a href="https://github.com/wycats/javascript-decorators">a repository on GitHub</a> (created by Yehuda Katz) that was later moved to <a href="https://github.com/tc39/proposal-decorators">its current location</a>.</p>
        </li>
        <li>
          <p>2015-07-20: <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-1-5/">TypeScript 1.5</a> came out and supported <a href="https://www.typescriptlang.org/docs/handbook/decorators.html">stage 1 decorators</a> behind the flag <code>--experimentalDecorators</code>.</p>
          <p>Several JavaScript projects (e.g. Angular and MobX) used this TypeScript feature which made it look like JavaScript already had decorators.</p>
          <p>So far, TypeScript has not supported a newer version of the decorators API. <a href="https://github.com/microsoft/TypeScript/pull/50820">A pull request by Ron Buckton provides support for stage 3 decorators</a> and will likely ship in the release after v4.9.</p>
        </li>
        <li>
          <p><a href="https://github.com/tc39/notes/blob/main/meetings/2016-07/jul-28.md">2016-07-28</a>: The proposal reached stage 2, after a presentation by Yehuda Katz and Brian Terlson.</p>
        </li>
        <li>
          <p><a href="https://github.com/tc39/notes/blob/main/meetings/2017-07/jul-27.md">2017-07-27</a>: Daniel Ehrenberg held his first decorator presentation, after joining the proposal a few months earlier. He drove its evolution for several years.</p>
        </li>
        <li>
          <p>Later, Chris Garrett joined the proposal and helped get it to stage 3, which happened <a href="https://github.com/tc39/notes/blob/main/meetings/2022-03/mar-28.md">on 2022-03-28</a>. Decorator metadata was moved to <a href="https://github.com/tc39/proposal-decorator-metadata">a separate proposal</a> that started at stage 2.</p>
        </li>
      </ul>
      <p>It took a long time to reach stage 3 because it was difficult to get all stakeholders to agree on an API. Concerns included interactions with other features (such as class members and private state) and performance.</p>
      <h3 id="the-history-of-babel%E2%80%99s-decorator-implementation" tabindex="-1">The history of Babel’s decorator implementation&nbsp;&nbsp;<a class="heading-anchor" href="#the-history-of-babel%E2%80%99s-decorator-implementation" aria-hidden="true">#</a></h3>
      <p>Babel closely tracked the evolution of the decorator proposal, thanks to the efforts of Logan Smyth, Nicolò Ribaudo and others:</p>
      <ul>
        <li>
          <p><a href="https://babeljs.io/blog/2015/03/31/5.0.0">2015-03-31</a>: Babel 5.0.0 supported stage 1 decorators.</p>
        </li>
        <li>
          <p><a href="https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy">2015-11-29</a> An external plugin by Logan Smyth brought support for stage 1 decorators to Babel 6.</p>
        </li>
        <li>
          <p><a href="https://babeljs.io/blog/2018/08/27/7.0.0">2018-08-27</a> Babel 7.0.0 supported stage 2 decorators via the official <code>@babel/plugin-proposal-decorators</code>.</p>
        </li>
        <li>
          <p>The official plugin currently supports <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators#version">the following versions</a>:</p>
          <ul>
            <li><code>"legacy"</code>: <a href="https://github.com/wycats/javascript-decorators/blob/e1bf8d41bfa2591d949dd3bbf013514c8904b913/README.md">stage 1 decorators</a></li>
            <li><code>"2018-09"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/7fa580b40f2c19c561511ea2c978e307ae689a1b">stage 2 decorators</a></li>
            <li><code>"2021-12"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/d6c056fa061646178c34f361bad33d583316dc85">an updated version of the original stage 2 decorators</a></li>
            <li><code>"2022-03"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/8ca65c046dd5e9aa3846a1fe5df343a6f7efd9f8">stage 3 decorators</a></li>
          </ul>
        </li>
      </ul>
      <h2 id="what-are-decorators%3F" tabindex="-1">What are decorators?&nbsp;&nbsp;<a class="heading-anchor" href="#what-are-decorators%3F" aria-hidden="true">#</a></h2>
      <p>Decorators let us change how JavaScript constructs (such as classes and methods) work. Let’s revisit our previous example with the decorator <code>@trace</code>:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
    @trace
    <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-string" >'C'</span>;
    }
  }
  </code></pre>
      <p>To implement <code>@trace</code>, we only have to write a function (<a href="#example-tracing-method-invocations">the exact implementation will be shown later</a>):</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >trace</span>(<span class="hljs-params" >decoratedMethod</span>) {
    <span class="hljs-comment" >// Returns a function that replaces `decoratedMethod`.</span>
  }
  </code></pre>
      <p>The class with the decorated method is roughly equivalent to the following code:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
    <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-string" >'C'</span>;
    }
  }
  C.<span class="hljs-property" ><span class="hljs-keyword" >prototype</span></span>.<span class="hljs-property" >toString</span> = <span class="hljs-title function_" >trace</span>(C.<span class="hljs-property" ><span class="hljs-keyword" >prototype</span></span>.<span class="hljs-property" >toString</span>);
  </code></pre>
      <p>In other words: A decorator is a function that we can apply to language constructs. We do so by putting <code>@</code> plus its name in front of them.</p>
      <p>Writing and using decorators is <em>metaprogramming</em>:</p>
      <ul>
        <li>We don’t write code that processes user data (<em>programming</em>).</li>
        <li>We write code that processes code that processes user data (<em>metaprogramming</em>).</li>
      </ul>
      <p>For more information on metaprogramming, see <a href="https://exploringjs.com/deep-js/ch_proxies.html#programming-vs-metaprogramming">section “Programming versus metaprogramming”</a> in “Deep JavaScript”.</p>
      <h3 id="the-shape-of-decorator-functions" tabindex="-1">The shape of decorator functions&nbsp;&nbsp;<a class="heading-anchor" href="#the-shape-of-decorator-functions" aria-hidden="true">#</a></h3>
      <p>Before we explore examples of decorator functions, I’d like to take a look at their TypeScript type signature:</p>
      <pre><code class="language-ts" ><span class="hljs-keyword" >type</span> <span class="hljs-title class_" >Decorator</span> = <span class="hljs-function" >(<span class="hljs-params" >
    <span class="hljs-attr" >value</span>: <span class="hljs-title class_" >DecoratedValue</span>, <span class="hljs-comment" >// only fields differ</span>
    <span class="hljs-attr" >context</span>: {
      kind: <span class="hljs-built_in" >string</span>;
      name: <span class="hljs-built_in" >string</span> | <span class="hljs-built_in" >symbol</span>;
      addInitializer(initializer: () =&gt; <span class="hljs-built_in" >void</span>): <span class="hljs-built_in" >void</span>;
  
      // Don’t always exist:
      <span class="hljs-keyword" >static</span>: <span class="hljs-built_in" >boolean</span>;
      <span class="hljs-keyword" >private</span>: <span class="hljs-built_in" >boolean</span>;
      access: {get: () =&gt; <span class="hljs-built_in" >unknown</span>, set: (value: <span class="hljs-built_in" >unknown</span>) =&gt; <span class="hljs-built_in" >void</span>};
    }
  </span>) =&gt;</span> <span class="hljs-built_in" >void</span> | <span class="hljs-title class_" >ReplacementValue</span>; <span class="hljs-comment" >// only fields differ</span>
  </code></pre>
      <p>That is, a decorator is a function. Its parameters are:</p>
      <ul>
        <li>The <code>value</code> that the decorator is applied to.</li>
        <li>The object <code>context</code> with:
          <ul>
            <li>Additional information on <code>value</code> (<code>.static</code>, <code>.private</code>)</li>
            <li>A small API (<code>.access</code>, <code>.addInitializer</code>) with metaprogramming functionality</li>
          </ul>
        </li>
      </ul>
      <p>Property <code>.kind</code> tells the decorator which kind of JavaScript construct it is applied to. We can use the same function for multiple constructs.</p>
      <p>Currently, decorators can be applied to classes, methods, getters, setters, fields, and <em>auto-accessors</em> (a new class member that is explained <a href="#auto-accessors">later</a>). The values of <code>.kind</code> reflect that:</p>
      <ul>
        <li><code>'class'</code></li>
        <li><code>'method'</code></li>
        <li><code>'getter'</code></li>
        <li><code>'setter'</code></li>
        <li><code>'accessor'</code></li>
        <li><code>'field'</code></li>
      </ul>
      <p>This is the exact type of <code>Decorator</code>:</p>
      <pre><code class="language-ts" ><span class="hljs-keyword" >type</span> <span class="hljs-title class_" >Decorator</span> =
    | <span class="hljs-title class_" >ClassDecorator</span>
    | <span class="hljs-title class_" >ClassMethodDecorator</span>
    | <span class="hljs-title class_" >ClassGetterDecorator</span>
    | <span class="hljs-title class_" >ClassSetterDecorator</span>
    | <span class="hljs-title class_" >ClassAutoAccessorDecorator</span>
    | <span class="hljs-title class_" >ClassFieldDecorator</span>
  ;
  </code></pre>
      <p>We’ll soon encounter each of these kinds of decorators and its type signature – where only these parts change:</p>
      <ul>
        <li>The type of <code>value</code></li>
        <li>Some of the properties of <code>context</code></li>
        <li>The return type</li>
      </ul>
      <h3 id="what-can-decorators-do%3F" tabindex="-1">What can decorators do?&nbsp;&nbsp;<a class="heading-anchor" href="#what-can-decorators-do%3F" aria-hidden="true">#</a></h3>
      <p>Each decorator has up to four abilities:</p>
      <ul>
        <li>
          <p>It can change the decorated entity by changing the parameter <code>value</code>.</p>
        </li>
        <li>
          <p>It can replace the decorated entity by returning a compatible value:</p>
          <ul>
            <li>“Compatible”&nbsp;means that the returned value must have the same type as the decorated value – e.g., class decorators must return callable values.</li>
            <li>If the decorator doesn’t want to replace the decorated value, it can return <code>undefined</code> – either explicitly or implicitly, by not returning anything.</li>
          </ul>
        </li>
        <li>
          <p>Exposing access to the decorated entity to others. <code>context.access</code> enables it to do that, via its methods <code>.get()</code> and <code>.set()</code>.</p>
        </li>
        <li>
          <p>Processing the decorated entity and its container (if it has one), after both exist: That functionality is provided by <code>context.addInitializer</code>. It lets the decorator register an <em>initializer</em> – a callback that is invoked when everything is ready (more details are explained <a href="#decorator-initializer-execution">later</a>).</p>
        </li>
      </ul>
      <p>The next subsections demonstrate these abilities. We initially won’t use <code>context.kind</code> to check which kind of construct a decorator is applied to. We will do that later, though.</p>
      <h4 id="ability%3A-replacing-the-decorated-entity" tabindex="-1">Ability: replacing the decorated entity&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-replacing-the-decorated-entity" aria-hidden="true">#</a></h4>
      <p>In the following example, the decorator <code>@replaceMethod</code> replaces method <code>.hello()</code> (line B) with a function that it returns (line A).</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >replaceMethod</span>(<span class="hljs-params" ></span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" ></span>) { <span class="hljs-comment" >// (A)</span>
      <span class="hljs-keyword" >return</span> <span class="hljs-string" >`How are you, <span class="hljs-subst" >${<span class="hljs-variable language_" >this</span>.name}</span>?`</span>;
    }
  }
  
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Person</span> {
    <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >name</span>) {
      <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >name</span> = name;
    }
    @replaceMethod
    <span class="hljs-title function_" >hello</span>(<span class="hljs-params" ></span>) { <span class="hljs-comment" >// (B)</span>
      <span class="hljs-keyword" >return</span> <span class="hljs-string" >`Hi <span class="hljs-subst" >${<span class="hljs-variable language_" >this</span>.name}</span>!`</span>;
    }
  }
  
  <span class="hljs-keyword" >const</span> robin = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Person</span>(<span class="hljs-string" >'Robin'</span>);
  assert.<span class="hljs-title function_" >equal</span>(
    robin.<span class="hljs-title function_" >hello</span>(), <span class="hljs-string" >'How are you, Robin?'</span>
  );
  </code></pre>
      <h4 id="ability%3A-exposing-access-to-the-decorated-entity-to-others" tabindex="-1">Ability: exposing access to the decorated entity to others&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-exposing-access-to-the-decorated-entity-to-others" aria-hidden="true">#</a></h4>
      <p>In the next example, the decorator <code>@exposeAccess</code> stores an object in the variable <code>acc</code> that lets us access property <code>.green</code> of the instances of <code>Color</code>.</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >let</span> acc;
  <span class="hljs-keyword" >function</span> <span class="hljs-title function_" >exposeAccess</span>(<span class="hljs-params" >_value, {access}</span>) {
    acc = access;
  }
  
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Color</span> {
    @exposeAccess
    name = <span class="hljs-string" >'green'</span>
  }
  
  <span class="hljs-keyword" >const</span> green = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>();
  assert.<span class="hljs-title function_" >equal</span>(
    green.<span class="hljs-property" >name</span>, <span class="hljs-string" >'green'</span>
  );
  <span class="hljs-comment" >// Using `acc` to get and set `green.name`</span>
  assert.<span class="hljs-title function_" >equal</span>(
    acc.<span class="hljs-property" >get</span>.<span class="hljs-title function_" >call</span>(green), <span class="hljs-string" >'green'</span>
  );
  acc.<span class="hljs-property" >set</span>.<span class="hljs-title function_" >call</span>(green, <span class="hljs-string" >'red'</span>);
  assert.<span class="hljs-title function_" >equal</span>(
    green.<span class="hljs-property" >name</span>, <span class="hljs-string" >'red'</span>
  );
  </code></pre>
      <h4 id="ability%3A-processing-the-decorated-entity-and-its-container" tabindex="-1">Ability: processing the decorated entity and its container&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-processing-the-decorated-entity-and-its-container" aria-hidden="true">#</a></h4>
      <p>In the following code, we use the decorator <code>@collect</code> to store the keys of decorated methods in the instance property <code>.collectedMethodKeys</code>:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >collect</span>(<span class="hljs-params" >_value, {name, addInitializer}</span>) {
    <span class="hljs-title function_" >addInitializer</span>(<span class="hljs-keyword" >function</span> (<span class="hljs-params" ></span>) { <span class="hljs-comment" >// (A)</span>
      <span class="hljs-keyword" >if</span> (!<span class="hljs-variable language_" >this</span>.<span class="hljs-property" >collectedMethodKeys</span>) {
        <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >collectedMethodKeys</span> = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>();
      }
      <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >collectedMethodKeys</span>.<span class="hljs-title function_" >add</span>(name);
    });
  }
  
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
    @collect
    <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {}
    @collect
    [<span class="hljs-title class_" >Symbol</span>.<span class="hljs-property" >iterator</span>]() {}
  }
  <span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >C</span>();
  assert.<span class="hljs-title function_" >deepEqual</span>(
    inst.<span class="hljs-property" >collectedMethodKeys</span>,
    <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>([<span class="hljs-string" >'toString'</span>, <span class="hljs-title class_" >Symbol</span>.<span class="hljs-property" >iterator</span>])
  );
  </code></pre>
      <p>The initializer function added by the decorator in line A must be an ordinary function because access to the implicit parameter <code>this</code> is needed. Arrow functions don’t provide this access – their <code>this</code> is statically scoped (like any normal variable).</p>
      <h3 id="summary-tables" tabindex="-1">Summary tables&nbsp;&nbsp;<a class="heading-anchor" href="#summary-tables" aria-hidden="true">#</a></h3>
      <p>Type signature:</p>
      <table class="framed">
        <thead>
          <tr>
            <th>Kind of decorator</th>
            <th><code>(input) =&gt; output</code></th>
            <th><code>.access</code></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Class</td>
            <td><code>(func) =&gt; func2</code></td>
            <td>–</td>
          </tr>
          <tr>
            <td>Method</td>
            <td><code>(func) =&gt; func2</code></td>
            <td><code>{get}</code></td>
          </tr>
          <tr>
            <td>Getter</td>
            <td><code>(func) =&gt; func2</code></td>
            <td><code>{get}</code></td>
          </tr>
          <tr>
            <td>Setter</td>
            <td><code>(func) =&gt; func2</code></td>
            <td><code>{set}</code></td>
          </tr>
          <tr>
            <td>Auto-accessor</td>
            <td><code>({get,set}) =&gt; {get,set,init}</code></td>
            <td><code>{get,set}</code></td>
          </tr>
          <tr>
            <td>Field</td>
            <td><code>() =&gt; (initValue)=&gt;initValue2</code></td>
            <td><code>{get,set}</code></td>
          </tr>
        </tbody>
      </table>
      <p>Value of <code>this</code> in functions:</p>
      <table class="framed">
        <thead>
          <tr>
            <th><code>this</code> is →</th>
            <th><code>undefined</code></th>
            <th>Class</th>
            <th>Instance</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Decorator function</td>
            <td>✔</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>Static initializer</td>
            <td></td>
            <td>✔</td>
            <td></td>
          </tr>
          <tr>
            <td>Non-static initializer</td>
            <td></td>
            <td></td>
            <td>✔</td>
          </tr>
          <tr>
            <td>Static field decorator result</td>
            <td></td>
            <td>✔</td>
            <td></td>
          </tr>
          <tr>
            <td>Non-static field decorator result</td>
            <td></td>
            <td></td>
            <td>✔</td>
          </tr>
        </tbody>
      </table>
      <h2 id="more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)" tabindex="-1">More information on the syntax and semantics of decorators (optional section)&nbsp;&nbsp;<a class="heading-anchor" href="#more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)" aria-hidden="true">#</a></h2>
      <p>(This section is optional. If you skip it, you can still understand the remaining content.)</p>
      <h3 id="the-syntax-of-decorator-expressions" tabindex="-1">The syntax of decorator expressions&nbsp;&nbsp;<a class="heading-anchor" href="#the-syntax-of-decorator-expressions" aria-hidden="true">#</a></h3>
      <ul>
        <li>A decorator expression starts with a chain of one or more identifiers, separated by dots. Each identifier except the first one can be private (prefix <code>#</code>). Square brackets <code>[]</code> are not allowed.</li>
        <li>Optional at the end: function call arguments in parentheses. The next subsection explains what that means.</li>
        <li>We can use any expression if we put it in parentheses:
          <pre><code class="language-js" >@(«expr»)
  </code></pre>
        </li>
      </ul>
      <p>Wherever decorators are allowed, we can use more than one of them. The following code demonstrates decorator syntax:</p>
      <pre><code class="language-js" ><span class="hljs-comment" >// Five decorators for MyClass</span>
  
  @myFunc
  @<span class="hljs-title function_" >myFuncFactory</span>(<span class="hljs-string" >'arg1'</span>, <span class="hljs-string" >'arg2'</span>)
  
  @libraryModule.<span class="hljs-property" >prop</span>
  @someObj.<span class="hljs-title function_" >method</span>(<span class="hljs-number" >123</span>)
  
  @(<span class="hljs-title function_" >wrap</span>(dict[<span class="hljs-string" >'prop'</span>])) <span class="hljs-comment" >// arbitrary expression</span>
  
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >MyClass</span> {}
  </code></pre>
      <h3 id="how-are-decorators-executed%3F" tabindex="-1">How are decorators executed?&nbsp;&nbsp;<a class="heading-anchor" href="#how-are-decorators-executed%3F" aria-hidden="true">#</a></h3>
      <ul>
        <li>
          <p>Evaluation: The expressions after the <code>@</code> symbols are evaluated during the execution of the class definition, along with computed property keys and static fields (see code below). The results must be functions. They are stored in temporary locations (think local variables), to be invoked later.</p>
        </li>
        <li>
          <p>Invocation: The decorator functions are called later during the execution of a class definition, after methods have been evaluated but before constructor and prototype have been assembled. Once again the results are stored in temporary locations.</p>
        </li>
        <li>
          <p>Application: After all decorator functions were invoked, their results are used, which can affect constructor and prototype. Class decorators are applied after all method and field decorators.</p>
        </li>
      </ul>
      <p>The following code illustrates in which order decorator expressions, computed property keys and field initializers are evaluated:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >decorate</span>(<span class="hljs-params" >str</span>) {
    <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >`EVALUATE @decorate(): <span class="hljs-subst" >${str}</span>`</span>);
    <span class="hljs-keyword" >return</span> <span class="hljs-function" >() =&gt;</span> <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >`APPLY @decorate(): <span class="hljs-subst" >${str}</span>`</span>); <span class="hljs-comment" >// (A)</span>
  }
  <span class="hljs-keyword" >function</span> <span class="hljs-title function_" >log</span>(<span class="hljs-params" >str</span>) {
    <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(str);
    <span class="hljs-keyword" >return</span> str;
  }
  
  @<span class="hljs-title function_" >decorate</span>(<span class="hljs-string" >'class'</span>)
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >TheClass</span> {
  
    @<span class="hljs-title function_" >decorate</span>(<span class="hljs-string" >'static field'</span>)
    <span class="hljs-keyword" >static</span> staticField = <span class="hljs-title function_" >log</span>(<span class="hljs-string" >'static field value'</span>);
  
    @<span class="hljs-title function_" >decorate</span>(<span class="hljs-string" >'prototype method'</span>)
    [<span class="hljs-title function_" >log</span>(<span class="hljs-string" >'computed key'</span>)]() {}
  
    @<span class="hljs-title function_" >decorate</span>(<span class="hljs-string" >'instance field'</span>)
    instanceField = <span class="hljs-title function_" >log</span>(<span class="hljs-string" >'instance field value'</span>);
      <span class="hljs-comment" >// This initializer only runs if we instantiate the class</span>
  }
  
  <span class="hljs-comment" >// Output:</span>
  <span class="hljs-comment" >// EVALUATE @decorate(): class</span>
  <span class="hljs-comment" >// EVALUATE @decorate(): static field</span>
  <span class="hljs-comment" >// EVALUATE @decorate(): prototype method</span>
  <span class="hljs-comment" >// computed key</span>
  <span class="hljs-comment" >// EVALUATE @decorate(): instance field</span>
  <span class="hljs-comment" >// APPLY @decorate(): prototype method</span>
  <span class="hljs-comment" >// APPLY @decorate(): static field</span>
  <span class="hljs-comment" >// APPLY @decorate(): instance field</span>
  <span class="hljs-comment" >// APPLY @decorate(): class</span>
  <span class="hljs-comment" >// static field value</span>
  </code></pre>
      <p>Function <code>decorate</code> is invoked whenever the expression <code>decorate()</code> after the <code>@</code> symbol is evaluated. In line A, it returns the actual decorator function, which is applied later.</p>
      <h3 id="decorator-initializer-execution" tabindex="-1">When do decorator initializers run?&nbsp;&nbsp;<a class="heading-anchor" href="#decorator-initializer-execution" aria-hidden="true">#</a></h3>
      <p>When a decorator initializer runs, depends on the kind of decorator:</p>
      <ul>
        <li>
          <p>Class decorator initializers run after the class is fully defined and all static fields were initialized.</p>
        </li>
        <li>
          <p>The initializers of non-static class element decorators run during instantiation, before instance fields are initialized.</p>
        </li>
        <li>
          <p>The initializers of static class element decorators run during class definition, before static fields are defined but after other all other class elements were defined.</p>
        </li>
      </ul>
      <p>Why is that? For non-static initializers, we have five options – they can run:</p>
      <ol>
        <li>Before <code>super</code></li>
        <li>After <code>super</code>, before field initialization</li>
        <li>Interleaved between fields in definition order</li>
        <li>After field initialization, before child class instantiation</li>
        <li>After child class instantiation</li>
      </ol>
      <p>Why was #2 chosen?</p>
      <ul>
        <li>
          <p>#1 was rejected because decorator initializers must be able to access <code>this</code>, which isn’t possible before <code>super</code> runs.</p>
        </li>
        <li>
          <p>#3 was rejected because running all decorator initializers at the same time is simpler than ensuring that they are properly interleaved.</p>
        </li>
      </ul>
      <ul>
        <li>
          <p>#4 was rejected because running decorator initializers before fields ensures that fields don’t see partially initialized methods. For example, if there are <code>@bind</code> decorators, then field initializers can rely on the decorated methods being bound.</p>
        </li>
        <li>
          <p>#5 was rejected because it would allow superclasses to interfere with subclasses, which would break the rule that superclasses should not be aware of their subclasses.</p>
        </li>
      </ul>
      <p>The following code demonstrates in which order Babel currently invokes decorator initializers. Note that Babel does not yet support initializers for class field decorators (which was a recent change to the decorators API).</p>
      <pre><code class="language-js" ><span class="hljs-comment" >// We wait until after instantiation before we log steps,</span>
  <span class="hljs-comment" >// so that we can compare the value of `this` with the instance.</span>
  <span class="hljs-keyword" >const</span> steps = [];
  <span class="hljs-keyword" >function</span> <span class="hljs-title function_" >push</span>(<span class="hljs-params" >msg, _this</span>) {
    steps.<span class="hljs-title function_" >push</span>({msg, _this});
  }
  <span class="hljs-keyword" >function</span> <span class="hljs-title function_" >pushStr</span>(<span class="hljs-params" >str</span>) {
    steps.<span class="hljs-title function_" >push</span>(str);
  }
  
  <span class="hljs-keyword" >function</span> <span class="hljs-title function_" >init</span>(<span class="hljs-params" >_value, {name, addInitializer}</span>) {
    <span class="hljs-title function_" >pushStr</span>(<span class="hljs-string" >`@init <span class="hljs-subst" >${name}</span>`</span>);
    <span class="hljs-keyword" >if</span> (addInitializer) {
      <span class="hljs-title function_" >addInitializer</span>(<span class="hljs-keyword" >function</span> (<span class="hljs-params" ></span>) {
        <span class="hljs-title function_" >push</span>(<span class="hljs-string" >`DECORATOR INITIALIZER <span class="hljs-subst" >${name}</span>`</span>, <span class="hljs-variable language_" >this</span>);
      });
    }
  }
  
  @init <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >TheClass</span> {
    <span class="hljs-comment" >//--- Static ---</span>
  
    <span class="hljs-keyword" >static</span> {
      <span class="hljs-title function_" >pushStr</span>(<span class="hljs-string" >'static block'</span>);
    }
  
    @init <span class="hljs-keyword" >static</span> <span class="hljs-title function_" >staticMethod</span>(<span class="hljs-params" ></span>) {}
    @init <span class="hljs-keyword" >static</span> accessor staticAcc = <span class="hljs-title function_" >pushStr</span>(<span class="hljs-string" >'staticAcc'</span>);
    @init <span class="hljs-keyword" >static</span> staticField = <span class="hljs-title function_" >pushStr</span>(<span class="hljs-string" >'staticField'</span>);
  
    <span class="hljs-comment" >//--- Non-static ---</span>
  
    @init <span class="hljs-title function_" >prototypeMethod</span>(<span class="hljs-params" ></span>) {}
    @init accessor instanceAcc = <span class="hljs-title function_" >pushStr</span>(<span class="hljs-string" >'instanceAcc'</span>);
    @init instanceField = <span class="hljs-title function_" >pushStr</span>(<span class="hljs-string" >'instanceField'</span>);
  
    <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" ></span>) {
      <span class="hljs-title function_" >pushStr</span>(<span class="hljs-string" >'constructor'</span>);
    }
  }
  
  <span class="hljs-title function_" >pushStr</span>(<span class="hljs-string" >'===== Instantiation ====='</span>);
  <span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >TheClass</span>();
  
  <span class="hljs-keyword" >for</span> (<span class="hljs-keyword" >const</span> step <span class="hljs-keyword" >of</span> steps) {
    <span class="hljs-keyword" >if</span> (<span class="hljs-keyword" >typeof</span> step === <span class="hljs-string" >'string'</span>) {
      <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(step);
      <span class="hljs-keyword" >continue</span>;
    }
    <span class="hljs-keyword" >let</span> thisDesc = <span class="hljs-string" >'???'</span>;
    <span class="hljs-keyword" >if</span> (step.<span class="hljs-property" >_this</span> === <span class="hljs-title class_" >TheClass</span>) {
      thisDesc = <span class="hljs-title class_" >TheClass</span>.<span class="hljs-property" >name</span>;
    } <span class="hljs-keyword" >else</span> <span class="hljs-keyword" >if</span> (step.<span class="hljs-property" >_this</span> === inst) {
      thisDesc = <span class="hljs-string" >'inst'</span>;
    } <span class="hljs-keyword" >else</span> <span class="hljs-keyword" >if</span> (step.<span class="hljs-property" >_this</span> === <span class="hljs-literal" >undefined</span>) {
      thisDesc = <span class="hljs-string" >'undefined'</span>;
    }
    <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >`<span class="hljs-subst" >${step.msg}</span> (this===<span class="hljs-subst" >${thisDesc}</span>)`</span>);
  }
  
  <span class="hljs-comment" >// Output:</span>
  <span class="hljs-comment" >// @init staticMethod</span>
  <span class="hljs-comment" >// @init staticAcc</span>
  <span class="hljs-comment" >// @init prototypeMethod</span>
  <span class="hljs-comment" >// @init instanceAcc</span>
  <span class="hljs-comment" >// @init staticField</span>
  <span class="hljs-comment" >// @init instanceField</span>
  <span class="hljs-comment" >// @init TheClass</span>
  <span class="hljs-comment" >// DECORATOR INITIALIZER staticMethod (this===TheClass)</span>
  <span class="hljs-comment" >// DECORATOR INITIALIZER staticAcc (this===TheClass)</span>
  <span class="hljs-comment" >// static block</span>
  <span class="hljs-comment" >// staticAcc</span>
  <span class="hljs-comment" >// staticField</span>
  <span class="hljs-comment" >// DECORATOR INITIALIZER TheClass (this===TheClass)</span>
  <span class="hljs-comment" >// ===== Instantiation =====</span>
  <span class="hljs-comment" >// DECORATOR INITIALIZER prototypeMethod (this===inst)</span>
  <span class="hljs-comment" >// DECORATOR INITIALIZER instanceAcc (this===inst)</span>
  <span class="hljs-comment" >// instanceAcc</span>
  <span class="hljs-comment" >// instanceField</span>
  <span class="hljs-comment" >// constructor</span>
  </code></pre>
      <h2 id="techniques-for-exposing-data-from-decorators" tabindex="-1">Techniques for exposing data from decorators&nbsp;&nbsp;<a class="heading-anchor" href="#techniques-for-exposing-data-from-decorators" aria-hidden="true">#</a></h2>
      <p>Sometimes decorators collect data. Let’s explore how they can make this data available to other parties.</p>
      <h3 id="storing-exposed-data-in-a-surrounding-scope" tabindex="-1">Storing exposed data in a surrounding scope&nbsp;&nbsp;<a class="heading-anchor" href="#storing-exposed-data-in-a-surrounding-scope" aria-hidden="true">#</a></h3>
      <p>The simplest solution is to store data in a location in a surrounding scope. For example, the decorator <code>@collect</code> collects classes and stores them in the Set <code>classes</code> (line A):</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >const</span> classes = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>(); <span class="hljs-comment" >// (A)</span>
  
  <span class="hljs-keyword" >function</span> <span class="hljs-title function_" >collect</span>(<span class="hljs-params" >value, {kind, addInitializer}</span>) {
    <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'class'</span>) {
      classes.<span class="hljs-title function_" >add</span>(value);
    }
  }
  
  @collect
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >A</span> {}
  @collect
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >B</span> {}
  @collect
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {}
  
  assert.<span class="hljs-title function_" >deepEqual</span>(
    classes, <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>([A, B, C])
  );
  </code></pre>
      <p>The downside of this approach is that it doesn’t work if a decorator comes from another module.</p>
      <h3 id="managing-exposed-data-via-a-factory-function" tabindex="-1">Managing exposed data via a factory function&nbsp;&nbsp;<a class="heading-anchor" href="#managing-exposed-data-via-a-factory-function" aria-hidden="true">#</a></h3>
      <p>A more sophisticated approach is to use a factory function <code>createClassCollector()</code> that returns:</p>
      <ul>
        <li>A class decorator <code>collect</code></li>
        <li>A Set <code>classes</code>, to which the decorator will add the classes it collects</li>
      </ul>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >createClassCollector</span>(<span class="hljs-params" ></span>) {
    <span class="hljs-keyword" >const</span> classes = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>();
    <span class="hljs-keyword" >function</span> <span class="hljs-title function_" >collect</span>(<span class="hljs-params" >value, {kind, addInitializer}</span>) {
      <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'class'</span>) {
        classes.<span class="hljs-title function_" >add</span>(value);
      }
    }
    <span class="hljs-keyword" >return</span> {
      classes,
      collect,
    };
  }
  
  <span class="hljs-keyword" >const</span> {classes, collect} = <span class="hljs-title function_" >createClassCollector</span>();
  
  @collect
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >A</span> {}
  @collect
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >B</span> {}
  @collect
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {}
  
  assert.<span class="hljs-title function_" >deepEqual</span>(
    classes, <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>([A, B, C])
  );
  </code></pre>
      <h3 id="managing-exposed-data-via-a-class" tabindex="-1">Managing exposed data via a class&nbsp;&nbsp;<a class="heading-anchor" href="#managing-exposed-data-via-a-class" aria-hidden="true">#</a></h3>
      <p>Instead of a factory function, we can also use a class. It has two members:</p>
      <ul>
        <li><code>.classes</code>, a Set with the collected classes</li>
        <li><code>.install</code>, a class decorator</li>
      </ul>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >ClassCollector</span> {
    classes = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>();
    install = <span class="hljs-function" >(<span class="hljs-params" >value, {kind}</span>) =&gt;</span> { <span class="hljs-comment" >// (A)</span>
      <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'class'</span>) {
        <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >classes</span>.<span class="hljs-title function_" >add</span>(value); <span class="hljs-comment" >// (B)</span>
      }
    };
  }
  
  <span class="hljs-keyword" >const</span> collector = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >ClassCollector</span>();
  
  @collector.<span class="hljs-property" >install</span>
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >A</span> {}
  @collector.<span class="hljs-property" >install</span>
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >B</span> {}
  @collector.<span class="hljs-property" >install</span>
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {}
  
  assert.<span class="hljs-title function_" >deepEqual</span>(
    collector.<span class="hljs-property" >classes</span>, <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>([A, B, C])
  );
  </code></pre>
      <p>We implemented <code>.install</code> by assigning an arrow function to a public instance field (line A). Instance field initializers run in scopes where <code>this</code> refers to the current instance. That is also the outer scope of the arrow function and explains what value <code>this</code> has in line B.</p>
      <p>We could also implement <code>.install</code> via a getter, but then we’d have to return a new function whenever <code>.install</code> is read.</p>
      <h2 id="class-decorators" tabindex="-1">Class decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-decorators" aria-hidden="true">#</a></h2>
      <p>Class decorators have the following type signature:</p>
      <pre><code class="language-ts" ><span class="hljs-keyword" >type</span> <span class="hljs-title class_" >ClassDecorator</span> = <span class="hljs-function" >(<span class="hljs-params" >
    <span class="hljs-attr" >value</span>: <span class="hljs-title class_" >Function</span>,
    <span class="hljs-attr" >context</span>: {
      kind: <span class="hljs-string" >'class'</span>;
      name: <span class="hljs-built_in" >string</span> | <span class="hljs-literal" >undefined</span>;
      addInitializer(initializer: () =&gt; <span class="hljs-built_in" >void</span>): <span class="hljs-built_in" >void</span>;
    }
  </span>) =&gt;</span> <span class="hljs-title class_" >Function</span> | <span class="hljs-built_in" >void</span>;
  </code></pre>
      <p>Abilities of a class decorator:</p>
      <ul>
        <li>It can change the decorated class by changing <code>value</code>.</li>
        <li>It can replace the decorated class by returning a callable value.</li>
        <li>It can register initializers, which are called after the decorated class is fully set up.</li>
        <li>It does not get <code>context.access</code> because classes are not members of other language constructs (whereas, e.g., methods are members of classes).</li>
      </ul>
      <h3 id="example%3A-collecting-instances" tabindex="-1">Example: collecting instances&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-collecting-instances" aria-hidden="true">#</a></h3>
      <p>In the next example, we use a decorator to collect all instances of a decorated class:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >InstanceCollector</span> {
    instances = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>();
    install = <span class="hljs-function" >(<span class="hljs-params" >value, {kind}</span>) =&gt;</span> {
      <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'class'</span>) {
        <span class="hljs-keyword" >const</span> _this = <span class="hljs-variable language_" >this</span>;
        <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" >...args</span>) { <span class="hljs-comment" >// (A)</span>
          <span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >value</span>(...args); <span class="hljs-comment" >// (B)</span>
          _this.<span class="hljs-property" >instances</span>.<span class="hljs-title function_" >add</span>(inst);
          <span class="hljs-keyword" >return</span> inst;
        };
      }
    };
  }
  
  <span class="hljs-keyword" >const</span> collector = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >InstanceCollector</span>();
  
  @collector.<span class="hljs-property" >install</span>
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >MyClass</span> {}
  
  <span class="hljs-keyword" >const</span> inst1 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();
  <span class="hljs-keyword" >const</span> inst2 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();
  <span class="hljs-keyword" >const</span> inst3 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();
  
  assert.<span class="hljs-title function_" >deepEqual</span>(
    collector.<span class="hljs-property" >instances</span>, <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Set</span>([inst1, inst2, inst3])
  );
  </code></pre>
      <p>The only way in which we can collect all instances of a given class via a decorator is by wrapping that class. The decorator in the field <code>.install</code> does that by returning a function (line A) that new-calls the decorated <code>value</code> (line B) and collects and returns the result.</p>
      <p>Note that we can’t return an arrow function in line A, because arrow functions can’t be new-called.</p>
      <p>One downside of this approach is that it breaks <code>instanceof</code>:</p>
      <pre><code class="language-js" >assert.<span class="hljs-title function_" >equal</span>(
    inst1 <span class="hljs-keyword" >instanceof</span> <span class="hljs-title class_" >MyClass</span>,
    <span class="hljs-literal" >false</span>
  );
  </code></pre>
      <p>The next subsection explains how we can fix that.</p>
      <h3 id="making-sure-that-instanceof-works" tabindex="-1">Making sure that <code>instanceof</code> works&nbsp;&nbsp;<a class="heading-anchor" href="#making-sure-that-instanceof-works" aria-hidden="true">#</a></h3>
      <p>In this section, we use the simple decorator <code>@countInstances</code> to show how we can support <code>instanceof</code> for wrapped classes.</p>
      <h4 id="enabling-instanceof-via-.prototype" tabindex="-1">Enabling <code>instanceof</code> via <code>.prototype</code>&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-.prototype" aria-hidden="true">#</a></h4>
      <p>One way of enabling <code>instanceof</code> is to set the <code>.prototype</code> of the wrapper function to the <code>.prototype</code> of the wrapped <code>value</code> (line A):</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >countInstances</span>(<span class="hljs-params" >value</span>) {
    <span class="hljs-keyword" >const</span> _this = <span class="hljs-variable language_" >this</span>;
    <span class="hljs-keyword" >let</span> instanceCount = <span class="hljs-number" >0</span>;
    <span class="hljs-comment" >// The wrapper must be new-callable</span>
    <span class="hljs-keyword" >const</span> wrapper = <span class="hljs-keyword" >function</span> (<span class="hljs-params" >...args</span>) {
      instanceCount++;
      <span class="hljs-keyword" >const</span> instance = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >value</span>(...args);
      <span class="hljs-comment" >// Change the instance</span>
      instance.<span class="hljs-property" >count</span> = instanceCount;
      <span class="hljs-keyword" >return</span> instance;
    };
    wrapper.<span class="hljs-property" ><span class="hljs-keyword" >prototype</span></span> = value.<span class="hljs-property" ><span class="hljs-keyword" >prototype</span></span>; <span class="hljs-comment" >// (A)</span>
    <span class="hljs-keyword" >return</span> wrapper;
  }
  
  @countInstances
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >MyClass</span> {}
  
  <span class="hljs-keyword" >const</span> inst1 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();
  assert.<span class="hljs-title function_" >ok</span>(inst1 <span class="hljs-keyword" >instanceof</span> <span class="hljs-title class_" >MyClass</span>);
  assert.<span class="hljs-title function_" >equal</span>(inst1.<span class="hljs-property" >count</span>, <span class="hljs-number" >1</span>);
  
  <span class="hljs-keyword" >const</span> inst2 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();
  assert.<span class="hljs-title function_" >ok</span>(inst2 <span class="hljs-keyword" >instanceof</span> <span class="hljs-title class_" >MyClass</span>);
  assert.<span class="hljs-title function_" >equal</span>(inst2.<span class="hljs-property" >count</span>, <span class="hljs-number" >2</span>);
  </code></pre>
      <p>Why does that work? Because the following expressions are equivalent:</p>
      <pre><code class="language-js" >inst <span class="hljs-keyword" >instanceof</span> C
  C.<span class="hljs-property" ><span class="hljs-keyword" >prototype</span></span>.<span class="hljs-title function_" >isPrototypeOf</span>(inst)
  </code></pre>
      <p>For more information on <code>instanceof</code>, see <a href="https://exploringjs.com/js/book/ch_classes.html#instanceof-operator">“Exploring JavaScript”</a>.</p>
      <h4 id="enabling-instanceof-via-symbol.hasinstance" tabindex="-1">Enabling <code>instanceof</code> via <code>Symbol.hasInstance</code>&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-symbol.hasinstance" aria-hidden="true">#</a></h4>
      <p>Another option for enabling <code>instanceof</code> is to give the wrapper function a method whose key is <code>Symbol.hasInstance</code> (line A):</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >countInstances</span>(<span class="hljs-params" >value</span>) {
    <span class="hljs-keyword" >const</span> _this = <span class="hljs-variable language_" >this</span>;
    <span class="hljs-keyword" >let</span> instanceCount = <span class="hljs-number" >0</span>;
    <span class="hljs-comment" >// The wrapper must be new-callable</span>
    <span class="hljs-keyword" >const</span> wrapper = <span class="hljs-keyword" >function</span> (<span class="hljs-params" >...args</span>) {
      instanceCount++;
      <span class="hljs-keyword" >const</span> instance = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >value</span>(...args);
      <span class="hljs-comment" >// Change the instance</span>
      instance.<span class="hljs-property" >count</span> = instanceCount;
      <span class="hljs-keyword" >return</span> instance;
    };
    <span class="hljs-comment" >// Property is read-only, so we can’t use assignment</span>
    <span class="hljs-title class_" >Object</span>.<span class="hljs-title function_" >defineProperty</span>( <span class="hljs-comment" >// (A)</span>
      wrapper, <span class="hljs-title class_" >Symbol</span>.<span class="hljs-property" >hasInstance</span>,
      {
        <span class="hljs-attr" >value</span>: <span class="hljs-keyword" >function</span> (<span class="hljs-params" >x</span>) {
          <span class="hljs-keyword" >return</span> x <span class="hljs-keyword" >instanceof</span> value; 
        }
      }
    );
    <span class="hljs-keyword" >return</span> wrapper;
  }
  
  @countInstances
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >MyClass</span> {}
  
  <span class="hljs-keyword" >const</span> inst1 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();
  assert.<span class="hljs-title function_" >ok</span>(inst1 <span class="hljs-keyword" >instanceof</span> <span class="hljs-title class_" >MyClass</span>);
  assert.<span class="hljs-title function_" >equal</span>(inst1.<span class="hljs-property" >count</span>, <span class="hljs-number" >1</span>);
  
  <span class="hljs-keyword" >const</span> inst2 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();
  assert.<span class="hljs-title function_" >ok</span>(inst2 <span class="hljs-keyword" >instanceof</span> <span class="hljs-title class_" >MyClass</span>);
  assert.<span class="hljs-title function_" >equal</span>(inst2.<span class="hljs-property" >count</span>, <span class="hljs-number" >2</span>);
  </code></pre>
      <p>“Exploring JavaScript” has <a href="https://exploringjs.com/js/book/ch_symbols.html#publicly-known-symbols">more information on <code>Symbol.hasInstance</code></a>.</p>
      <h4 id="enabling-instanceof-via-subclassing" tabindex="-1">Enabling <code>instanceof</code> via subclassing&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-subclassing" aria-hidden="true">#</a></h4>
      <p>We can also enable <code>instanceof</code> by returning a subclass of <code>value</code> (line A):</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >countInstances</span>(<span class="hljs-params" >value</span>) {
    <span class="hljs-keyword" >const</span> _this = <span class="hljs-variable language_" >this</span>;
    <span class="hljs-keyword" >let</span> instanceCount = <span class="hljs-number" >0</span>;
    <span class="hljs-comment" >// The wrapper must be new-callable</span>
    <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >extends</span> value { <span class="hljs-comment" >// (A)</span>
      <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >...args</span>) {
        <span class="hljs-variable language_" >super</span>(...args);
        instanceCount++;
        <span class="hljs-comment" >// Change the instance</span>
        <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >count</span> = instanceCount;
      }
    };
  }
  
  @countInstances
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >MyClass</span> {}
  
  <span class="hljs-keyword" >const</span> inst1 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();
  assert.<span class="hljs-title function_" >ok</span>(inst1 <span class="hljs-keyword" >instanceof</span> <span class="hljs-title class_" >MyClass</span>);
  assert.<span class="hljs-title function_" >equal</span>(inst1.<span class="hljs-property" >count</span>, <span class="hljs-number" >1</span>);
  
  <span class="hljs-keyword" >const</span> inst2 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >MyClass</span>();
  assert.<span class="hljs-title function_" >ok</span>(inst2 <span class="hljs-keyword" >instanceof</span> <span class="hljs-title class_" >MyClass</span>);
  assert.<span class="hljs-title function_" >equal</span>(inst2.<span class="hljs-property" >count</span>, <span class="hljs-number" >2</span>);
  </code></pre>
      <h3 id="example-freezing-instances" tabindex="-1">Example: freezing instances&nbsp;&nbsp;<a class="heading-anchor" href="#example-freezing-instances" aria-hidden="true">#</a></h3>
      <p>The decorator class <code>@freeze</code> freezes all instances produced by the classes it decorates:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >freeze</span> (<span class="hljs-params" >value, {kind}</span>) {
    <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'class'</span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" >...args</span>) {
        <span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >value</span>(...args);
        <span class="hljs-keyword" >return</span> <span class="hljs-title class_" >Object</span>.<span class="hljs-title function_" >freeze</span>(inst);
      }
    }
  }
  
  @freeze
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Color</span> {
    <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >name</span>) {
      <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >name</span> = name;
    }
  }
  
  <span class="hljs-keyword" >const</span> red = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>(<span class="hljs-string" >'red'</span>);
  assert.<span class="hljs-title function_" >throws</span>(
    <span class="hljs-function" >() =&gt;</span> red.<span class="hljs-property" >name</span> = <span class="hljs-string" >'green'</span>,
    <span class="hljs-regexp" >/^TypeError: Cannot assign to read only property 'name'/</span>
  );
  </code></pre>
      <p>This decorator has downsides:</p>
      <ul>
        <li>It breaks <code>instanceof</code>. We have already seen how to fix this.</li>
        <li>Subclassing a decorated class doesn’t work well:
          <ul>
            <li>The way in which constructors are connected isn’t ideal – with a wrapped constructor in the mix. This can be partially fixed by returning a subclass of the decorated <code>value</code>.</li>
            <li>Subclasses can’t set up properties, because their <code>this</code> is immutable. There is no way to avoid this downside.</li>
          </ul>
        </li>
      </ul>
      <p>The last downside could be avoided by giving class decorators access to the instances of the decorated classes after all constructors were executed.</p>
      <p>This would change how inheritance works because a superclass could now change properties that were added by subclasses. Therefore, it’s not sure if such a mechanism is in the cards.</p>
      <h3 id="example%3A-making-classes-function-callable" tabindex="-1">Example: making classes function-callable&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-making-classes-function-callable" aria-hidden="true">#</a></h3>
      <p>Classes decorated by <code>@functionCallable</code> can be invoked by function calls instead of the <code>new</code> operator:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >functionCallable</span>(<span class="hljs-params" >value, {kind}</span>) {
    <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'class'</span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" >...args</span>) {
        <span class="hljs-keyword" >if</span> (<span class="hljs-keyword" >new</span>.<span class="hljs-property" >target</span> !== <span class="hljs-literal" >undefined</span>) {
          <span class="hljs-keyword" >throw</span> <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >TypeError</span>(<span class="hljs-string" >'This function can’t be new-invoked'</span>);
        }
        <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >value</span>(...args);
      }
    }
  }
  
  @functionCallable
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Person</span> {
    <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >name</span>) {
      <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >name</span> = name;
    }
  }
  <span class="hljs-keyword" >const</span> robin = <span class="hljs-title class_" >Person</span>(<span class="hljs-string" >'Robin'</span>);
  assert.<span class="hljs-title function_" >equal</span>(
    robin.<span class="hljs-property" >name</span>, <span class="hljs-string" >'Robin'</span>
  );
  </code></pre>
      <h2 id="class-method-decorators" tabindex="-1">Class method decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-method-decorators" aria-hidden="true">#</a></h2>
      <p>Class method decorators have the following type signature:</p>
      <pre><code class="language-ts" ><span class="hljs-keyword" >type</span> <span class="hljs-title class_" >ClassMethodDecorator</span> = <span class="hljs-function" >(<span class="hljs-params" >
    <span class="hljs-attr" >value</span>: <span class="hljs-title class_" >Function</span>,
    <span class="hljs-attr" >context</span>: {
      kind: <span class="hljs-string" >'method'</span>;
      name: <span class="hljs-built_in" >string</span> | <span class="hljs-built_in" >symbol</span>;
      <span class="hljs-keyword" >static</span>: <span class="hljs-built_in" >boolean</span>;
      <span class="hljs-keyword" >private</span>: <span class="hljs-built_in" >boolean</span>;
      access: { get: () =&gt; <span class="hljs-built_in" >unknown</span> };
      addInitializer(initializer: () =&gt; <span class="hljs-built_in" >void</span>): <span class="hljs-built_in" >void</span>;
    }
  </span>) =&gt;</span> <span class="hljs-title class_" >Function</span> | <span class="hljs-built_in" >void</span>;
  </code></pre>
      <p>Abilities of a method decorator:</p>
      <ul>
        <li>It can change the decorated method by changing <code>value</code>.</li>
        <li>It can replace the decorated method by returning a function.</li>
        <li>It can register initializers.</li>
        <li><code>context.access</code> only supports getting the value of its property, not setting it.</li>
      </ul>
      <p>Constructors can’t be decorated: They look like methods, but they aren’t really methods.</p>
      <h3 id="example-tracing-method-invocations" tabindex="-1">Example: tracing method invocations&nbsp;&nbsp;<a class="heading-anchor" href="#example-tracing-method-invocations" aria-hidden="true">#</a></h3>
      <p>The decorator <code>@trace</code> wraps methods so that their invocations and results are logged to the console:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >trace</span>(<span class="hljs-params" >value, {kind, name}</span>) {
    <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'method'</span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" >...args</span>) {
        <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >`CALL <span class="hljs-subst" >${name}</span>: <span class="hljs-subst" >${<span class="hljs-built_in" >JSON</span>.stringify(args)}</span>`</span>);
        <span class="hljs-keyword" >const</span> result = value.<span class="hljs-title function_" >apply</span>(<span class="hljs-variable language_" >this</span>, args);
        <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >'=&gt; '</span> + <span class="hljs-title class_" >JSON</span>.<span class="hljs-title function_" >stringify</span>(result));
        <span class="hljs-keyword" >return</span> result;
      };
    }
  }
  
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >StringBuilder</span> {
    #str = <span class="hljs-string" >''</span>;
    @trace
    <span class="hljs-title function_" >add</span>(<span class="hljs-params" >str</span>) {
      <span class="hljs-variable language_" >this</span>.#str += str;
    }
    @trace
    <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-variable language_" >this</span>.#str;
    }
  }
  
  <span class="hljs-keyword" >const</span> sb = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >StringBuilder</span>();
  sb.<span class="hljs-title function_" >add</span>(<span class="hljs-string" >'Home'</span>);
  sb.<span class="hljs-title function_" >add</span>(<span class="hljs-string" >'page'</span>);
  assert.<span class="hljs-title function_" >equal</span>(
    sb.<span class="hljs-title function_" >toString</span>(), <span class="hljs-string" >'Homepage'</span>
  );
  
  <span class="hljs-comment" >// Output:</span>
  <span class="hljs-comment" >// CALL add: ["Home"]</span>
  <span class="hljs-comment" >// =&gt; undefined</span>
  <span class="hljs-comment" >// CALL add: ["page"]</span>
  <span class="hljs-comment" >// =&gt; undefined</span>
  <span class="hljs-comment" >// CALL toString: []</span>
  <span class="hljs-comment" >// =&gt; "Homepage"</span>
  </code></pre>
      <h3 id="example%3A-binding-methods-to-instances" tabindex="-1">Example: binding methods to instances&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-binding-methods-to-instances" aria-hidden="true">#</a></h3>
      <p>Normally, extracting methods (line A) means that we can’t function-call them because that sets <code>this</code> to <code>undefined</code>:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Color1</span> {
    #name;
    <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >name</span>) {
      <span class="hljs-variable language_" >this</span>.#name = name;
    }
    <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-string" >`Color(<span class="hljs-subst" >${<span class="hljs-variable language_" >this</span>.#name}</span>)`</span>;
    }
  }
  
  <span class="hljs-keyword" >const</span> green1 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color1</span>(<span class="hljs-string" >'green'</span>);
  <span class="hljs-keyword" >const</span> toString1 = green1.<span class="hljs-property" >toString</span>; <span class="hljs-comment" >// (A)</span>
  assert.<span class="hljs-title function_" >throws</span>(
    <span class="hljs-function" >() =&gt;</span> <span class="hljs-title function_" >toString1</span>(),
    <span class="hljs-regexp" >/^TypeError: Cannot read properties of undefined/</span>
  );
  </code></pre>
      <p>We can fix that via the decorator <code>@bind</code>:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >bind</span>(<span class="hljs-params" >value, {kind, name, addInitializer}</span>) {
    <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'method'</span>) {
      <span class="hljs-title function_" >addInitializer</span>(<span class="hljs-keyword" >function</span> (<span class="hljs-params" ></span>) { <span class="hljs-comment" >// (B)</span>
        <span class="hljs-variable language_" >this</span>[name] = value.<span class="hljs-title function_" >bind</span>(<span class="hljs-variable language_" >this</span>); <span class="hljs-comment" >// (C)</span>
      });
    }
  }
  
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Color2</span> {
    #name;
    <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >name</span>) {
      <span class="hljs-variable language_" >this</span>.#name = name;
    }
    @bind
    <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-string" >`Color(<span class="hljs-subst" >${<span class="hljs-variable language_" >this</span>.#name}</span>)`</span>;
    }
  }
  
  <span class="hljs-keyword" >const</span> green2 = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color2</span>(<span class="hljs-string" >'green'</span>);
  <span class="hljs-keyword" >const</span> toString2 = green2.<span class="hljs-property" >toString</span>;
  assert.<span class="hljs-title function_" >equal</span>(
    <span class="hljs-title function_" >toString2</span>(), <span class="hljs-string" >'Color(green)'</span>
  );
  
  <span class="hljs-comment" >// The own property green2.toString is different</span>
  <span class="hljs-comment" >// from Color2.prototype.toString</span>
  assert.<span class="hljs-title function_" >ok</span>(<span class="hljs-title class_" >Object</span>.<span class="hljs-title function_" >hasOwn</span>(green2, <span class="hljs-string" >'toString'</span>));
  assert.<span class="hljs-title function_" >notEqual</span>(
    green2.<span class="hljs-property" >toString</span>,
    <span class="hljs-title class_" >Color2</span>.<span class="hljs-property" ><span class="hljs-keyword" >prototype</span></span>.<span class="hljs-property" >toString</span>
  );
  </code></pre>
      <p>Per decorated method, the initializer registered in line B is invoked whenever an instance is created and adds an own property whose value is a function with a fixed <code>this</code> (line C).</p>
      <h3 id="example%3A-applying-functions-to-methods" tabindex="-1">Example: applying functions to methods&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-applying-functions-to-methods" aria-hidden="true">#</a></h3>
      <p>The library <code>core-decorators</code> has <a href="https://github.com/jayphelps/core-decorators#decorate">a decorator</a> that lets us apply functions to methods. That enables us to use helper functions such as Lodash’s <code>memoize()</code>. The following code shows an implementation <code>@applyFunction</code> of such a decorator:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >import</span> { memoize } <span class="hljs-keyword" >from</span> <span class="hljs-string" >'lodash-es'</span>;
  
  <span class="hljs-keyword" >function</span> <span class="hljs-title function_" >applyFunction</span>(<span class="hljs-params" >functionFactory</span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-function" >(<span class="hljs-params" >value, {kind}</span>) =&gt;</span> { <span class="hljs-comment" >// decorator function</span>
      <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'method'</span>) {
        <span class="hljs-keyword" >return</span> <span class="hljs-title function_" >functionFactory</span>(value);
      }
    };
  }
  
  <span class="hljs-keyword" >let</span> invocationCount = <span class="hljs-number" >0</span>;
  
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Task</span> {
    @<span class="hljs-title function_" >applyFunction</span>(memoize)
    <span class="hljs-title function_" >expensiveOperation</span>(<span class="hljs-params" >str</span>) {
      invocationCount++;
      <span class="hljs-comment" >// Expensive processing of `str` 😀</span>
      <span class="hljs-keyword" >return</span> str + str;
    }
  }
  
  <span class="hljs-keyword" >const</span> task = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Task</span>();
  assert.<span class="hljs-title function_" >equal</span>(
    task.<span class="hljs-title function_" >expensiveOperation</span>(<span class="hljs-string" >'abc'</span>),
    <span class="hljs-string" >'abcabc'</span>
  );
  assert.<span class="hljs-title function_" >equal</span>(
    task.<span class="hljs-title function_" >expensiveOperation</span>(<span class="hljs-string" >'abc'</span>),
    <span class="hljs-string" >'abcabc'</span>
  );
  assert.<span class="hljs-title function_" >equal</span>(
    invocationCount, <span class="hljs-number" >1</span>
  );
  </code></pre>
      <h2 id="class-getter-decorators%2C-class-setter-decorators" tabindex="-1">Class getter decorators, class setter decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-getter-decorators%2C-class-setter-decorators" aria-hidden="true">#</a></h2>
      <p>These are the type signatures of getter decorators and setter decorators:</p>
      <pre><code class="language-ts" ><span class="hljs-keyword" >type</span> <span class="hljs-title class_" >ClassGetterDecorator</span> = <span class="hljs-function" >(<span class="hljs-params" >
    <span class="hljs-attr" >value</span>: <span class="hljs-title class_" >Function</span>,
    <span class="hljs-attr" >context</span>: {
      kind: <span class="hljs-string" >'getter'</span>;
      name: <span class="hljs-built_in" >string</span> | <span class="hljs-built_in" >symbol</span>;
      <span class="hljs-keyword" >static</span>: <span class="hljs-built_in" >boolean</span>;
      <span class="hljs-keyword" >private</span>: <span class="hljs-built_in" >boolean</span>;
      access: { get: () =&gt; <span class="hljs-built_in" >unknown</span> };
      addInitializer(initializer: () =&gt; <span class="hljs-built_in" >void</span>): <span class="hljs-built_in" >void</span>;
    }
  </span>) =&gt;</span> <span class="hljs-title class_" >Function</span> | <span class="hljs-built_in" >void</span>;
  
  <span class="hljs-keyword" >type</span> <span class="hljs-title class_" >ClassSetterDecorator</span> = <span class="hljs-function" >(<span class="hljs-params" >
    <span class="hljs-attr" >value</span>: <span class="hljs-title class_" >Function</span>,
    <span class="hljs-attr" >context</span>: {
      kind: <span class="hljs-string" >'setter'</span>;
      name: <span class="hljs-built_in" >string</span> | <span class="hljs-built_in" >symbol</span>;
      <span class="hljs-keyword" >static</span>: <span class="hljs-built_in" >boolean</span>;
      <span class="hljs-keyword" >private</span>: <span class="hljs-built_in" >boolean</span>;
      access: { set: (value: <span class="hljs-built_in" >unknown</span>) =&gt; <span class="hljs-built_in" >void</span> };
      addInitializer(initializer: () =&gt; <span class="hljs-built_in" >void</span>): <span class="hljs-built_in" >void</span>;
    }
  </span>) =&gt;</span> <span class="hljs-title class_" >Function</span> | <span class="hljs-built_in" >void</span>;
  </code></pre>
      <p>Getter decorators and setter decorators have similar abilities to method decorators.</p>
      <h3 id="example%3A-computing-values-lazily" tabindex="-1">Example: computing values lazily&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-computing-values-lazily" aria-hidden="true">#</a></h3>
      <p>To implement a property whose value is computed <em>lazily</em> (on demand), we use two techniques:</p>
      <ul>
        <li>
          <p>We implement the property via a getter. That way, the code that computes its value, is only executed if the property is read.</p>
        </li>
        <li>
          <p>The decorator <code>@lazy</code> wraps the original getter: When the wrapper is invoked for the first time, it invokes the getter and creates an own data property whose value is the result. From now on, the own property overrides the inherited getter whenever someone reads the property.</p>
        </li>
      </ul>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
    @lazy
    <span class="hljs-keyword" >get</span> <span class="hljs-title function_" >value</span>() {
      <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >'COMPUTING'</span>);
      <span class="hljs-keyword" >return</span> <span class="hljs-string" >'Result of computation'</span>;
    }
  }
  
  <span class="hljs-keyword" >function</span> <span class="hljs-title function_" >lazy</span>(<span class="hljs-params" >value, {kind, name, addInitializer}</span>) {
    <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'getter'</span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" ></span>) {
        <span class="hljs-keyword" >const</span> result = value.<span class="hljs-title function_" >call</span>(<span class="hljs-variable language_" >this</span>);
        <span class="hljs-title class_" >Object</span>.<span class="hljs-title function_" >defineProperty</span>( <span class="hljs-comment" >// (A)</span>
          <span class="hljs-variable language_" >this</span>, name,
          {
            <span class="hljs-attr" >value</span>: result,
            <span class="hljs-attr" >writable</span>: <span class="hljs-literal" >false</span>,
          }
        );
        <span class="hljs-keyword" >return</span> result;
      };
    }
  }
  
  <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >'1 new C()'</span>);
  <span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >C</span>();
  <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >'2 inst.value'</span>);
  assert.<span class="hljs-title function_" >equal</span>(inst.<span class="hljs-property" >value</span>, <span class="hljs-string" >'Result of computation'</span>);
  <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >'3 inst.value'</span>);
  assert.<span class="hljs-title function_" >equal</span>(inst.<span class="hljs-property" >value</span>, <span class="hljs-string" >'Result of computation'</span>);
  <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >'4 end'</span>);
  
  <span class="hljs-comment" >// Output:</span>
  <span class="hljs-comment" >// 1 new C()</span>
  <span class="hljs-comment" >// 2 inst.value</span>
  <span class="hljs-comment" >// COMPUTING</span>
  <span class="hljs-comment" >// 3 inst.value</span>
  <span class="hljs-comment" >// 4 end</span>
  </code></pre>
      <p>Note that property <code>.[name]</code> is immutable (because there is only a getter), which is why we have to define the property (line A) and can’t use assignment.</p>
      <h2 id="class-field-decorators" tabindex="-1">Class field decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-field-decorators" aria-hidden="true">#</a></h2>
      <p>Class field decorators have the following type signature:</p>
      <pre><code class="language-ts" ><span class="hljs-keyword" >type</span> <span class="hljs-title class_" >ClassFieldDecorator</span> = <span class="hljs-function" >(<span class="hljs-params" >
    <span class="hljs-attr" >value</span>: <span class="hljs-literal" >undefined</span>,
    <span class="hljs-attr" >context</span>: {
      kind: <span class="hljs-string" >'field'</span>;
      name: <span class="hljs-built_in" >string</span> | <span class="hljs-built_in" >symbol</span>;
      <span class="hljs-keyword" >static</span>: <span class="hljs-built_in" >boolean</span>;
      <span class="hljs-keyword" >private</span>: <span class="hljs-built_in" >boolean</span>;
      access: { get: () =&gt; <span class="hljs-built_in" >unknown</span>, set: (value: <span class="hljs-built_in" >unknown</span>) =&gt; <span class="hljs-built_in" >void</span> };
      addInitializer(initializer: () =&gt; <span class="hljs-built_in" >void</span>): <span class="hljs-built_in" >void</span>;
    }
  </span>) =&gt;</span> <span class="hljs-function" >(<span class="hljs-params" ><span class="hljs-attr" >initialValue</span>: <span class="hljs-built_in" >unknown</span></span>) =&gt;</span> <span class="hljs-built_in" >unknown</span> | <span class="hljs-built_in" >void</span>;
  </code></pre>
      <p>Abilities of a field decorator:</p>
      <ul>
        <li>
          <p>It cannot change or replace its field. If we need that functionality, we have to use an <em>auto-accessor</em> (what that is, is described <a href="#auto-accessors">later</a>).</p>
        </li>
        <li>
          <p>It can change the value with which “its” field is initialized, by returning a function that receives the original initialization value and returns a new initialization value.</p>
          <ul>
            <li>Inside that function, <code>this</code> refers to the current instance.</li>
          </ul>
        </li>
        <li>
          <p>It can register initializers. That is a recent change (post-2022-03) of the decorators API and wasn’t possible before.</p>
        </li>
      </ul>
      <ul>
        <li>It can expose access to its field (even if it’s private) via <code>context.access</code>.</li>
      </ul>
      <h3 id="example%3A-changing-initialization-values-of-fields" tabindex="-1">Example: changing initialization values of fields&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-changing-initialization-values-of-fields" aria-hidden="true">#</a></h3>
      <p>The decorator <code>@twice</code> doubles the original initialization value of a field by returning a function that performs this change:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >twice</span>(<span class="hljs-params" ></span>) {
    <span class="hljs-keyword" >return</span> <span class="hljs-function" ><span class="hljs-params" >initialValue</span> =&gt;</span> initialValue * <span class="hljs-number" >2</span>;
  }
  
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
    @twice
    field = <span class="hljs-number" >3</span>;
  }
  
  <span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >C</span>();
  assert.<span class="hljs-title function_" >equal</span>(
    inst.<span class="hljs-property" >field</span>, <span class="hljs-number" >6</span>
  );
  </code></pre>
      <h3 id="read-only-fields" tabindex="-1">Example: read-only fields (instance public fields)&nbsp;&nbsp;<a class="heading-anchor" href="#read-only-fields" aria-hidden="true">#</a></h3>
      <p>The decorator <code>@readOnly</code> makes a field immutable. It waits until the field was completely set up (either via an assignment or via the constructor) before it does so.</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >const</span> readOnlyFieldKeys = <span class="hljs-title class_" >Symbol</span>(<span class="hljs-string" >'readOnlyFieldKeys'</span>);
  
  @readOnly
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Color</span> {
    @readOnly
    name;
    <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >name</span>) {
      <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >name</span> = name;
    }
  }
  
  <span class="hljs-keyword" >const</span> blue = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>(<span class="hljs-string" >'blue'</span>);
  assert.<span class="hljs-title function_" >equal</span>(blue.<span class="hljs-property" >name</span>, <span class="hljs-string" >'blue'</span>);
  assert.<span class="hljs-title function_" >throws</span>(
    <span class="hljs-function" >() =&gt;</span> blue.<span class="hljs-property" >name</span> = <span class="hljs-string" >'brown'</span>,
    <span class="hljs-regexp" >/^TypeError: Cannot assign to read only property 'name'/</span>
  );
  
  <span class="hljs-keyword" >function</span> <span class="hljs-title function_" >readOnly</span>(<span class="hljs-params" >value, {kind, name}</span>) {
    <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'field'</span>) { <span class="hljs-comment" >// (A)</span>
      <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" ></span>) {
        <span class="hljs-keyword" >if</span> (!<span class="hljs-variable language_" >this</span>[readOnlyFieldKeys]) {
          <span class="hljs-variable language_" >this</span>[readOnlyFieldKeys] = [];
        }
        <span class="hljs-variable language_" >this</span>[readOnlyFieldKeys].<span class="hljs-title function_" >push</span>(name);
      };
    }
    <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'class'</span>) { <span class="hljs-comment" >// (B)</span>
      <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" >...args</span>) {
        <span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >value</span>(...args);
        <span class="hljs-keyword" >for</span> (<span class="hljs-keyword" >const</span> key <span class="hljs-keyword" >of</span> inst[readOnlyFieldKeys]) {
          <span class="hljs-title class_" >Object</span>.<span class="hljs-title function_" >defineProperty</span>(inst, key, {<span class="hljs-attr" >writable</span>: <span class="hljs-literal" >false</span>});
        }
        <span class="hljs-keyword" >return</span> inst;
      }
    }
  }
  </code></pre>
      <p>We need two steps to implement the functionality of <code>@readOnly</code> (which is why the class is also decorated):</p>
      <ul>
        <li>We first collect all keys of read-only fields (line A).</li>
        <li>Then we wait until the instance was completely set up and make the fields, whose keys we collected, non-writable (line B). We need to wrap the class because decorator initializers are executed too early.</li>
      </ul>
      <p>Similarly to making instances immutable, this decorator breaks <code>instanceof</code>. The same workaround can be used here, too.</p>
      <p>We’ll later see <a href="#read-only-auto-accessors">a version <code>@readOnly</code> that works with auto-accessors</a> instead of fields. That implementation does not require the class to be decorated.</p>
      <h3 id="example%3A-dependency-injection-(instance-public-fields)" tabindex="-1">Example: dependency injection (instance public fields)&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-dependency-injection-(instance-public-fields)" aria-hidden="true">#</a></h3>
      <p><em>Dependency injection</em> is motivated by the following observation: If we provide the constructor of a class with its dependencies (vs. the constructor setting them up itself), then it’s easier to adapt the dependencies to different environments, including testing.</p>
      <p>This is an <em>inversion of control</em>: The constructor does not do its own setup, we do it for it. Approaches for doing dependency injection:</p>
      <ol>
        <li>Manually, by creating dependencies and passing them to the constructor.</li>
        <li>Via “contexts” in frontend frameworks such as React</li>
        <li>Via decorators and a <em>dependency injection registry</em> (a minor variation of <em>dependency injection containers</em>)</li>
      </ol>
      <p>The following code is a simple implementation of approach #3:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >const</span> {registry, inject} = <span class="hljs-title function_" >createRegistry</span>();
  
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Logger</span> {
    <span class="hljs-title function_" >log</span>(<span class="hljs-params" >str</span>) {
      <span class="hljs-variable language_" >console</span>.<span class="hljs-title function_" >log</span>(str);
    }
  }
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Main</span> {
    @inject logger;
    <span class="hljs-title function_" >run</span>(<span class="hljs-params" ></span>) {
      <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >logger</span>.<span class="hljs-title function_" >log</span>(<span class="hljs-string" >'Hello!'</span>);
    }
  }
  
  registry.<span class="hljs-title function_" >register</span>(<span class="hljs-string" >'logger'</span>, <span class="hljs-title class_" >Logger</span>);
  <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Main</span>().<span class="hljs-title function_" >run</span>();
  
  <span class="hljs-comment" >// Output:</span>
  <span class="hljs-comment" >// Hello!</span>
  </code></pre>
      <p>This is how <code>createRegistry()</code> is implemented:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >createRegistry</span>(<span class="hljs-params" ></span>) {
    <span class="hljs-keyword" >const</span> nameToClass = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Map</span>();
    <span class="hljs-keyword" >const</span> nameToInstance = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Map</span>();
    <span class="hljs-keyword" >const</span> registry = {
      <span class="hljs-title function_" >register</span>(<span class="hljs-params" >name, componentClass</span>) {
        nameToClass.<span class="hljs-title function_" >set</span>(name, componentClass);
      },
      <span class="hljs-title function_" >getInstance</span>(<span class="hljs-params" >name</span>) {
        <span class="hljs-keyword" >if</span> (nameToInstance.<span class="hljs-title function_" >has</span>(name)) {
          <span class="hljs-keyword" >return</span> nameToInstance.<span class="hljs-title function_" >get</span>(name);
        }
        <span class="hljs-keyword" >const</span> componentClass = nameToClass.<span class="hljs-title function_" >get</span>(name);
        <span class="hljs-keyword" >if</span> (componentClass === <span class="hljs-literal" >undefined</span>) {
          <span class="hljs-keyword" >throw</span> <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Error</span>(<span class="hljs-string" >'Unknown component name: '</span> + name);
        }
        <span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >componentClass</span>();
        nameToInstance.<span class="hljs-title function_" >set</span>(name, inst);
        <span class="hljs-keyword" >return</span> inst;
      },
    }; 
    <span class="hljs-keyword" >function</span> <span class="hljs-title function_" >inject</span> (<span class="hljs-params" >_value, {kind, name}</span>) {
      <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'field'</span>) {
        <span class="hljs-keyword" >return</span> <span class="hljs-function" >() =&gt;</span> registry.<span class="hljs-title function_" >getInstance</span>(name);
      }
    }
    <span class="hljs-keyword" >return</span> {registry, inject};
  }
  </code></pre>
      <h3 id="example-friend-visibility" tabindex="-1">Example: “friend”&nbsp;visibility (instance private fields)&nbsp;&nbsp;<a class="heading-anchor" href="#example-friend-visibility" aria-hidden="true">#</a></h3>
      <p>We can change the visibility of some class members by making them private. That prevents them from being accessed publicly. There are more useful kinds of visibility, though. For example, <em>friend visibility</em> lets a group of <em>friends</em> (functions, other classes, etc.) access the member.</p>
      <p>There are many ways in which friends can be specified. In the following example, everyone who has access to <code>friendName</code>, is a friend of <code>classWithSecret.#name</code>. The idea is that a module contains classes and functions that collaborate and that there is some instance data that only the collaborators should be able see.</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >const</span> friendName = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Friend</span>();
  
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >ClassWithSecret</span> {
    @friendName.<span class="hljs-property" >install</span> #name = <span class="hljs-string" >'Rumpelstiltskin'</span>;
    <span class="hljs-title function_" >getName</span>(<span class="hljs-params" ></span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-variable language_" >this</span>.#name;
    }
  }
  
  <span class="hljs-comment" >// Everyone who has access to `secret`, can access inst.#name</span>
  <span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >ClassWithSecret</span>();
  assert.<span class="hljs-title function_" >equal</span>(
    friendName.<span class="hljs-title function_" >get</span>(inst), <span class="hljs-string" >'Rumpelstiltskin'</span>
  );
  friendName.<span class="hljs-title function_" >set</span>(inst, <span class="hljs-string" >'Joe'</span>);
  assert.<span class="hljs-title function_" >equal</span>(
    inst.<span class="hljs-title function_" >getName</span>(), <span class="hljs-string" >'Joe'</span>
  );
  </code></pre>
      <p>This is how class <code>Friend</code> is implemented:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Friend</span> {
    #access = <span class="hljs-literal" >undefined</span>;
    #<span class="hljs-title function_" >getAccessOrThrow</span>(<span class="hljs-params" ></span>) {
      <span class="hljs-keyword" >if</span> (<span class="hljs-variable language_" >this</span>.#access === <span class="hljs-literal" >undefined</span>) {
        <span class="hljs-keyword" >throw</span> <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Error</span>(<span class="hljs-string" >'The friend decorator wasn’t used yet'</span>);
      }
      <span class="hljs-keyword" >return</span> <span class="hljs-variable language_" >this</span>.#access;
    }
    <span class="hljs-comment" >// An instance property whose value is a function whose `this`</span>
    <span class="hljs-comment" >// is fixed (bound to the instance).</span>
    install = <span class="hljs-function" >(<span class="hljs-params" >_value, {kind, access}</span>) =&gt;</span> {
      <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'field'</span>) {
        <span class="hljs-keyword" >if</span> (<span class="hljs-variable language_" >this</span>.#access) {
          <span class="hljs-keyword" >throw</span> <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Error</span>(<span class="hljs-string" >'This decorator can only be used once'</span>);
        }
        <span class="hljs-variable language_" >this</span>.#access = access;
      }
    }
    <span class="hljs-title function_" >get</span>(<span class="hljs-params" >inst</span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-variable language_" >this</span>.#<span class="hljs-title function_" >getAccessOrThrow</span>().<span class="hljs-property" >get</span>.<span class="hljs-title function_" >call</span>(inst);
    }
    <span class="hljs-title function_" >set</span>(<span class="hljs-params" >inst, value</span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-variable language_" >this</span>.#<span class="hljs-title function_" >getAccessOrThrow</span>().<span class="hljs-property" >set</span>.<span class="hljs-title function_" >call</span>(inst, value);
    }
  }
  </code></pre>
      <h3 id="example%3A-enums-(static-public-fields)" tabindex="-1">Example: enums (static public fields)&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-enums-(static-public-fields)" aria-hidden="true">#</a></h3>
      <p>There are many ways to implement enums. An OOP-style approach is to use a class and static properties (<a href="https://2ality.com/2016/01/enumify.html">more information on this approach</a>):</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Color</span> {
    <span class="hljs-keyword" >static</span> red = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>(<span class="hljs-string" >'red'</span>);
    <span class="hljs-keyword" >static</span> green = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>(<span class="hljs-string" >'green'</span>);
    <span class="hljs-keyword" >static</span> blue = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>(<span class="hljs-string" >'blue'</span>);
    <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >enumKey</span>) {
      <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >enumKey</span> = enumKey;
    }
    <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-string" >`Color(<span class="hljs-subst" >${<span class="hljs-variable language_" >this</span>.enumKey}</span>)`</span>;
    }
  }
  assert.<span class="hljs-title function_" >equal</span>(
    <span class="hljs-title class_" >Color</span>.<span class="hljs-property" >green</span>.<span class="hljs-title function_" >toString</span>(),
    <span class="hljs-string" >'Color(green)'</span>
  );
  </code></pre>
      <p>We can use a decorator to automatically:</p>
      <ul>
        <li>Create a Map from “enum keys” (the names of their fields) to enum values.</li>
        <li>Add enum keys to enum values – without having to pass them to the constructor.</li>
      </ul>
      <p>That looks as follows:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >function</span> <span class="hljs-title function_" >enumEntry</span>(<span class="hljs-params" >value, {kind, name}</span>) {
    <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'field'</span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-keyword" >function</span> (<span class="hljs-params" >initialValue</span>) {
        <span class="hljs-keyword" >if</span> (!<span class="hljs-title class_" >Object</span>.<span class="hljs-title function_" >hasOwn</span>(<span class="hljs-variable language_" >this</span>, <span class="hljs-string" >'enumFields'</span>)) {
          <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >enumFields</span> = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Map</span>();
        }
        <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >enumFields</span>.<span class="hljs-title function_" >set</span>(name, initialValue);
        initialValue.<span class="hljs-property" >enumKey</span> = name;
        <span class="hljs-keyword" >return</span> initialValue;
      };
    }
  }
  
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Color</span> {
    @enumEntry <span class="hljs-keyword" >static</span> red = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>();
    @enumEntry <span class="hljs-keyword" >static</span> green = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>();
    @enumEntry <span class="hljs-keyword" >static</span> blue = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>();
    <span class="hljs-title function_" >toString</span>(<span class="hljs-params" ></span>) {
      <span class="hljs-keyword" >return</span> <span class="hljs-string" >`Color(<span class="hljs-subst" >${<span class="hljs-variable language_" >this</span>.enumKey}</span>)`</span>;
    }
  }
  assert.<span class="hljs-title function_" >equal</span>(
    <span class="hljs-title class_" >Color</span>.<span class="hljs-property" >green</span>.<span class="hljs-title function_" >toString</span>(),
    <span class="hljs-string" >'Color(green)'</span>
  );
  assert.<span class="hljs-title function_" >deepEqual</span>(
    <span class="hljs-title class_" >Color</span>.<span class="hljs-property" >enumFields</span>,
    <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Map</span>([
      [<span class="hljs-string" >'red'</span>, <span class="hljs-title class_" >Color</span>.<span class="hljs-property" >red</span>],
      [<span class="hljs-string" >'green'</span>, <span class="hljs-title class_" >Color</span>.<span class="hljs-property" >green</span>],
      [<span class="hljs-string" >'blue'</span>, <span class="hljs-title class_" >Color</span>.<span class="hljs-property" >blue</span>],
    ])
  );
  </code></pre>
      <h2 id="auto-accessors" tabindex="-1">Auto-accessors: a new member of class definitions&nbsp;&nbsp;<a class="heading-anchor" href="#auto-accessors" aria-hidden="true">#</a></h2>
      <p>The decorators proposal introduces a new language feature: <em>auto-accessors</em>. An auto-accessor is created by putting the keyword <code>accessor</code> before a class field. It is used like a field but implemented differently at runtime. That helps decorators as we’ll see soon. This is what auto-accessors look like:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
    <span class="hljs-keyword" >static</span> accessor myField1;
    <span class="hljs-keyword" >static</span> accessor #myField2;
    accessor myField3;
    accessor #myField4;
  }
  </code></pre>
      <p>How do fields and auto-accessors differ?</p>
      <ul>
        <li>A field creates either:
          <ul>
            <li>Properties (static or instance)</li>
            <li>Private slots (static or instance)</li>
          </ul>
        </li>
        <li>An auto-accessor creates a private slot (static or instance) for the data and:
          <ul>
            <li>A public getter-setter pair (static or prototype)</li>
            <li>A private getter-setter pair (static or instance)
              <ul>
                <li>Private slots are not inherited and therefore never located in prototypes.</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <p>Consider the following class:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
    accessor str = <span class="hljs-string" >'abc'</span>;
  }
  <span class="hljs-keyword" >const</span> inst = <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >C</span>();
  assert.<span class="hljs-title function_" >equal</span>(
    inst.<span class="hljs-property" >str</span>, <span class="hljs-string" >'abc'</span>
  );
  inst.<span class="hljs-property" >str</span> = <span class="hljs-string" >'def'</span>;
  assert.<span class="hljs-title function_" >equal</span>(
    inst.<span class="hljs-property" >str</span>, <span class="hljs-string" >'def'</span>
  );
  </code></pre>
      <p>Internally, it looks like this:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
    #str = <span class="hljs-string" >'abc'</span>;
    <span class="hljs-keyword" >get</span> <span class="hljs-title function_" >str</span>() {
      <span class="hljs-keyword" >return</span> <span class="hljs-variable language_" >this</span>.#str;
    }
    <span class="hljs-keyword" >set</span> <span class="hljs-title function_" >str</span>(<span class="hljs-params" >value</span>) {
      <span class="hljs-variable language_" >this</span>.#str = value;
    }
  }
  </code></pre>
      <p>The following code shows where the getters and setters of auto-accessors are located:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >class</span> <span class="hljs-title class_" >C</span> {
    <span class="hljs-keyword" >static</span> accessor myField1;
    <span class="hljs-keyword" >static</span> accessor #myField2;
    accessor myField3;
    accessor #myField4;
  
    <span class="hljs-keyword" >static</span> {
      <span class="hljs-comment" >// Static getter and setter</span>
      assert.<span class="hljs-title function_" >ok</span>(
        <span class="hljs-title class_" >Object</span>.<span class="hljs-title function_" >hasOwn</span>(C, <span class="hljs-string" >'myField1'</span>), <span class="hljs-string" >'myField1'</span>
      );
      <span class="hljs-comment" >// Static getter and setter</span>
      assert.<span class="hljs-title function_" >ok</span>(
        #myField2 <span class="hljs-keyword" >in</span> C, <span class="hljs-string" >'#myField2'</span>
      );
  
      <span class="hljs-comment" >// Prototype getter and setter</span>
      assert.<span class="hljs-title function_" >ok</span>(
        <span class="hljs-title class_" >Object</span>.<span class="hljs-title function_" >hasOwn</span>(C.<span class="hljs-property" ><span class="hljs-keyword" >prototype</span></span>, <span class="hljs-string" >'myField3'</span>), <span class="hljs-string" >'myField3'</span>
      );
      <span class="hljs-comment" >// Private getter and setter</span>
      <span class="hljs-comment" >// (stored in instances, but shared between instances)</span>
      assert.<span class="hljs-title function_" >ok</span>(
        #myField4 <span class="hljs-keyword" >in</span> <span class="hljs-keyword" >new</span> <span class="hljs-title function_" >C</span>(), <span class="hljs-string" >'#myField4'</span>
      );
    }
  }
  </code></pre>
      <p>For more information on why the slots of private getters, private setters and private methods are stored in instances, see <a href="https://exploringjs.com/js/book/ch_classes.html#private-methods-accessors">section “Private methods and accessors”</a> in “Exploring JavaScript”.</p>
      <h3 id="why-are-auto-accessors-needed%3F" tabindex="-1">Why are auto-accessors needed?&nbsp;&nbsp;<a class="heading-anchor" href="#why-are-auto-accessors-needed%3F" aria-hidden="true">#</a></h3>
      <p>Auto-accessors are needed by decorators:</p>
      <ul>
        <li>They can only influence the values fields are initialized with.</li>
        <li>But they can completely replace auto-accessors.</li>
      </ul>
      <p>Therefore, we have to use auto-accessors instead of fields whenever a decorator needs more control than it has with fields.</p>
      <h2 id="class-auto-accessor-decorators" tabindex="-1">Class auto-accessor decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-auto-accessor-decorators" aria-hidden="true">#</a></h2>
      <p>Class auto-accessor decorators have the following type signature:</p>
      <pre><code class="language-ts" ><span class="hljs-keyword" >type</span> <span class="hljs-title class_" >ClassAutoAccessorDecorator</span> = <span class="hljs-function" >(<span class="hljs-params" >
    <span class="hljs-attr" >value</span>: {
      get: () =&gt; <span class="hljs-built_in" >unknown</span>;
      set: (value: <span class="hljs-built_in" >unknown</span>) =&gt; <span class="hljs-built_in" >void</span>;
    },
    <span class="hljs-attr" >context</span>: {
      kind: <span class="hljs-string" >'accessor'</span>;
      name: <span class="hljs-built_in" >string</span> | <span class="hljs-built_in" >symbol</span>;
      <span class="hljs-keyword" >static</span>: <span class="hljs-built_in" >boolean</span>;
      <span class="hljs-keyword" >private</span>: <span class="hljs-built_in" >boolean</span>;
      access: { get: () =&gt; <span class="hljs-built_in" >unknown</span>, set: (value: <span class="hljs-built_in" >unknown</span>) =&gt; <span class="hljs-built_in" >void</span> };
      addInitializer(initializer: () =&gt; <span class="hljs-built_in" >void</span>): <span class="hljs-built_in" >void</span>;
    }
  </span>) =&gt;</span> {
    <span class="hljs-attr" >get</span>?: <span class="hljs-function" >() =&gt;</span> <span class="hljs-built_in" >unknown</span>;
    <span class="hljs-attr" >set</span>?: <span class="hljs-function" >(<span class="hljs-params" ><span class="hljs-attr" >value</span>: <span class="hljs-built_in" >unknown</span></span>) =&gt;</span> <span class="hljs-built_in" >void</span>;
    <span class="hljs-attr" >init</span>?: <span class="hljs-function" >(<span class="hljs-params" ><span class="hljs-attr" >initialValue</span>: <span class="hljs-built_in" >unknown</span></span>) =&gt;</span> <span class="hljs-built_in" >unknown</span>;
  } | <span class="hljs-built_in" >void</span>;
  </code></pre>
      <p>Abilities of an auto-accessor decorator:</p>
      <ul>
        <li>It receives the getter and the setter of the auto-accessor via its parameter <code>value</code>.
          <ul>
            <li><code>context.access</code> provides the same functionality.</li>
          </ul>
        </li>
        <li>It can replace the decorated auto-accessor by returning an object with the methods <code>.get()</code> and/or <code>.set()</code>.</li>
        <li>It can influence the initial value of the auto-accessor by returning an object with the method <code>.init()</code>.</li>
        <li>It can register initializers.</li>
      </ul>
      <h3 id="read-only-auto-accessors" tabindex="-1">Example: read-only auto-accessors&nbsp;&nbsp;<a class="heading-anchor" href="#read-only-auto-accessors" aria-hidden="true">#</a></h3>
      <p>We have already implemented <a href="#read-only-fields">a decorator <code>@readOnly</code> for fields</a>. Let’s do the same for auto-accessors:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >const</span> <span class="hljs-variable constant_" >UNINITIALIZED</span> = <span class="hljs-title class_" >Symbol</span>(<span class="hljs-string" >'UNINITIALIZED'</span>);
  <span class="hljs-keyword" >function</span> <span class="hljs-title function_" >readOnly</span>(<span class="hljs-params" >{get,set}, {name, kind}</span>) {
    <span class="hljs-keyword" >if</span> (kind === <span class="hljs-string" >'accessor'</span>) {
      <span class="hljs-keyword" >return</span> {
        <span class="hljs-title function_" >init</span>(<span class="hljs-params" ></span>) {
          <span class="hljs-keyword" >return</span> <span class="hljs-variable constant_" >UNINITIALIZED</span>;
        },
        <span class="hljs-title function_" >get</span>(<span class="hljs-params" ></span>) {
          <span class="hljs-keyword" >const</span> value = get.<span class="hljs-title function_" >call</span>(<span class="hljs-variable language_" >this</span>);
          <span class="hljs-keyword" >if</span> (value === <span class="hljs-variable constant_" >UNINITIALIZED</span>) {
            <span class="hljs-keyword" >throw</span> <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >TypeError</span>(
              <span class="hljs-string" >`Accessor <span class="hljs-subst" >${name}</span> hasn’t been initialized yet`</span>
            );
          }
          <span class="hljs-keyword" >return</span> value;
        },
        <span class="hljs-title function_" >set</span>(<span class="hljs-params" >newValue</span>) {
          <span class="hljs-keyword" >const</span> oldValue = get.<span class="hljs-title function_" >call</span>(<span class="hljs-variable language_" >this</span>);
          <span class="hljs-keyword" >if</span> (oldValue !== <span class="hljs-variable constant_" >UNINITIALIZED</span>) {
            <span class="hljs-keyword" >throw</span> <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >TypeError</span>(
              <span class="hljs-string" >`Accessor <span class="hljs-subst" >${name}</span> can only be set once`</span>
            );
          }
          set.<span class="hljs-title function_" >call</span>(<span class="hljs-variable language_" >this</span>, newValue);
        },
      };
    }
  }
  
  <span class="hljs-keyword" >class</span> <span class="hljs-title class_" >Color</span> {
    @readOnly
    accessor name;
    <span class="hljs-title function_" >constructor</span>(<span class="hljs-params" >name</span>) {
      <span class="hljs-variable language_" >this</span>.<span class="hljs-property" >name</span> = name;
    }
  }
  
  <span class="hljs-keyword" >const</span> blue = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>(<span class="hljs-string" >'blue'</span>);
  assert.<span class="hljs-title function_" >equal</span>(blue.<span class="hljs-property" >name</span>, <span class="hljs-string" >'blue'</span>);
  assert.<span class="hljs-title function_" >throws</span>(
    <span class="hljs-function" >() =&gt;</span> blue.<span class="hljs-property" >name</span> = <span class="hljs-string" >'yellow'</span>,
    <span class="hljs-regexp" >/^TypeError: Accessor name can only be set once$/</span>
  );
  
  <span class="hljs-keyword" >const</span> orange = <span class="hljs-keyword" >new</span> <span class="hljs-title class_" >Color</span>(<span class="hljs-string" >'orange'</span>);
  assert.<span class="hljs-title function_" >equal</span>(orange.<span class="hljs-property" >name</span>, <span class="hljs-string" >'orange'</span>);
  </code></pre>
      <p>Compared to the field version, this decorator has one considerable advantage: It does not need to wrap the class to ensure that the decorated constructs become read-only.</p>
      <h2 id="faq" tabindex="-1">Frequently asked questions&nbsp;&nbsp;<a class="heading-anchor" href="#faq" aria-hidden="true">#</a></h2>
      <h3 id="function-decorators" tabindex="-1">Why can’t functions be decorated?&nbsp;&nbsp;<a class="heading-anchor" href="#function-decorators" aria-hidden="true">#</a></h3>
      <p>The current proposal focuses on classes as a starting point. <a href="#more-decorator-related-proposals">Decorators for function expressions were proposed.</a> However, there hasn’t been much progress since then and there is no proposal for function <em>declarations</em>.</p>
      <p>On the other hand, functions are relatively easy to decorate “manually”:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >const</span> decoratedFunc = <span class="hljs-title function_" >decorator</span>(<span class="hljs-function" >(<span class="hljs-params" >x, y</span>) =&gt;</span> {});
  </code></pre>
      <p>This looks even better with <a href="https://2ality.com/2022/01/pipe-operator.html">the proposed pipeline operator</a>:</p>
      <pre><code class="language-js" ><span class="hljs-keyword" >const</span> <span class="hljs-title function_" >decoratedFunc</span> = (<span class="hljs-params" >x, y</span>) =&gt; {} |&gt; <span class="hljs-title function_" >decorator</span>(%);
  </code></pre>
      <h2 id="more-decorator-related-proposals" tabindex="-1">More decorator-related proposals&nbsp;&nbsp;<a class="heading-anchor" href="#more-decorator-related-proposals" aria-hidden="true">#</a></h2>
      <p>The following ECMAScript proposals provide more decorator-related features:</p>
      <ul>
        <li>Stage 2: <a href="https://github.com/tc39/proposal-decorator-metadata">“Decorator Metadata”</a> by Chris Garrett (last update: 2022-04-11)
          <ul>
            <li>Quote: “This proposal seeks to extend the Decorators proposal by adding the ability for decorators to associate metadata with the value being decorated.”</li>
          </ul>
        </li>
        <li>Stage 0: <a href="https://docs.google.com/document/d/1ikxIP5-RVYq6d_f8lAvf3pKC00W78ueyp-xIZ6q67uU">“Function Expression Decorators”</a> by Igor Minar (last update: 2016-01-25)</li>
        <li>Stage 0: <a href="https://docs.google.com/document/d/1Qpkqf_8NzAwfD8LdnqPjXAQ2wwh8BBUGynhn-ZlCWT0">“Method Parameter Decorators”</a> by Igor Minar (last update: 2016-01-25)</li>
      </ul>
      <h2 id="resources" tabindex="-1">Resources&nbsp;&nbsp;<a class="heading-anchor" href="#resources" aria-hidden="true">#</a></h2>
      <h3 id="decorator-implementations" tabindex="-1">Implementations&nbsp;&nbsp;<a class="heading-anchor" href="#decorator-implementations" aria-hidden="true">#</a></h3>
      <ul>
        <li>Babel currently has the best support for stage 3 decorators, via <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators"><code>@babel/plugin-proposal-decorators</code></a>.
          <ul>
            <li>Be sure to pick <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators#version">the latest decorator version</a>.</li>
            <li>All the code in this blog post was developed via Babel.</li>
          </ul>
        </li>
        <li>TypeScript currently supports stage 1 decorators behind a flag.
          <ul>
            <li>There is <a href="https://github.com/microsoft/TypeScript/pull/50820">a pull request by Ron Buckton</a> that supports stage 3 decorators and will likely ship in the release after TypeScript 4.9.</li>
          </ul>
        </li>
      </ul>
      <h3 id="libraries-with-decorators" tabindex="-1">Libraries with decorators&nbsp;&nbsp;<a class="heading-anchor" href="#libraries-with-decorators" aria-hidden="true">#</a></h3>
      <p>These are libraries with decorators. They currently only support stage 1 decorators but can serve as inspirations for what’s possible:</p>
      <ul>
        <li><a href="https://github.com/jayphelps/core-decorators.js">core-decorators.js</a> by Jay Phelps (targets Babel)</li>
        <li><a href="https://github.com/NetanelBasal/helpful-decorators">“Helpful Decorators For TypeScript Projects”</a> by Netanel Basal</li>
      </ul>
      <h2 id="acknowledgements" tabindex="-1">Acknowledgements&nbsp;&nbsp;<a class="heading-anchor" href="#acknowledgements" aria-hidden="true">#</a></h2>
      <ul>
        <li>Thanks to Chris Garrett for answering my questions about decorators.</li>
      </ul>
      <h2 id="further-reading" tabindex="-1">Further reading&nbsp;&nbsp;<a class="heading-anchor" href="#further-reading" aria-hidden="true">#</a></h2>
      <ul>
        <li>
          <p><a href="https://exploringjs.com/js/book/ch_callables.html">Chapter “Callable values”</a> [ordinary functions, arrow functions, classes, methods] in “Exploring JavaScript”</p>
        </li>
        <li>
          <p><a href="https://exploringjs.com/js/book/ch_classes.html">Chapter “Classes”</a> in “Exploring JavaScript”</p>
        </li>
      </ul>
    </div>
  </div>

</body>
<script>
  const a = document.querySelectorAll('#page-core-content *');
  const b = document.querySelectorAll('#page-core-content2 *');
  console.log({ a: a.length, b: b.length });
  const len = Math.min(a.length, b.length);
  for (let i = 0; i < len; i++) {
    if (a[i].tagName !== b[i].tagName) {
      console.log(i, 'tag', a[i], b[i]);
      continue;
    }
    if (a[i].children?.length !== b[i].children?.length) {
      console.log(i, 'children', a[i], b[i]);
      continue;
    }

  }
</script>

</html>