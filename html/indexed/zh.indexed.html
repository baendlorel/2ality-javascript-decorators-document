<html lang="en-US" data-en="0">

<head data-en="1">
  <meta charset="utf-8" data-en="2">
  <meta name="viewport" content="width=device-width" data-en="3">
  <title>使用 2022-03 装饰器 API 进行 JavaScript 元编程</title>
</head>

<body data-en="5">
  <div id="page-core-content" class="number-headings" data-en="6">
    <h1 data-en="7">使用 2022-03 装饰器 API 进行 JavaScript 元编程</h1>
    <div data-en="8">
      <p data-en="9">JavaScript 装饰器终于进入了 <a href="https://exploringjs.com/js/book/ch_history.html#tc39-process">第 3 阶段</a>！最新版本已经被 Babel 支持，<a href="#decorator-implementations">很快也会被 TypeScript 支持</a>。</p>
      <p data-en="12">本文介绍了 ECMAScript 提案 <a href="https://github.com/tc39/proposal-decorators">“Decorators”</a>（2022-03 版本，第 3 阶段），作者为 Daniel Ehrenberg 和 Chris Garrett。</p>
      <p data-en="14">装饰器是以 <code>@</code> 符号开头的关键字，可以用于类和类成员（如方法）前。例如，<code>@trace</code> 就是一个装饰器：</p>
      <pre data-en="17"><code class="language-js" data-en="18"><span class="hljs-keyword" data-en="19">class</span> <span class="hljs-title class_" data-en="20">C</span> {
  @trace
  <span class="hljs-title function_" data-en="21">toString</span>(<span class="hljs-params" data-en="22"></span>) {
    <span class="hljs-keyword" data-en="23">return</span> <span class="hljs-string" data-en="24">'C'</span>;
  }
}
</code>
</pre>
      <p data-en="25">装饰器会改变被装饰结构的行为。在这个例子中，每次调用 <code>.toString()</code> 都会被“追踪”（参数和结果会被输出到控制台）。<a href="#example-tracing-method-invocations">稍后我们会看到 <code>@trace</code> 的实现。</a></p>
      <!--more-->
      <p data-en="29">装饰器主要是面向对象的特性，在 Ember、Angular、Vue、Web 组件框架和 MobX 等 OOP 框架和库中非常流行。</p>
      <p data-en="30">关于装饰器，有两个相关角色：</p>
      <ul data-en="31">
        <li data-en="32">库作者需要了解装饰器 API，以便实现它们。</li>
        <li data-en="33">库使用者只需知道如何应用装饰器。</li>
      </ul>
      <p data-en="34">本文主要面向库作者：我们将学习装饰器的工作原理，并用这些知识实现几个装饰器。</p>
      <nav class="table-of-contents" data-en="35">
        <ul>
          <li>
            <a href="#history-of-decorators">装饰器的历史（可选章节）</a>
            <ul>
              <li>
                <a href="#the-history-of-decorators">装饰器的历史</a>
              </li>
              <li>
                <a href="#the-history-of-babel%E2%80%99s-decorator-implementation">Babel 装饰器实现的历史</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#what-are-decorators%3F">什么是装饰器？</a>
            <ul>
              <li>
                <a href="#the-shape-of-decorator-functions">装饰器函数的结构</a>
              </li>
              <li>
                <a href="#what-can-decorators-do%3F">装饰器能做什么？</a>
              </li>
              <li>
                <a href="#summary-tables">总结表格</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)">装饰器语法与语义的更多信息（可选章节）</a>
            <ul>
              <li>
                <a href="#the-syntax-of-decorator-expressions">装饰器表达式的语法</a>
              </li>
              <li>
                <a href="#how-are-decorators-executed%3F">装饰器如何执行？</a>
              </li>
              <li>
                <a href="#decorator-initializer-execution">装饰器初始化器何时运行？</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#techniques-for-exposing-data-from-decorators">装饰器暴露数据的技巧</a>
            <ul>
              <li>
                <a href="#storing-exposed-data-in-a-surrounding-scope">在外部作用域存储暴露的数据</a>
              </li>
              <li>
                <a href="#managing-exposed-data-via-a-factory-function">通过工厂函数管理暴露的数据</a>
              </li>
              <li>
                <a href="#managing-exposed-data-via-a-class">通过类管理暴露的数据</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#class-decorators">类装饰器</a>
            <ul>
              <li>
                <a href="#example%3A-collecting-instances">示例：收集实例</a>
              </li>
              <li>
                <a href="#making-sure-that-instanceof-works">确保 <code>instanceof</code> 正常工作</a>
              </li>
              <li>
                <a href="#example-freezing-instances">示例：冻结实例</a>
              </li>
              <li>
                <a href="#example%3A-making-classes-function-callable">示例：让类可函数调用</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#class-method-decorators">类方法装饰器</a>
            <ul>
              <li>
                <a href="#example-tracing-method-invocations">示例：追踪方法调用</a>
              </li>
              <li>
                <a href="#example%3A-binding-methods-to-instances">示例：将方法绑定到实例</a>
              </li>
              <li>
                <a href="#example%3A-applying-functions-to-methods">示例：对方法应用函数</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#class-getter-decorators%2C-class-setter-decorators">类 getter 装饰器、setter 装饰器</a>
            <ul>
              <li>
                <a href="#example%3A-computing-values-lazily">示例：惰性计算值</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#class-field-decorators">类字段装饰器</a>
            <ul>
              <li>
                <a href="#example%3A-changing-initialization-values-of-fields">示例：改变字段初始化值</a>
              </li>
              <li>
                <a href="#read-only-fields">示例：只读字段（实例公有字段）</a>
              </li>
              <li>
                <a href="#example%3A-dependency-injection-(instance-public-fields)">示例：依赖注入（实例公有字段）</a>
              </li>
              <li>
                <a href="#example-friend-visibility">示例：“友元”可见性（实例私有字段）</a>
              </li>
              <li>
                <a href="#example%3A-enums-(static-public-fields)">示例：枚举（静态公有字段）</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#auto-accessors">自动访问器：类定义的新成员</a>
            <ul>
              <li>
                <a href="#why-are-auto-accessors-needed%3F">为什么需要自动访问器？</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#class-auto-accessor-decorators">类自动访问器装饰器</a>
            <ul>
              <li>
                <a href="#read-only-auto-accessors">示例：只读自动访问器</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#faq">常见问题</a>
            <ul>
              <li>
                <a href="#function-decorators">为什么函数不能被装饰？</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#more-decorator-related-proposals">更多与装饰器相关的提案</a>
          </li>
          <li>
            <a href="#resources">资源</a>
            <ul>
              <li>
                <a href="#decorator-implementations">实现</a>
              </li>
              <li>
                <a href="#libraries-with-decorators">带装饰器的库</a>
              </li>
            </ul>
          </li>
          <li>
            <a href="#acknowledgements">致谢</a>
          </li>
          <li>
            <a href="#further-reading">延伸阅读</a>
          </li>
        </ul>
      </nav>
      <h2 id="history-of-decorators" tabindex="-1" data-en="138">装饰器的历史（可选章节）&nbsp;&nbsp;<a class="heading-anchor" href="#history-of-decorators" aria-hidden="true">#</a></h2>
      <p data-en="140">(本章节为可选内容。如果您跳过此章节，仍然可以理解后续内容。)</p>
      <p data-en="141">让我们从装饰器的历史开始。主要回答以下两个问题：</p>
      <ul data-en="142">
        <li>为什么这个提案花了这么长时间？</li>
        <li>为什么感觉 JavaScript 似乎已经有装饰器很多年了？</li>
      </ul>
      <h3 id="the-history-of-decorators" tabindex="-1" data-en="145">装饰器的历史&nbsp;&nbsp;<a class="heading-anchor" href="#the-history-of-decorators" aria-hidden="true">#</a></h3>
      <p data-en="147">以下历史描述了：</p>
      <ul data-en="148">
        <li>各个团体如何在各自的项目中工作，并在 TC39 提案上进行协作。</li>
        <li>TC39 提案如何通过 <a href="https://exploringjs.com/js/book/ch_history.html#tc39-process">TC39 过程</a> 的各个阶段（从 0 开始，到 4 结束，提案准备添加到 ECMAScript 中）。在此过程中，提案经历了多次变更。</li>
      </ul>
      <p data-en="152">以下是相关事件的时间顺序：</p>
      <ul data-en="153">
        <li>
          <p><a href="https://github.com/tc39/notes/blob/main/meetings/2014-04/apr-10.md">2014-04-10</a>：Yehuda Katz 向 TC39 提出了装饰器提案。该提案晋升为第 0 阶段。</p>
          <ul>
            <li>Katz 的提案是与 Ron Buckton 合作创建的。关于该提案的讨论可以追溯到 <a href="https://twitter.com/rbuckton/status/1581292852532813825">2013 年 7 月</a>。</li>
          </ul>
        </li>
        <li>
          <p>2014-10-22（ngEurope 大会，巴黎）：Angular 团队宣布 Angular 2.0 正在使用 AtScript 编写，并编译为 JavaScript（通过 Traceur）和 Dart。计划包括基于 TypeScript 的 AtScript，同时添加：</p>
          <ul>
            <li>三种类型的 <em>注解</em>：
              <ul>
                <li><em>类型注解</em></li>
                <li><em>字段注解</em> 显式声明字段。</li>
                <li><em>元数据注解</em> 语法与装饰器相同，但仅添加元数据，不改变被注解结构的工作方式。</li>
              </ul>
            </li>
            <li>运行时类型检查</li>
            <li>类型反射</li>
          </ul>
        </li>
        <li>
          <p><a href="https://github.com/tc39/notes/blob/main/meetings/2015-01/jan-28.md">2015-01-28</a>：Yehuda Katz 和 Jonathan Turner 报告说 Katz 和 TypeScript 团队正在交流想法。</p>
        </li>
        <li>
          <p>2015-03-05（ng-conf，盐湖城）：Angular 团队和 TypeScript 团队宣布 Angular 将从 AtScript 切换到 TypeScript，并且 TypeScript 将采用 AtScript 的一些特性（特别是装饰器）。</p>
        </li>
        <li>
          <p><a href="https://github.com/tc39/notes/blob/main/meetings/2015-03/mar-24.md">2015-03-24</a>：装饰器提案进入第 1 阶段。彼时，他们在 GitHub 上有 <a href="https://github.com/wycats/javascript-decorators">一个仓库</a>（由 Yehuda Katz 创建），后来迁移到 <a href="https://github.com/tc39/proposal-decorators">当前所在位置</a>。</p>
        </li>
        <li>
          <p>2015-07-20：<a href="https://devblogs.microsoft.com/typescript/announcing-typescript-1-5/">TypeScript 1.5</a> 发布，支持通过 <a href="https://www.typescriptlang.org/docs/handbook/decorators.html">第 1 阶段装饰器</a>，需开启标志 <code>--experimentalDecorators</code>。</p>
          <p>多个 JavaScript 项目（如 Angular 和 MobX）使用了这个 TypeScript 特性，这使得 JavaScript 看起来已经有装饰器。</p>
          <p>到目前为止，TypeScript 尚未支持更新版本的装饰器 API。<a href="https://github.com/microsoft/TypeScript/pull/50820">Ron Buckton 的一个拉取请求提供了对第 3 阶段装饰器的支持</a>，可能会在 v4.9 之后的版本中发布。</p>
        </li>
        <li>
          <p><a href="https://github.com/tc39/notes/blob/main/meetings/2016-07/jul-28.md">2016-07-28</a>：在 Yehuda Katz 和 Brian Terlson 的介绍后，提案进入第 2 阶段。</p>
        </li>
        <li>
          <p><a href="https://github.com/tc39/notes/blob/main/meetings/2017-07/jul-27.md">2017-07-27</a>：Daniel Ehrenberg 在几个月前加入提案后首次进行了装饰器的介绍。他推动了提案的演变，持续了好几年。</p>
        </li>
        <li>
          <p>随后，Chris Garrett 加入了提案，并帮助其进入第 3 阶段，该阶段发生在 <a href="https://github.com/tc39/notes/blob/main/meetings/2022-03/mar-28.md">2022-03-28</a>。装饰器元数据被移至 <a href="https://github.com/tc39/proposal-decorator-metadata">一个单独的提案</a>，该提案从第 2 阶段开始。</p>
        </li>
      </ul>
      <p data-en="202">之所以花了很长时间才进入第 3 阶段，是因为很难让所有利益相关者就 API 达成一致。人们关心的包括与其他特性（如类成员和私有状态）的相互作用以及性能等问题。</p>
      <h3 id="the-history-of-babel%E2%80%99s-decorator-implementation" tabindex="-1" data-en="203">Babel 装饰器实现的历史&nbsp;&nbsp;<a class="heading-anchor" href="#the-history-of-babel%E2%80%99s-decorator-implementation" aria-hidden="true">#</a></h3>
      <p data-en="205">Babel 紧密跟踪了装饰器提案的演变，这要感谢 Logan Smyth、Nicolò Ribaudo 和其他人的努力：</p>
      <ul data-en="206">
        <li>
          <p><a href="https://babeljs.io/blog/2015/03/31/5.0.0">2015-03-31</a>：Babel 5.0.0 支持第 1 阶段装饰器。</p>
        </li>
        <li>
          <p><a href="https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy">2015-11-29</a> Logan Smyth 的一个外部插件将第 1 阶段装饰器带到了 Babel 6。</p>
        </li>
        <li>
          <p><a href="https://babeljs.io/blog/2018/08/27/7.0.0">2018-08-27</a> Babel 7.0.0 通过官方的 <code>@babel/plugin-proposal-decorators</code> 支持第 2 阶段装饰器。</p>
        </li>
        <li>
          <p>官方插件目前支持 <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators#version">以下版本</a>：</p>
          <ul>
            <li><code>"legacy"</code>: <a href="https://github.com/wycats/javascript-decorators/blob/e1bf8d41bfa2591d949dd3bbf013514c8904b913/README.md">第 1 阶段装饰器</a></li>
            <li><code>"2018-09"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/7fa580b40f2c19c561511ea2c978e307ae689a1b">第 2 阶段装饰器</a></li>
            <li><code>"2021-12"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/d6c056fa061646178c34f361bad33d583316dc85">第 2 阶段装饰器的更新版本</a></li>
            <li><code>"2022-03"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/8ca65c046dd5e9aa3846a1fe5df343a6f7efd9f8">第 3 阶段装饰器</a></li>
          </ul>
        </li>
      </ul>
      <h2 id="what-are-decorators%3F" tabindex="-1" data-en="233">什么是装饰器？&nbsp;&nbsp;<a class="heading-anchor" href="#what-are-decorators%3F" aria-hidden="true" data-en="234">#</a></h2>
      <p data-en="235">装饰器让我们可以改变 JavaScript 结构（如类和方法）的工作方式。让我们回顾一下使用装饰器 <code data-en="236">@trace</code>:</p>
      <pre data-en="237"><code class="language-js" data-en="238"><span class="hljs-keyword" data-en="239">class</span> <span class="hljs-title class_" data-en="240">C</span> {
  @trace
  <span class="hljs-title function_" data-en="241">toString</span>(<span class="hljs-params" data-en="242"></span>) {
    <span class="hljs-keyword" data-en="243">return</span> <span class="hljs-string" data-en="244">'C'</span>;
  }
}
</code></pre>
      <p data-en="245">要实现 <code>@trace</code>，我们只需编写一个函数 (<a href="#example-tracing-method-invocations" data-en="247">确切的实现稍后会展示</a>):</p>
      <pre data-en="248"><code class="language-js" data-en="249"><span class="hljs-keyword" data-en="250">function</span> <span class="hljs-title function_" data-en="251">trace</span>(<span class="hljs-params" data-en="252">decoratedMethod</span>) {
  <span class="hljs-comment" data-en="253">// // 返回一个替换 `decoratedMethod` 的函数。</span>
}
</code></pre>
      <p data-en="254">带有装饰器方法的类大致等同于以下代码：</p>
      <pre data-en="255"><code class="language-js" data-en="256"><span class="hljs-keyword" data-en="257">class</span> <span class="hljs-title class_" data-en="258">C</span> {
  <span class="hljs-title function_" data-en="259">toString</span>(<span class="hljs-params" data-en="260"></span>) {
    <span class="hljs-keyword" data-en="261">return</span> <span class="hljs-string" data-en="262">'C'</span>;
  }
}
C.<span class="hljs-property" data-en="263"><span class="hljs-keyword" data-en="264">prototype</span></span>.<span class="hljs-property" data-en="265">toString</span> = <span class="hljs-title function_" data-en="266">trace</span>(C.<span class="hljs-property" data-en="267"><span class="hljs-keyword" data-en="268">prototype</span></span>.<span class="hljs-property" data-en="269">toString</span>);
</code></pre>
      <p data-en="270">换句话说：装饰器是一个可以应用于语言结构的函数。我们通过在它们前面加上 <code>@</code> 和它的名字来实现这一点。</p>
      <p data-en="272">编写和使用装饰器是<em>元编程</em>：</p>
      <ul data-en="274">
        <li>我们不是编写处理用户数据的代码（<em>编程</em>）。</li>
        <li>我们编写处理处理用户数据的代码（<em>元编程</em>）。</li>
      </ul>
      <p data-en="279">有关元编程的更多信息，请参见“深度 JavaScript”中的<a href="https://exploringjs.com/deep-js/ch_proxies.html#programming-vs-metaprogramming" data-en="280">“编程与元编程”部分</a>。</p>
      <h3 id="the-shape-of-decorator-functions" tabindex="-1" data-en="281">装饰器函数的结构&nbsp;&nbsp;<a class="heading-anchor" href="#the-shape-of-decorator-functions" aria-hidden="true" data-en="282">#</a></h3>
      <p data-en="283">在我们探索装饰器函数的示例之前，我想先看看它们的 TypeScript 类型签名：</p>
      <pre data-en="284"><code class="language-ts" data-en="285"><span class="hljs-keyword" data-en="286">type</span> <span class="hljs-title class_" data-en="287">Decorator</span> = <span class="hljs-function" data-en="288">(<span class="hljs-params" data-en="289">
  <span class="hljs-attr" data-en="290">value</span>: <span class="hljs-title class_" data-en="291">DecoratedValue</span>, <span class="hljs-comment" data-en="292">// 字段不同</span>
  <span class="hljs-attr" data-en="293">context</span>: {
    kind: <span class="hljs-built_in" data-en="294">string</span>;
    name: <span class="hljs-built_in" data-en="295">string</span> | <span class="hljs-built_in" data-en="296">symbol</span>;
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" data-en="297">void</span>): <span class="hljs-built_in" data-en="298">void</span>;

    // Don’t always exist:
    <span class="hljs-keyword" data-en="299">static</span>: <span class="hljs-built_in" data-en="300">boolean</span>;
    <span class="hljs-keyword" data-en="301">private</span>: <span class="hljs-built_in" data-en="302">boolean</span>;
    access: {get: () =&gt; <span class="hljs-built_in" data-en="303">unknown</span>, set: (value: <span class="hljs-built_in" data-en="304">unknown</span>) =&gt; <span class="hljs-built_in" data-en="305">void</span>};
  }
</span>) =&gt;</span> <span class="hljs-built_in" data-en="306">void</span> | <span class="hljs-title class_" data-en="307">ReplacementValue</span>; <span class="hljs-comment" data-en="308">// 仅字段不同</span>
</code></pre>
      <p data-en="309">也就是说，装饰器就是一个函数。它的参数是：</p>
      <ul data-en="310">
        <li>装饰器应用于的 <code>value</code>。</li>
        <li>包含 <code>value</code> 附加信息的对象 <code>context</code>，具有：
          <ul>
            <li>关于 <code>value</code> 的附加信息（<code>.static</code>、<code>.private</code>）</li>
            <li>一个小型 API（<code>.access</code>、<code>.addInitializer</code>），具有元编程功能</li>
          </ul>
        </li>
      </ul>
      <p data-en="323">属性 <code>.kind</code> 告诉装饰器它被应用于哪种类型的 JavaScript 结构。我们可以对多种结构使用相同的函数。</p>
      <p data-en="325">目前，装饰器可以应用于类、方法、getter、setter、字段和 <em>自动访问器</em>（稍后将解释的一种新类成员）。<code>.kind</code> 的值反映了这一点：</p>
      <ul data-en="329">
        <li data-en="330"><code data-en="331">'class'</code></li>
        <li data-en="332"><code data-en="333">'method'</code></li>
        <li data-en="334"><code data-en="335">'getter'</code></li>
        <li data-en="336"><code data-en="337">'setter'</code></li>
        <li data-en="338"><code data-en="339">'accessor'</code></li>
        <li data-en="340"><code data-en="341">'field'</code></li>
      </ul>
      <p data-en="342">以下是 <code>Decorator</code> 的确切类型：</p>
      <pre data-en="344"><code class="language-ts" data-en="345"><span class="hljs-keyword" data-en="346">type</span> <span class="hljs-title class_" data-en="347">Decorator</span> =
  | <span class="hljs-title class_" data-en="348">ClassDecorator</span>
  | <span class="hljs-title class_" data-en="349">ClassMethodDecorator</span>
  | <span class="hljs-title class_" data-en="350">ClassGetterDecorator</span>
  | <span class="hljs-title class_" data-en="351">ClassSetterDecorator</span>
  | <span class="hljs-title class_" data-en="352">ClassAutoAccessorDecorator</span>
  | <span class="hljs-title class_" data-en="353">ClassFieldDecorator</span>
;
</code></pre>
      <p data-en="354">我们很快会遇到这些装饰器及其类型签名 – 只有这些部分会有所不同：</p>
      <ul data-en="355">
        <li><code>value</code> 的类型</li>
        <li><code>context</code> 的某些属性</li>
        <li>返回类型</li>
      </ul>
      <h3 id="what-can-decorators-do%3F" tabindex="-1" data-en="361">装饰器能做什么？&nbsp;&nbsp;<a class="heading-anchor" href="#what-can-decorators-do%3F" aria-hidden="true" data-en="362">#</a></h3>
      <p data-en="363">每个装饰器最多有四种能力：</p>
      <ul data-en="364">
        <li>
          <p>通过改变参数 <code>value</code> 来改变被装饰的实体。</p>
        </li>
        <li>
          <p>通过返回兼容的值来替换被装饰的实体：
          <ul>
            <li>“兼容”&nbsp;意味着返回的值必须与被装饰值具有相同的类型 – 例如，类装饰器必须返回可调用的值。</li>
            <li>如果装饰器不想替换被装饰的值，它可以返回 <code>undefined</code> – 可以是显式返回，也可以是通过不返回任何内容隐式返回。</li>
          </ul>
          </p>
        </li>
        <li>
          <p>向其他人暴露对被装饰实体的访问。<code>context.access</code> 使其能够通过其方法 <code>.get()</code> 和 <code>.set()</code> 来实现。</p>
        </li>
        <li>
          <p>在被装饰实体及其容器（如果有的话）存在后处理它们：该功能由 <code>context.addInitializer</code> 提供。它允许装饰器注册一个 <em>初始化器</em> – 在一切准备就绪时调用的回调（更多细节在<a href="#decorator-initializer-execution">稍后解释</a>）。</p>
        </li>
      </ul>
      <p data-en="384">接下来的小节将演示这些能力。起初我们不会使用 <code>context.kind</code> 来检查装饰器应用于哪种类型的构造。稍后我们会这样做。</p>
      <h4 id="ability%3A-replacing-the-decorated-entity" tabindex="-1" data-en="386">能力：替换被装饰实体&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-replacing-the-decorated-entity" aria-hidden="true">#</a></h4>
      <p data-en="388">在下面的示例中，装饰器 <code>@replaceMethod</code> 用它返回的函数替换了方法 <code>.hello()</code>（B 行）。</p>
      <pre data-en="391"><code class="language-js" data-en="392"><span class="hljs-keyword" data-en="393">function</span> <span class="hljs-title function_" data-en="394">replaceMethod</span>(<span class="hljs-params" data-en="395"></span>) {
  <span class="hljs-keyword" data-en="396">return</span> <span class="hljs-keyword" data-en="397">function</span> (<span class="hljs-params" data-en="398"></span>) { <span class="hljs-comment" data-en="399">// (A)</span>
    <span class="hljs-keyword" data-en="400">return</span> <span class="hljs-string" data-en="401">`How are you, <span class="hljs-subst" data-en="402">${<span class="hljs-variable language_" data-en="403">this</span>.name}</span>?`</span>;
  }
}

<span class="hljs-keyword" data-en="404">class</span> <span class="hljs-title class_" data-en="405">Person</span> {
  <span class="hljs-title function_" data-en="406">constructor</span>(<span class="hljs-params" data-en="407">name</span>) {
    <span class="hljs-variable language_" data-en="408">this</span>.<span class="hljs-property" data-en="409">name</span> = name;
  }
  @replaceMethod
  <span class="hljs-title function_" data-en="410">hello</span>(<span class="hljs-params" data-en="411"></span>) { <span class="hljs-comment" data-en="412">// (B)</span>
    <span class="hljs-keyword" data-en="413">return</span> <span class="hljs-string" data-en="414">`Hi <span class="hljs-subst" data-en="415">${<span class="hljs-variable language_" data-en="416">this</span>.name}</span>!`</span>;
  }
}

<span class="hljs-keyword" data-en="417">const</span> robin = <span class="hljs-keyword" data-en="418">new</span> <span class="hljs-title class_" data-en="419">Person</span>(<span class="hljs-string" data-en="420">'Robin'</span>);
assert.<span class="hljs-title function_" data-en="421">equal</span>(
  robin.<span class="hljs-title function_" data-en="422">hello</span>(), <span class="hljs-string" data-en="423">'How are you, Robin?'</span>
);
</code></pre>
      <h4 id="ability%3A-exposing-access-to-the-decorated-entity-to-others" tabindex="-1" data-en="424">能力：向其他人暴露对被装饰实体的访问&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-exposing-access-to-the-decorated-entity-to-others" aria-hidden="true" data-en="425">#</a></h4>
      <p data-en="426">在下一个示例中，装饰器 <code>@exposeAccess</code> 将一个对象存储在变量 <code>acc</code> 中，使我们能够访问 <code>Color</code> 实例的 <code>.green</code> 属性。</p>
      <pre data-en="431"><code class="language-js" data-en="432"><span class="hljs-keyword" data-en="433">let</span> acc;
<span class="hljs-keyword" data-en="434">function</span> <span class="hljs-title function_" data-en="435">exposeAccess</span>(<span class="hljs-params" data-en="436">_value, {access}</span>) {
  acc = access;
}

<span class="hljs-keyword" data-en="437">class</span> <span class="hljs-title class_" data-en="438">Color</span> {
  @exposeAccess
  name = <span class="hljs-string" data-en="439">'green'</span>
}

<span class="hljs-keyword" data-en="440">const</span> green = <span class="hljs-keyword" data-en="441">new</span> <span class="hljs-title class_" data-en="442">Color</span>();
assert.<span class="hljs-title function_" data-en="443">equal</span>(
  green.<span class="hljs-property" data-en="444">name</span>, <span class="hljs-string" data-en="445">'green'</span>
);
<span class="hljs-comment" data-en="446">// 使用 `acc` 获取和设置 `green.name`</span>
assert.<span class="hljs-title function_" data-en="447">equal</span>(
  acc.<span class="hljs-property" data-en="448">get</span>.<span class="hljs-title function_" data-en="449">call</span>(green), <span class="hljs-string" data-en="450">'green'</span>
);
acc.<span class="hljs-property" data-en="451">set</span>.<span class="hljs-title function_" data-en="452">call</span>(green, <span class="hljs-string" data-en="453">'red'</span>);
assert.<span class="hljs-title function_" data-en="454">equal</span>(
  green.<span class="hljs-property" data-en="455">name</span>, <span class="hljs-string" data-en="456">'red'</span>
);
</code></pre>
      <h4 id="ability%3A-processing-the-decorated-entity-and-its-container" tabindex="-1" data-en="457">能力：处理被装饰实体及其容器&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-processing-the-decorated-entity-and-its-container" aria-hidden="true" data-en="458">#</a></h4>
      <p data-en="459">在以下代码中，我们使用装饰器 <code>@collect</code> 将被装饰方法的键存储在实例属性 <code>.collectedMethodKeys</code> 中：</p>
      <pre data-en="462"><code class="language-js" data-en="463"><span class="hljs-keyword" data-en="464">function</span> <span class="hljs-title function_" data-en="465">collect</span>(<span class="hljs-params" data-en="466">_value, {name, addInitializer}</span>) {
  <span class="hljs-title function_" data-en="467">addInitializer</span>(<span class="hljs-keyword" data-en="468">function</span> (<span class="hljs-params" data-en="469"></span>) { <span class="hljs-comment" data-en="470">// (A)</span>
    <span class="hljs-keyword" data-en="471">if</span> (!<span class="hljs-variable language_" data-en="472">this</span>.<span class="hljs-property" data-en="473">collectedMethodKeys</span>) {
      <span class="hljs-variable language_" data-en="474">this</span>.<span class="hljs-property" data-en="475">collectedMethodKeys</span> = <span class="hljs-keyword" data-en="476">new</span> <span class="hljs-title class_" data-en="477">Set</span>();
    }
    <span class="hljs-variable language_" data-en="478">this</span>.<span class="hljs-property" data-en="479">collectedMethodKeys</span>.<span class="hljs-title function_" data-en="480">add</span>(name);
  });
}

<span class="hljs-keyword" data-en="481">class</span> <span class="hljs-title class_" data-en="482">C</span> {
  @collect
  <span class="hljs-title function_" data-en="483">toString</span>(<span class="hljs-params" data-en="484"></span>) {}
  @collect
  [<span class="hljs-title class_" data-en="485">Symbol</span>.<span class="hljs-property" data-en="486">iterator</span>]() {}
}
<span class="hljs-keyword" data-en="487">const</span> inst = <span class="hljs-keyword" data-en="488">new</span> <span class="hljs-title function_" data-en="489">C</span>();
assert.<span class="hljs-title function_" data-en="490">deepEqual</span>(
  inst.<span class="hljs-property" data-en="491">collectedMethodKeys</span>,
  <span class="hljs-keyword" data-en="492">new</span> <span class="hljs-title class_" data-en="493">Set</span>([<span class="hljs-string" data-en="494">'toString'</span>, <span class="hljs-title class_" data-en="495">Symbol</span>.<span class="hljs-property" data-en="496">iterator</span>])
);
</code></pre>
      <p data-en="497">在 A 行添加的初始化函数必须是普通函数，因为需要访问隐式参数 <code>this</code>。箭头函数无法提供此访问权限 – 它们的 <code>this</code> 是静态作用域的（像任何普通变量一样）。</p>
      <h3 id="summary-tables" tabindex="-1" data-en="500">总结表格&nbsp;&nbsp;<a class="heading-anchor" href="#summary-tables" aria-hidden="true" data-en="501">#</a></h3>
      <p data-en="502">类型签名：</p>
      <table class="framed" data-en="503">
        <thead>
          <tr>
            <th>装饰器种类</th>
            <th><code>(input) =&gt; output</code></th>
            <th><code>.access</code></th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Class</td>
            <td><code>(func) =&gt; func2</code></td>
            <td>–</td>
          </tr>
          <tr>
            <td>Method</td>
            <td><code>(func) =&gt; func2</code></td>
            <td><code>{get}</code></td>
          </tr>
          <tr>
            <td>Getter</td>
            <td><code>(func) =&gt; func2</code></td>
            <td><code>{get}</code></td>
          </tr>
          <tr>
            <td>Setter</td>
            <td><code>(func) =&gt; func2</code></td>
            <td><code>{set}</code></td>
          </tr>
          <tr>
            <td>Auto-accessor</td>
            <td><code>({get,set}) =&gt; {get,set,init}</code></td>
            <td><code>{get,set}</code></td>
          </tr>
          <tr>
            <td>Field</td>
            <td><code>() =&gt; (initValue)=&gt;initValue2</code></td>
            <td><code>{get,set}</code></td>
          </tr>
        </tbody>
      </table>
      <p data-en="547">函数中 <code>this</code> 的值：</p>
      <table class="framed" data-en="549">
        <thead>
          <tr>
            <th><code>this</code> 是 →</th>
            <th><code>undefined</code></th>
            <th>Class</th>
            <th>Instance</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Decorator function</td>
            <td>✔</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>Static initializer</td>
            <td></td>
            <td>✔</td>
            <td></td>
          </tr>
          <tr>
            <td>Non-static initializer</td>
            <td></td>
            <td></td>
            <td>✔</td>
          </tr>
          <tr>
            <td>Static field decorator result</td>
            <td></td>
            <td>✔</td>
            <td></td>
          </tr>
          <tr>
            <td>Non-static field decorator result</td>
            <td></td>
            <td></td>
            <td>✔</td>
          </tr>
        </tbody>
      </table>
      <h2 id="more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)" tabindex="-1" data-en="584">装饰器语法与语义的更多信息（可选章节）&nbsp;&nbsp;<a class="heading-anchor" href="#more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)" aria-hidden="true" data-en="585">#</a></h2>
      <p data-en="586">(本章节为可选内容。如果您跳过此章节，仍然可以理解后续内容。)</p>
      <h3 id="the-syntax-of-decorator-expressions" tabindex="-1" data-en="587">装饰器表达式的语法&nbsp;&nbsp;<a class="heading-anchor" href="#the-syntax-of-decorator-expressions" aria-hidden="true" data-en="588">#</a></h3>
      <ul data-en="589">
        <li>装饰器表达式以一个或多个标识符的链开始，标识符之间用点分隔。除第一个标识符外，每个标识符都可以是私有的（前缀为 <code>#</code>）。不允许使用方括号 <code>[]</code>。</li>
        <li>可选：末尾可以加上括号中的函数调用参数。下一小节将解释这意味着什么。</li>
        <li>如果我们把它放在括号中，我们可以使用任何表达式：
          <pre><code class="language-js">@(«expr»)
      </code></pre>
        </li>
      </ul>
      <p data-en="597">无论装饰器允许在哪里，我们都可以使用多个装饰器。以下代码演示了装饰器语法:</p>
      <pre data-en="598"><code class="language-js" data-en="599"><span class="hljs-comment" data-en="600">// 五个 MyClass 的装饰器</span>

@myFunc
@<span class="hljs-title function_" data-en="601">myFuncFactory</span>(<span class="hljs-string" data-en="602">'arg1'</span>, <span class="hljs-string" data-en="603">'arg2'</span>)

@libraryModule.<span class="hljs-property" data-en="604">prop</span>
@someObj.<span class="hljs-title function_" data-en="605">method</span>(<span class="hljs-number" data-en="606">123</span>)

@(<span class="hljs-title function_" data-en="607">wrap</span>(dict[<span class="hljs-string" data-en="608">'prop'</span>])) <span class="hljs-comment" data-en="609">// 任意表达式</span>

<span class="hljs-keyword" data-en="610">class</span> <span class="hljs-title class_" data-en="611">MyClass</span> {}
</code></pre>
      <h3 id="how-are-decorators-executed%3F" tabindex="-1" data-en="612">装饰器如何执行？&nbsp;&nbsp;<a class="heading-anchor" href="#how-are-decorators-executed%3F" aria-hidden="true" data-en="613">#</a></h3>
      <ul data-en="614">
        <li>
          <p>评估：<code>@</code> 符号后面的表达式在类定义的执行过程中被评估，与计算属性键和静态字段一起（见代码）。结果必须是函数。它们被存储在临时位置（可以认为是局部变量），以便稍后调用。</p>
        </li>
        <li>
          <p>调用：装饰器函数在类定义的执行过程中稍后被调用，在方法被评估后，但在构造函数和原型被组装之前。结果再次存储在临时位置。</p>
        </li>
        <li>
          <p>应用：在所有装饰器函数被调用后，使用它们的结果，这可能会影响构造函数和原型。类装饰器在所有方法和字段装饰器之后应用。</p>
        </li>
      </ul>
      <p data-en="622">以下代码说明了装饰器表达式、计算属性键和字段初始化器的评估顺序：</p>
      <pre data-en="623"><code class="language-js" data-en="624"><span class="hljs-keyword" data-en="625">function</span> <span class="hljs-title function_" data-en="626">decorate</span>(<span class="hljs-params" data-en="627">str</span>) {
  <span class="hljs-variable language_" data-en="628">console</span>.<span class="hljs-title function_" data-en="629">log</span>(<span class="hljs-string" data-en="630">`EVALUATE @decorate(): <span class="hljs-subst" data-en="631">${str}</span>`</span>);
  <span class="hljs-keyword" data-en="632">return</span> <span class="hljs-function" data-en="633">() =&gt;</span> <span class="hljs-variable language_" data-en="634">console</span>.<span class="hljs-title function_" data-en="635">log</span>(<span class="hljs-string" data-en="636">`APPLY @decorate(): <span class="hljs-subst" data-en="637">${str}</span>`</span>); <span class="hljs-comment" data-en="638">// (A)</span>
}
<span class="hljs-keyword" data-en="639">function</span> <span class="hljs-title function_" data-en="640">log</span>(<span class="hljs-params" data-en="641">str</span>) {
  <span class="hljs-variable language_" data-en="642">console</span>.<span class="hljs-title function_" data-en="643">log</span>(str);
  <span class="hljs-keyword" data-en="644">return</span> str;
}

@<span class="hljs-title function_" data-en="645">decorate</span>(<span class="hljs-string" data-en="646">'class'</span>)
<span class="hljs-keyword" data-en="647">class</span> <span class="hljs-title class_" data-en="648">TheClass</span> {

  @<span class="hljs-title function_" data-en="649">decorate</span>(<span class="hljs-string" data-en="650">'static field'</span>)
  <span class="hljs-keyword" data-en="651">static</span> staticField = <span class="hljs-title function_" data-en="652">log</span>(<span class="hljs-string" data-en="653">'static field value'</span>);

  @<span class="hljs-title function_" data-en="654">decorate</span>(<span class="hljs-string" data-en="655">'prototype method'</span>)
  [<span class="hljs-title function_" data-en="656">log</span>(<span class="hljs-string" data-en="657">'computed key'</span>)]() {}

  @<span class="hljs-title function_" data-en="658">decorate</span>(<span class="hljs-string" data-en="659">'instance field'</span>)
  instanceField = <span class="hljs-title function_" data-en="660">log</span>(<span class="hljs-string" data-en="661">'instance field value'</span>);
    <span class="hljs-comment" data-en="662">// 仅在我们实例化类时，此初始化器才会运行</span>
}

<span class="hljs-comment" data-en="663">// Output:</span>
<span class="hljs-comment" data-en="664">// EVALUATE @decorate(): class</span>
<span class="hljs-comment" data-en="665">// EVALUATE @decorate(): static field</span>
<span class="hljs-comment" data-en="666">// EVALUATE @decorate(): prototype method</span>
<span class="hljs-comment" data-en="667">// computed key</span>
<span class="hljs-comment" data-en="668">// EVALUATE @decorate(): instance field</span>
<span class="hljs-comment" data-en="669">// APPLY @decorate(): prototype method</span>
<span class="hljs-comment" data-en="670">// APPLY @decorate(): static field</span>
<span class="hljs-comment" data-en="671">// APPLY @decorate(): instance field</span>
<span class="hljs-comment" data-en="672">// APPLY @decorate(): class</span>
<span class="hljs-comment" data-en="673">// static field value</span>
</code></pre>
      <p data-en="674">函数 <code>decorate</code> 在每次评估 <code>decorate()</code> 表达式时被调用。在 A行，它返回实际的装饰器函数，该函数稍后会被应用。</p>
      <h3 id="decorator-initializer-execution" tabindex="-1" data-en="678">装饰器初始化器何时运行？&nbsp;&nbsp;<a class="heading-anchor" href="#decorator-initializer-execution" aria-hidden="true" data-en="679">#</a></h3>
      <p data-en="680">装饰器初始化器的运行时间取决于装饰器的种类：</p>
      <ul data-en="681">
        <li>
          <p>类装饰器初始化器在类完全定义并且所有静态字段初始化后运行。</p>
        </li>
        <li>
          <p>非静态类元素装饰器的初始化器在实例化期间运行，在实例字段初始化之前。</p>
        </li>
        <li>
          <p>静态类元素装饰器的初始化器在类定义期间运行，在静态字段定义之前，但在所有其他类元素定义之后。</p>
        </li>
      </ul>
      <p data-en="688">为什么会这样？对于非静态初始化器，我们有五个选项 – 它们可以在以下时机运行：</p>
      <ol data-en="689">
        <li>在 <code>super</code> 之前</li>
        <li>在 <code>super</code> 之后，字段初始化之前</li>
        <li>按定义顺序交错在字段之间</li>
        <li>在字段初始化之后，子类实例化之前</li>
        <li>在子类实例化之后</li>
      </ol>
      <p data-en="697">为什么选择了第 2 种方案？</p>
      <ul data-en="698">
        <li>
          <p>第 1 种方案被拒绝，因为装饰器初始化器必须能够访问 <code>this</code>，而在 <code>super</code> 运行之前无法做到这一点。</p>
        </li>
        <li>
          <p>第 3 种方案被拒绝，因为同时运行所有装饰器初始化器比确保它们正确交错要简单。</p>
        </li>
      </ul>
      <ul data-en="705">
        <li>
          <p>第 4 种方案被拒绝，因为在字段之前运行装饰器初始化器可以确保字段在被装饰方法完全初始化之前不会被访问。例如，如果有 <code>@bind</code> 装饰器，则字段初始化器可以依赖于被装饰的方法已被绑定。</p>
        </li>
        <li>
          <p>第 5 种方案被拒绝，因为它允许超类干扰子类，这会破坏超类不应意识到其子类的规则。</p>
        </li>
      </ul>
      <p data-en="711">以下代码演示了 Babel 当前如何调用装饰器初始化器。请注意，Babel 尚不支持类字段装饰器的初始化器（这是对装饰器 API 的最近更改）。</p>
      <pre data-en="712"><code class="language-js" data-en="713"><span class="hljs-comment" data-en="714">// 我们在记录步骤时等待实例化后,</span>
<span class="hljs-comment" data-en="715">// 这样我们就可以将`this`的值与实例进行比较。</span>
<span class="hljs-keyword" data-en="716">const</span> steps = [];
<span class="hljs-keyword" data-en="717">function</span> <span class="hljs-title function_" data-en="718">push</span>(<span class="hljs-params" data-en="719">msg, _this</span>) {
  steps.<span class="hljs-title function_" data-en="720">push</span>({msg, _this});
}
<span class="hljs-keyword" data-en="721">function</span> <span class="hljs-title function_" data-en="722">pushStr</span>(<span class="hljs-params" data-en="723">str</span>) {
  steps.<span class="hljs-title function_" data-en="724">push</span>(str);
}

<span class="hljs-keyword" data-en="725">function</span> <span class="hljs-title function_" data-en="726">init</span>(<span class="hljs-params" data-en="727">_value, {name, addInitializer}</span>) {
  <span class="hljs-title function_" data-en="728">pushStr</span>(<span class="hljs-string" data-en="729">`@init <span class="hljs-subst" data-en="730">${name}</span>`</span>);
  <span class="hljs-keyword" data-en="731">if</span> (addInitializer) {
    <span class="hljs-title function_" data-en="732">addInitializer</span>(<span class="hljs-keyword" data-en="733">function</span> (<span class="hljs-params" data-en="734"></span>) {
      <span class="hljs-title function_" data-en="735">push</span>(<span class="hljs-string" data-en="736">`DECORATOR INITIALIZER <span class="hljs-subst" data-en="737">${name}</span>`</span>, <span class="hljs-variable language_" data-en="738">this</span>);
    });
  }
}

@init <span class="hljs-keyword" data-en="739">class</span> <span class="hljs-title class_" data-en="740">TheClass</span> {
  <span class="hljs-comment" data-en="741">//--- 静态 ---</span>

  <span class="hljs-keyword" data-en="742">static</span> {
    <span class="hljs-title function_" data-en="743">pushStr</span>(<span class="hljs-string" data-en="744">'static block'</span>);
  }

  @init <span class="hljs-keyword" data-en="745">static</span> <span class="hljs-title function_" data-en="746">staticMethod</span>(<span class="hljs-params" data-en="747"></span>) {}
  @init <span class="hljs-keyword" data-en="748">static</span> accessor staticAcc = <span class="hljs-title function_" data-en="749">pushStr</span>(<span class="hljs-string" data-en="750">'staticAcc'</span>);
  @init <span class="hljs-keyword" data-en="751">static</span> staticField = <span class="hljs-title function_" data-en="752">pushStr</span>(<span class="hljs-string" data-en="753">'staticField'</span>);

  <span class="hljs-comment" data-en="754">//--- 非静态 ---</span>

  @init <span class="hljs-title function_" data-en="755">prototypeMethod</span>(<span class="hljs-params" data-en="756"></span>) {}
  @init accessor instanceAcc = <span class="hljs-title function_" data-en="757">pushStr</span>(<span class="hljs-string" data-en="758">'instanceAcc'</span>);
  @init instanceField = <span class="hljs-title function_" data-en="759">pushStr</span>(<span class="hljs-string" data-en="760">'instanceField'</span>);

  <span class="hljs-title function_" data-en="761">constructor</span>(<span class="hljs-params" data-en="762"></span>) {
    <span class="hljs-title function_" data-en="763">pushStr</span>(<span class="hljs-string" data-en="764">'constructor'</span>);
  }
}

<span class="hljs-title function_" data-en="765">pushStr</span>(<span class="hljs-string" data-en="766">'===== 实例化 ====='</span>);
<span class="hljs-keyword" data-en="767">const</span> inst = <span class="hljs-keyword" data-en="768">new</span> <span class="hljs-title class_" data-en="769">TheClass</span>();

<span class="hljs-keyword" data-en="770">for</span> (<span class="hljs-keyword" data-en="771">const</span> step <span class="hljs-keyword" data-en="772">of</span> steps) {
  <span class="hljs-keyword" data-en="773">if</span> (<span class="hljs-keyword" data-en="774">typeof</span> step === <span class="hljs-string" data-en="775">'string'</span>) {
    <span class="hljs-variable language_" data-en="776">console</span>.<span class="hljs-title function_" data-en="777">log</span>(step);
    <span class="hljs-keyword" data-en="778">continue</span>;
  }
  <span class="hljs-keyword" data-en="779">let</span> thisDesc = <span class="hljs-string" data-en="780">'???'</span>;
  <span class="hljs-keyword" data-en="781">if</span> (step.<span class="hljs-property" data-en="782">_this</span> === <span class="hljs-title class_" data-en="783">TheClass</span>) {
    thisDesc = <span class="hljs-title class_" data-en="784">TheClass</span>.<span class="hljs-property" data-en="785">name</span>;
  } <span class="hljs-keyword" data-en="786">else</span> <span class="hljs-keyword" data-en="787">if</span> (step.<span class="hljs-property" data-en="788">_this</span> === inst) {
    thisDesc = <span class="hljs-string" data-en="789">'inst'</span>;
  } <span class="hljs-keyword" data-en="790">else</span> <span class="hljs-keyword" data-en="791">if</span> (step.<span class="hljs-property" data-en="792">_this</span> === <span class="hljs-literal" data-en="793">undefined</span>) {
    thisDesc = <span class="hljs-string" data-en="794">'undefined'</span>;
  }
  <span class="hljs-variable language_" data-en="795">console</span>.<span class="hljs-title function_" data-en="796">log</span>(<span class="hljs-string" data-en="797">`<span class="hljs-subst" data-en="798">${step.msg}</span> (this===<span class="hljs-subst" data-en="799">${thisDesc}</span>)`</span>);
}

<span class="hljs-comment" data-en="800">// 输出：</span>
<span class="hljs-comment" data-en="801">// @init staticMethod</span>
<span class="hljs-comment" data-en="802">// @init staticAcc</span>
<span class="hljs-comment" data-en="803">// @init prototypeMethod</span>
<span class="hljs-comment" data-en="804">// @init instanceAcc</span>
<span class="hljs-comment" data-en="805">// @init staticField</span>
<span class="hljs-comment" data-en="806">// @init instanceField</span>
<span class="hljs-comment" data-en="807">// @init TheClass</span>
<span class="hljs-comment" data-en="808">// DECORATOR INITIALIZER staticMethod (this===TheClass)</span>
<span class="hljs-comment" data-en="809">// DECORATOR INITIALIZER staticAcc (this===TheClass)</span>
<span class="hljs-comment" data-en="810">// static block</span>
<span class="hljs-comment" data-en="811">// staticAcc</span>
<span class="hljs-comment" data-en="812">// staticField</span>
<span class="hljs-comment" data-en="813">// DECORATOR INITIALIZER TheClass (this===TheClass)</span>
<span class="hljs-comment" data-en="814">// ===== Instantiation =====</span>
<span class="hljs-comment" data-en="815">// DECORATOR INITIALIZER prototypeMethod (this===inst)</span>
<span class="hljs-comment" data-en="816">// DECORATOR INITIALIZER instanceAcc (this===inst)</span>
<span class="hljs-comment" data-en="817">// instanceAcc</span>
<span class="hljs-comment" data-en="818">// instanceField</span>
<span class="hljs-comment" data-en="819">// constructor</span>
</code></pre>
      <h2 id="techniques-for-exposing-data-from-decorators" tabindex="-1" data-en="820">装饰器暴露数据的技巧&nbsp;&nbsp;<a class="heading-anchor" href="#techniques-for-exposing-data-from-decorators" aria-hidden="true" data-en="821">#</a></h2>
      <p data-en="822">有时装饰器会收集数据。让我们探索它们如何将这些数据提供给其他方。</p>
      <h3 id="storing-exposed-data-in-a-surrounding-scope" tabindex="-1" data-en="823">在外部作用域存储暴露的数据&nbsp;&nbsp;<a class="heading-anchor" href="#storing-exposed-data-in-a-surrounding-scope" aria-hidden="true" data-en="824">#</a></h3>
      <p data-en="825">最简单的解决方案是将数据存储在外部作用域的某个位置。例如，装饰器 <code>@collect</code> 收集类并将它们存储在 Set <code>classes</code> 中（A 行）：</p>
      <pre data-en="828"><code class="language-js" data-en="829"><span class="hljs-keyword" data-en="830">const</span> classes = <span class="hljs-keyword" data-en="831">new</span> <span class="hljs-title class_" data-en="832">Set</span>(); <span class="hljs-comment" data-en="833">// (A)</span>

<span class="hljs-keyword" data-en="834">function</span> <span class="hljs-title function_" data-en="835">collect</span>(<span class="hljs-params" data-en="836">value, {kind, addInitializer}</span>) {
  <span class="hljs-keyword" data-en="837">if</span> (kind === <span class="hljs-string" data-en="838">'class'</span>) {
    classes.<span class="hljs-title function_" data-en="839">add</span>(value);
  }
}

@collect
<span class="hljs-keyword" data-en="840">class</span> <span class="hljs-title class_" data-en="841">A</span> {}
@collect
<span class="hljs-keyword" data-en="842">class</span> <span class="hljs-title class_" data-en="843">B</span> {}
@collect
<span class="hljs-keyword" data-en="844">class</span> <span class="hljs-title class_" data-en="845">C</span> {}

assert.<span class="hljs-title function_" data-en="846">deepEqual</span>(
  classes, <span class="hljs-keyword" data-en="847">new</span> <span class="hljs-title class_" data-en="848">Set</span>([A, B, C])
);
</code></pre>
      <p data-en="849">此方法的缺点是，如果装饰器来自另一个模块，则此方法无效。</p>
      <h3 id="managing-exposed-data-via-a-factory-function" tabindex="-1" data-en="850">通过工厂函数管理暴露的数据&nbsp;&nbsp;<a class="heading-anchor" href="#managing-exposed-data-via-a-factory-function" aria-hidden="true" data-en="851">#</a></h3>
      <p data-en="852">一种更复杂的方法是使用工厂函数 <code>createClassCollector()</code>，该函数返回：</p>
      <ul data-en="854">
        <li>一个类装饰器 <code>collect</code></li>
        <li>一个 Set <code>classes</code>，装饰器将把收集到的类添加到其中</li>
      </ul>
      <pre data-en="859"><code class="language-js" data-en="860"><span class="hljs-keyword" data-en="861">function</span> <span class="hljs-title function_" data-en="862">createClassCollector</span>(<span class="hljs-params" data-en="863"></span>) {
  <span class="hljs-keyword" data-en="864">const</span> classes = <span class="hljs-keyword" data-en="865">new</span> <span class="hljs-title class_" data-en="866">Set</span>();
  <span class="hljs-keyword" data-en="867">function</span> <span class="hljs-title function_" data-en="868">collect</span>(<span class="hljs-params" data-en="869">value, {kind, addInitializer}</span>) {
    <span class="hljs-keyword" data-en="870">if</span> (kind === <span class="hljs-string" data-en="871">'class'</span>) {
      classes.<span class="hljs-title function_" data-en="872">add</span>(value);
    }
  }
  <span class="hljs-keyword" data-en="873">return</span> {
    classes,
    collect,
  };
}

<span class="hljs-keyword" data-en="874">const</span> {classes, collect} = <span class="hljs-title function_" data-en="875">createClassCollector</span>();

@collect
<span class="hljs-keyword" data-en="876">class</span> <span class="hljs-title class_" data-en="877">A</span> {}
@collect
<span class="hljs-keyword" data-en="878">class</span> <span class="hljs-title class_" data-en="879">B</span> {}
@collect
<span class="hljs-keyword" data-en="880">class</span> <span class="hljs-title class_" data-en="881">C</span> {}

assert.<span class="hljs-title function_" data-en="882">deepEqual</span>(
  classes, <span class="hljs-keyword" data-en="883">new</span> <span class="hljs-title class_" data-en="884">Set</span>([A, B, C])
);
</code></pre>
      <h3 id="managing-exposed-data-via-a-class" tabindex="-1" data-en="885">通过类管理暴露的数据&nbsp;&nbsp;<a class="heading-anchor" href="#managing-exposed-data-via-a-class" aria-hidden="true" data-en="886">#</a></h3>
      <p data-en="887">我们也可以使用类来代替工厂函数。它有两个成员：</p>
      <ul data-en="888">
        <li><code>.classes</code>，一个包含收集到的类的 Set</li>
        <li><code>.install</code>，一个类装饰器</li>
      </ul>
      <pre data-en="893"><code class="language-js" data-en="894"><span class="hljs-keyword" data-en="895">class</span> <span class="hljs-title class_" data-en="896">ClassCollector</span> {
  classes = <span class="hljs-keyword" data-en="897">new</span> <span class="hljs-title class_" data-en="898">Set</span>();
  install = <span class="hljs-function" data-en="899">(<span class="hljs-params" data-en="900">value, {kind}</span>) =&gt;</span> { <span class="hljs-comment" data-en="901">// (A)</span>
    <span class="hljs-keyword" data-en="902">if</span> (kind === <span class="hljs-string" data-en="903">'class'</span>) {
      <span class="hljs-variable language_" data-en="904">this</span>.<span class="hljs-property" data-en="905">classes</span>.<span class="hljs-title function_" data-en="906">add</span>(value); <span class="hljs-comment" data-en="907">// (B)</span>
    }
  };
}

<span class="hljs-keyword" data-en="908">const</span> collector = <span class="hljs-keyword" data-en="909">new</span> <span class="hljs-title class_" data-en="910">ClassCollector</span>();

@collector.<span class="hljs-property" data-en="911">install</span>
<span class="hljs-keyword" data-en="912">class</span> <span class="hljs-title class_" data-en="913">A</span> {}
@collector.<span class="hljs-property" data-en="914">install</span>
<span class="hljs-keyword" data-en="915">class</span> <span class="hljs-title class_" data-en="916">B</span> {}
@collector.<span class="hljs-property" data-en="917">install</span>
<span class="hljs-keyword" data-en="918">class</span> <span class="hljs-title class_" data-en="919">C</span> {}

assert.<span class="hljs-title function_" data-en="920">deepEqual</span>(
  collector.<span class="hljs-property" data-en="921">classes</span>, <span class="hljs-keyword" data-en="922">new</span> <span class="hljs-title class_" data-en="923">Set</span>([A, B, C])
);
</code></pre>
      <p data-en="924">我们通过将一个箭头函数分配给公共实例字段来实现 <code>.install</code>（A 行）。实例字段初始化器在 <code>this</code> 指向当前实例的作用域中运行。这也是箭头函数的外部作用域，解释了为什么 <code>this</code> 在 B 行具有该值。</p>
      <p data-en="928">我们也可以通过 getter 来实现 <code>.install</code>，但那样的话，每次读取 <code>.install</code> 时都必须返回一个新函数。</p>
      <h2 id="class-decorators" tabindex="-1" data-en="931">类装饰器&nbsp;&nbsp;<a class="heading-anchor" href="#class-decorators" aria-hidden="true" data-en="932">#</a></h2>
      <p data-en="933">类装饰器具有以下类型签名：</p>
      <pre data-en="934"><code class="language-ts" data-en="935"><span class="hljs-keyword" data-en="936">type</span> <span class="hljs-title class_" data-en="937">ClassDecorator</span> = <span class="hljs-function" data-en="938">(<span class="hljs-params" data-en="939">
  <span class="hljs-attr" data-en="940">value</span>: <span class="hljs-title class_" data-en="941">Function</span>,
  <span class="hljs-attr" data-en="942">context</span>: {
    kind: <span class="hljs-string" data-en="943">'class'</span>;
    name: <span class="hljs-built_in" data-en="944">string</span> | <span class="hljs-literal" data-en="945">undefined</span>;
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" data-en="946">void</span>): <span class="hljs-built_in" data-en="947">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_" data-en="948">Function</span> | <span class="hljs-built_in" data-en="949">void</span>;
</code></pre>
      <p data-en="950">类装饰器的能力：</p>
      <ul data-en="951">
        <li>它可以通过改变 <code>value</code> 来改变被装饰的类。</li>
        <li>它可以通过返回可调用的值来替换被装饰的类。</li>
        <li>它可以注册初始化器，初始化器在被装饰的类完全设置后调用。</li>
        <li>由于类不是其他语言结构的成员（而方法是类的成员），因此它不获取 <code>context.access</code>。</li>
      </ul>
      <h3 id="example%3A-collecting-instances" tabindex="-1" data-en="958">示例：收集实例&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-collecting-instances" aria-hidden="true" data-en="959">#</a></h3>
      <p data-en="960">在下面的示例中，我们使用装饰器收集所有被装饰类的实例：</p>
      <pre data-en="961"><code class="language-js" data-en="962"><span class="hljs-keyword" data-en="963">class</span> <span class="hljs-title class_" data-en="964">InstanceCollector</span> {
  instances = <span class="hljs-keyword" data-en="965">new</span> <span class="hljs-title class_" data-en="966">Set</span>();
  install = <span class="hljs-function" data-en="967">(<span class="hljs-params" data-en="968">value, {kind}</span>) =&gt;</span> {
    <span class="hljs-keyword" data-en="969">if</span> (kind === <span class="hljs-string" data-en="970">'class'</span>) {
      <span class="hljs-keyword" data-en="971">const</span> _this = <span class="hljs-variable language_" data-en="972">this</span>;
      <span class="hljs-keyword" data-en="973">return</span> <span class="hljs-keyword" data-en="974">function</span> (<span class="hljs-params" data-en="975">...args</span>) { <span class="hljs-comment" data-en="976">// (A)</span>
        <span class="hljs-keyword" data-en="977">const</span> inst = <span class="hljs-keyword" data-en="978">new</span> <span class="hljs-title function_" data-en="979">value</span>(...args); <span class="hljs-comment" data-en="980">// (B)</span>
        _this.<span class="hljs-property" data-en="981">instances</span>.<span class="hljs-title function_" data-en="982">add</span>(inst);
        <span class="hljs-keyword" data-en="983">return</span> inst;
      };
    }
  };
}

<span class="hljs-keyword" data-en="984">const</span> collector = <span class="hljs-keyword" data-en="985">new</span> <span class="hljs-title class_" data-en="986">InstanceCollector</span>();

@collector.<span class="hljs-property" data-en="987">install</span>
<span class="hljs-keyword" data-en="988">class</span> <span class="hljs-title class_" data-en="989">MyClass</span> {}

<span class="hljs-keyword" data-en="990">const</span> inst1 = <span class="hljs-keyword" data-en="991">new</span> <span class="hljs-title class_" data-en="992">MyClass</span>();
<span class="hljs-keyword" data-en="993">const</span> inst2 = <span class="hljs-keyword" data-en="994">new</span> <span class="hljs-title class_" data-en="995">MyClass</span>();
<span class="hljs-keyword" data-en="996">const</span> inst3 = <span class="hljs-keyword" data-en="997">new</span> <span class="hljs-title class_" data-en="998">MyClass</span>();

assert.<span class="hljs-title function_" data-en="999">deepEqual</span>(
  collector.<span class="hljs-property" data-en="1000">instances</span>, <span class="hljs-keyword" data-en="1001">new</span> <span class="hljs-title class_" data-en="1002">Set</span>([inst1, inst2, inst3])
);
</code></pre>
      <p data-en="1003">我们通过将一个函数包装在 <code>.install</code> 中来实现收集实例。该函数在实例化时被调用，并将新创建的实例添加到收集器的实例集合中。</p>
      <p data-en="1006">请注意，我们不能在 A 行返回一个箭头函数，因为箭头函数不能被 new 调用。</p>
      <p data-en="1007">此方法的一个缺点是，它破坏了 <code>instanceof</code>：</p>
      <pre data-en="1009"><code class="language-js" data-en="1010">assert.<span class="hljs-title function_" data-en="1011">equal</span>(
  inst1 <span class="hljs-keyword" data-en="1012">instanceof</span> <span class="hljs-title class_" data-en="1013">MyClass</span>,
  <span class="hljs-literal" data-en="1014">false</span>
);
</code></pre>
      <p data-en="1015">下一小节将解释我们如何修复这个问题。</p>
      <h3 id="making-sure-that-instanceof-works" tabindex="-1" data-en="1016">确保 <code>instanceof</code> 正常工作&nbsp;&nbsp;<a class="heading-anchor" href="#making-sure-that-instanceof-works" aria-hidden="true" data-en="1018">#</a></h3>
      <p data-en="1019">在本节中，我们将使用简单的装饰器 <code>@countInstances</code> 来演示如何使被包装的类支持 <code>instanceof</code>。</p>
      <h4 id="enabling-instanceof-via-.prototype" tabindex="-1" data-en="1022">通过 <code>.prototype</code> 启用 <code>instanceof</code>&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-.prototype" aria-hidden="true">#</a></h4>
      <p data-en="1026">启用 <code>instanceof</code> 的一种方法是将包装函数的 <code>.prototype</code> 设置为被包装的 <code>value</code> 的 <code>.prototype</code>（A 行）：</p>
      <pre data-en="1031"><code class="language-js" data-en="1032"><span class="hljs-keyword" data-en="1033">function</span> <span class="hljs-title function_" data-en="1034">countInstances</span>(<span class="hljs-params" data-en="1035">value</span>) {
  <span class="hljs-keyword" data-en="1036">const</span> _this = <span class="hljs-variable language_" data-en="1037">this</span>;
  <span class="hljs-keyword" data-en="1038">let</span> instanceCount = <span class="hljs-number" data-en="1039">0</span>;
  <span class="hljs-comment" data-en="1040">// 包装器必须是可通过 new 调用的</span>
  <span class="hljs-keyword" data-en="1041">const</span> wrapper = <span class="hljs-keyword" data-en="1042">function</span> (<span class="hljs-params" data-en="1043">...args</span>) {
    instanceCount++;
    <span class="hljs-keyword" data-en="1044">const</span> instance = <span class="hljs-keyword" data-en="1045">new</span> <span class="hljs-title function_" data-en="1046">value</span>(...args);
    <span class="hljs-comment" data-en="1047">// 修改实例</span>
    instance.<span class="hljs-property" data-en="1048">count</span> = instanceCount;
    <span class="hljs-keyword" data-en="1049">return</span> instance;
  };
  wrapper.<span class="hljs-property" data-en="1050"><span class="hljs-keyword" data-en="1051">prototype</span></span> = value.<span class="hljs-property" data-en="1052"><span class="hljs-keyword" data-en="1053">prototype</span></span>; <span class="hljs-comment" data-en="1054">// (A)</span>
  <span class="hljs-keyword" data-en="1055">return</span> wrapper;
}

@countInstances
<span class="hljs-keyword" data-en="1056">class</span> <span class="hljs-title class_" data-en="1057">MyClass</span> {}

<span class="hljs-keyword" data-en="1058">const</span> inst1 = <span class="hljs-keyword" data-en="1059">new</span> <span class="hljs-title class_" data-en="1060">MyClass</span>();
assert.<span class="hljs-title function_" data-en="1061">ok</span>(inst1 <span class="hljs-keyword" data-en="1062">instanceof</span> <span class="hljs-title class_" data-en="1063">MyClass</span>);
assert.<span class="hljs-title function_" data-en="1064">equal</span>(inst1.<span class="hljs-property" data-en="1065">count</span>, <span class="hljs-number" data-en="1066">1</span>);

<span class="hljs-keyword" data-en="1067">const</span> inst2 = <span class="hljs-keyword" data-en="1068">new</span> <span class="hljs-title class_" data-en="1069">MyClass</span>();
assert.<span class="hljs-title function_" data-en="1070">ok</span>(inst2 <span class="hljs-keyword" data-en="1071">instanceof</span> <span class="hljs-title class_" data-en="1072">MyClass</span>);
assert.<span class="hljs-title function_" data-en="1073">equal</span>(inst2.<span class="hljs-property" data-en="1074">count</span>, <span class="hljs-number" data-en="1075">2</span>);
</code></pre>
      <p data-en="1076">这是有效的，原因如下：</p>
      <pre data-en="1077"><code class="language-js" data-en="1078">inst <span class="hljs-keyword" data-en="1079">instanceof</span> C
C.<span class="hljs-property" data-en="1080"><span class="hljs-keyword" data-en="1081">prototype</span></span>.<span class="hljs-title function_" data-en="1082">isPrototypeOf</span>(inst)
</code></pre>
      <p data-en="1083">For more information on <code data-en="1084">instanceof</code>, see <a href="https://exploringjs.com/js/book/ch_classes.html#instanceof-operator" data-en="1085">“Exploring JavaScript”</a>.</p>
      <h4 id="enabling-instanceof-via-symbol.hasinstance" tabindex="-1" data-en="1086">Enabling <code data-en="1087">instanceof</code> via <code data-en="1088">Symbol.hasInstance</code>&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-symbol.hasinstance" aria-hidden="true" data-en="1089">#</a></h4>
      <p data-en="1090">Another option for enabling <code data-en="1091">instanceof</code> is to give the wrapper function a method whose key is <code data-en="1092">Symbol.hasInstance</code> (line A):</p>
      <pre data-en="1093"><code class="language-js" data-en="1094"><span class="hljs-keyword" data-en="1095">function</span> <span class="hljs-title function_" data-en="1096">countInstances</span>(<span class="hljs-params" data-en="1097">value</span>) {
  <span class="hljs-keyword" data-en="1098">const</span> _this = <span class="hljs-variable language_" data-en="1099">this</span>;
  <span class="hljs-keyword" data-en="1100">let</span> instanceCount = <span class="hljs-number" data-en="1101">0</span>;
  <span class="hljs-comment" data-en="1102">// The wrapper must be new-callable</span>
  <span class="hljs-keyword" data-en="1103">const</span> wrapper = <span class="hljs-keyword" data-en="1104">function</span> (<span class="hljs-params" data-en="1105">...args</span>) {
    instanceCount++;
    <span class="hljs-keyword" data-en="1106">const</span> instance = <span class="hljs-keyword" data-en="1107">new</span> <span class="hljs-title function_" data-en="1108">value</span>(...args);
    <span class="hljs-comment" data-en="1109">// Change the instance</span>
    instance.<span class="hljs-property" data-en="1110">count</span> = instanceCount;
    <span class="hljs-keyword" data-en="1111">return</span> instance;
  };
  <span class="hljs-comment" data-en="1112">// Property is read-only, so we can’t use assignment</span>
  <span class="hljs-title class_" data-en="1113">Object</span>.<span class="hljs-title function_" data-en="1114">defineProperty</span>( <span class="hljs-comment" data-en="1115">// (A)</span>
    wrapper, <span class="hljs-title class_" data-en="1116">Symbol</span>.<span class="hljs-property" data-en="1117">hasInstance</span>,
    {
      <span class="hljs-attr" data-en="1118">value</span>: <span class="hljs-keyword" data-en="1119">function</span> (<span class="hljs-params" data-en="1120">x</span>) {
        <span class="hljs-keyword" data-en="1121">return</span> x <span class="hljs-keyword" data-en="1122">instanceof</span> value; 
      }
    }
  );
  <span class="hljs-keyword" data-en="1123">return</span> wrapper;
}

@countInstances
<span class="hljs-keyword" data-en="1124">class</span> <span class="hljs-title class_" data-en="1125">MyClass</span> {}

<span class="hljs-keyword" data-en="1126">const</span> inst1 = <span class="hljs-keyword" data-en="1127">new</span> <span class="hljs-title class_" data-en="1128">MyClass</span>();
assert.<span class="hljs-title function_" data-en="1129">ok</span>(inst1 <span class="hljs-keyword" data-en="1130">instanceof</span> <span class="hljs-title class_" data-en="1131">MyClass</span>);
assert.<span class="hljs-title function_" data-en="1132">equal</span>(inst1.<span class="hljs-property" data-en="1133">count</span>, <span class="hljs-number" data-en="1134">1</span>);

<span class="hljs-keyword" data-en="1135">const</span> inst2 = <span class="hljs-keyword" data-en="1136">new</span> <span class="hljs-title class_" data-en="1137">MyClass</span>();
assert.<span class="hljs-title function_" data-en="1138">ok</span>(inst2 <span class="hljs-keyword" data-en="1139">instanceof</span> <span class="hljs-title class_" data-en="1140">MyClass</span>);
assert.<span class="hljs-title function_" data-en="1141">equal</span>(inst2.<span class="hljs-property" data-en="1142">count</span>, <span class="hljs-number" data-en="1143">2</span>);
</code></pre>
      <p data-en="1144">“Exploring JavaScript” has <a href="https://exploringjs.com/js/book/ch_symbols.html#publicly-known-symbols" data-en="1145">more information on <code data-en="1146">Symbol.hasInstance</code></a>.</p>
      <h4 id="enabling-instanceof-via-subclassing" tabindex="-1" data-en="1147">Enabling <code data-en="1148">instanceof</code> via subclassing&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-subclassing" aria-hidden="true" data-en="1149">#</a></h4>
      <p data-en="1150">We can also enable <code data-en="1151">instanceof</code> by returning a subclass of <code data-en="1152">value</code> (line A):</p>
      <pre data-en="1153"><code class="language-js" data-en="1154"><span class="hljs-keyword" data-en="1155">function</span> <span class="hljs-title function_" data-en="1156">countInstances</span>(<span class="hljs-params" data-en="1157">value</span>) {
  <span class="hljs-keyword" data-en="1158">const</span> _this = <span class="hljs-variable language_" data-en="1159">this</span>;
  <span class="hljs-keyword" data-en="1160">let</span> instanceCount = <span class="hljs-number" data-en="1161">0</span>;
  <span class="hljs-comment" data-en="1162">// The wrapper must be new-callable</span>
  <span class="hljs-keyword" data-en="1163">return</span> <span class="hljs-keyword" data-en="1164">class</span> <span class="hljs-title class_" data-en="1165">extends</span> value { <span class="hljs-comment" data-en="1166">// (A)</span>
    <span class="hljs-title function_" data-en="1167">constructor</span>(<span class="hljs-params" data-en="1168">...args</span>) {
      <span class="hljs-variable language_" data-en="1169">super</span>(...args);
      instanceCount++;
      <span class="hljs-comment" data-en="1170">// Change the instance</span>
      <span class="hljs-variable language_" data-en="1171">this</span>.<span class="hljs-property" data-en="1172">count</span> = instanceCount;
    }
  };
}

@countInstances
<span class="hljs-keyword" data-en="1173">class</span> <span class="hljs-title class_" data-en="1174">MyClass</span> {}

<span class="hljs-keyword" data-en="1175">const</span> inst1 = <span class="hljs-keyword" data-en="1176">new</span> <span class="hljs-title class_" data-en="1177">MyClass</span>();
assert.<span class="hljs-title function_" data-en="1178">ok</span>(inst1 <span class="hljs-keyword" data-en="1179">instanceof</span> <span class="hljs-title class_" data-en="1180">MyClass</span>);
assert.<span class="hljs-title function_" data-en="1181">equal</span>(inst1.<span class="hljs-property" data-en="1182">count</span>, <span class="hljs-number" data-en="1183">1</span>);

<span class="hljs-keyword" data-en="1184">const</span> inst2 = <span class="hljs-keyword" data-en="1185">new</span> <span class="hljs-title class_" data-en="1186">MyClass</span>();
assert.<span class="hljs-title function_" data-en="1187">ok</span>(inst2 <span class="hljs-keyword" data-en="1188">instanceof</span> <span class="hljs-title class_" data-en="1189">MyClass</span>);
assert.<span class="hljs-title function_" data-en="1190">equal</span>(inst2.<span class="hljs-property" data-en="1191">count</span>, <span class="hljs-number" data-en="1192">2</span>);
</code></pre>
      <h3 id="example-freezing-instances" tabindex="-1" data-en="1193">Example: freezing instances&nbsp;&nbsp;<a class="heading-anchor" href="#example-freezing-instances" aria-hidden="true" data-en="1194">#</a></h3>
      <p data-en="1195">The decorator class <code data-en="1196">@freeze</code> freezes all instances produced by the classes it decorates:</p>
      <pre data-en="1197"><code class="language-js" data-en="1198"><span class="hljs-keyword" data-en="1199">function</span> <span class="hljs-title function_" data-en="1200">freeze</span> (<span class="hljs-params" data-en="1201">value, {kind}</span>) {
  <span class="hljs-keyword" data-en="1202">if</span> (kind === <span class="hljs-string" data-en="1203">'class'</span>) {
    <span class="hljs-keyword" data-en="1204">return</span> <span class="hljs-keyword" data-en="1205">function</span> (<span class="hljs-params" data-en="1206">...args</span>) {
      <span class="hljs-keyword" data-en="1207">const</span> inst = <span class="hljs-keyword" data-en="1208">new</span> <span class="hljs-title function_" data-en="1209">value</span>(...args);
      <span class="hljs-keyword" data-en="1210">return</span> <span class="hljs-title class_" data-en="1211">Object</span>.<span class="hljs-title function_" data-en="1212">freeze</span>(inst);
    }
  }
}

@freeze
<span class="hljs-keyword" data-en="1213">class</span> <span class="hljs-title class_" data-en="1214">Color</span> {
  <span class="hljs-title function_" data-en="1215">constructor</span>(<span class="hljs-params" data-en="1216">name</span>) {
    <span class="hljs-variable language_" data-en="1217">this</span>.<span class="hljs-property" data-en="1218">name</span> = name;
  }
}

<span class="hljs-keyword" data-en="1219">const</span> red = <span class="hljs-keyword" data-en="1220">new</span> <span class="hljs-title class_" data-en="1221">Color</span>(<span class="hljs-string" data-en="1222">'red'</span>);
assert.<span class="hljs-title function_" data-en="1223">throws</span>(
  <span class="hljs-function" data-en="1224">() =&gt;</span> red.<span class="hljs-property" data-en="1225">name</span> = <span class="hljs-string" data-en="1226">'green'</span>,
  <span class="hljs-regexp" data-en="1227">/^TypeError: Cannot assign to read only property 'name'/</span>
);
</code></pre>
      <p data-en="1228">This decorator has downsides:</p>
      <ul data-en="1229">
        <li data-en="1230">It breaks <code data-en="1231">instanceof</code>. We have already seen how to fix this.</li>
        <li data-en="1232">Subclassing a decorated class doesn’t work well:
          <ul data-en="1233">
            <li data-en="1234">The way in which constructors are connected isn’t ideal – with a wrapped constructor in the mix. This can be partially fixed by returning a subclass of the decorated <code data-en="1235">value</code>.</li>
            <li data-en="1236">Subclasses can’t set up properties, because their <code data-en="1237">this</code> is immutable. There is no way to avoid this downside.</li>
          </ul>
        </li>
      </ul>
      <p data-en="1238">The last downside could be avoided by giving class decorators access to the instances of the decorated classes after all constructors were executed.</p>
      <p data-en="1239">This would change how inheritance works because a superclass could now change properties that were added by subclasses. Therefore, it’s not sure if such a mechanism is in the cards.</p>
      <h3 id="example%3A-making-classes-function-callable" tabindex="-1" data-en="1240">Example: making classes function-callable&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-making-classes-function-callable" aria-hidden="true" data-en="1241">#</a></h3>
      <p data-en="1242">Classes decorated by <code data-en="1243">@functionCallable</code> can be invoked by function calls instead of the <code data-en="1244">new</code> operator:</p>
      <pre data-en="1245"><code class="language-js" data-en="1246"><span class="hljs-keyword" data-en="1247">function</span> <span class="hljs-title function_" data-en="1248">functionCallable</span>(<span class="hljs-params" data-en="1249">value, {kind}</span>) {
  <span class="hljs-keyword" data-en="1250">if</span> (kind === <span class="hljs-string" data-en="1251">'class'</span>) {
    <span class="hljs-keyword" data-en="1252">return</span> <span class="hljs-keyword" data-en="1253">function</span> (<span class="hljs-params" data-en="1254">...args</span>) {
      <span class="hljs-keyword" data-en="1255">if</span> (<span class="hljs-keyword" data-en="1256">new</span>.<span class="hljs-property" data-en="1257">target</span> !== <span class="hljs-literal" data-en="1258">undefined</span>) {
        <span class="hljs-keyword" data-en="1259">throw</span> <span class="hljs-keyword" data-en="1260">new</span> <span class="hljs-title class_" data-en="1261">TypeError</span>(<span class="hljs-string" data-en="1262">'This function can’t be new-invoked'</span>);
      }
      <span class="hljs-keyword" data-en="1263">return</span> <span class="hljs-keyword" data-en="1264">new</span> <span class="hljs-title function_" data-en="1265">value</span>(...args);
    }
  }
}

@functionCallable
<span class="hljs-keyword" data-en="1266">class</span> <span class="hljs-title class_" data-en="1267">Person</span> {
  <span class="hljs-title function_" data-en="1268">constructor</span>(<span class="hljs-params" data-en="1269">name</span>) {
    <span class="hljs-variable language_" data-en="1270">this</span>.<span class="hljs-property" data-en="1271">name</span> = name;
  }
}
<span class="hljs-keyword" data-en="1272">const</span> robin = <span class="hljs-title class_" data-en="1273">Person</span>(<span class="hljs-string" data-en="1274">'Robin'</span>);
assert.<span class="hljs-title function_" data-en="1275">equal</span>(
  robin.<span class="hljs-property" data-en="1276">name</span>, <span class="hljs-string" data-en="1277">'Robin'</span>
);
</code></pre>
      <h2 id="class-method-decorators" tabindex="-1" data-en="1278">Class method decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-method-decorators" aria-hidden="true" data-en="1279">#</a></h2>
      <p data-en="1280">Class method decorators have the following type signature:</p>
      <pre data-en="1281"><code class="language-ts" data-en="1282"><span class="hljs-keyword" data-en="1283">type</span> <span class="hljs-title class_" data-en="1284">ClassMethodDecorator</span> = <span class="hljs-function" data-en="1285">(<span class="hljs-params" data-en="1286">
  <span class="hljs-attr" data-en="1287">value</span>: <span class="hljs-title class_" data-en="1288">Function</span>,
  <span class="hljs-attr" data-en="1289">context</span>: {
    kind: <span class="hljs-string" data-en="1290">'method'</span>;
    name: <span class="hljs-built_in" data-en="1291">string</span> | <span class="hljs-built_in" data-en="1292">symbol</span>;
    <span class="hljs-keyword" data-en="1293">static</span>: <span class="hljs-built_in" data-en="1294">boolean</span>;
    <span class="hljs-keyword" data-en="1295">private</span>: <span class="hljs-built_in" data-en="1296">boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in" data-en="1297">unknown</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" data-en="1298">void</span>): <span class="hljs-built_in" data-en="1299">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_" data-en="1300">Function</span> | <span class="hljs-built_in" data-en="1301">void</span>;
</code></pre>
      <p data-en="1302">Abilities of a method decorator:</p>
      <ul data-en="1303">
        <li data-en="1304">It can change the decorated method by changing <code data-en="1305">value</code>.</li>
        <li data-en="1306">It can replace the decorated method by returning a function.</li>
        <li data-en="1307">It can register initializers.</li>
        <li data-en="1308"><code data-en="1309">context.access</code> only supports getting the value of its property, not setting it.</li>
      </ul>
      <p data-en="1310">Constructors can’t be decorated: They look like methods, but they aren’t really methods.</p>
      <h3 id="example-tracing-method-invocations" tabindex="-1" data-en="1311">Example: tracing method invocations&nbsp;&nbsp;<a class="heading-anchor" href="#example-tracing-method-invocations" aria-hidden="true" data-en="1312">#</a></h3>
      <p data-en="1313">The decorator <code data-en="1314">@trace</code> wraps methods so that their invocations and results are logged to the console:</p>
      <pre data-en="1315"><code class="language-js" data-en="1316"><span class="hljs-keyword" data-en="1317">function</span> <span class="hljs-title function_" data-en="1318">trace</span>(<span class="hljs-params" data-en="1319">value, {kind, name}</span>) {
  <span class="hljs-keyword" data-en="1320">if</span> (kind === <span class="hljs-string" data-en="1321">'method'</span>) {
    <span class="hljs-keyword" data-en="1322">return</span> <span class="hljs-keyword" data-en="1323">function</span> (<span class="hljs-params" data-en="1324">...args</span>) {
      <span class="hljs-variable language_" data-en="1325">console</span>.<span class="hljs-title function_" data-en="1326">log</span>(<span class="hljs-string" data-en="1327">`CALL <span class="hljs-subst" data-en="1328">${name}</span>: <span class="hljs-subst" data-en="1329">${<span class="hljs-built_in" data-en="1330">JSON</span>.stringify(args)}</span>`</span>);
      <span class="hljs-keyword" data-en="1331">const</span> result = value.<span class="hljs-title function_" data-en="1332">apply</span>(<span class="hljs-variable language_" data-en="1333">this</span>, args);
      <span class="hljs-variable language_" data-en="1334">console</span>.<span class="hljs-title function_" data-en="1335">log</span>(<span class="hljs-string" data-en="1336">'=&gt; '</span> + <span class="hljs-title class_" data-en="1337">JSON</span>.<span class="hljs-title function_" data-en="1338">stringify</span>(result));
      <span class="hljs-keyword" data-en="1339">return</span> result;
    };
  }
}

<span class="hljs-keyword" data-en="1340">class</span> <span class="hljs-title class_" data-en="1341">StringBuilder</span> {
  #str = <span class="hljs-string" data-en="1342">''</span>;
  @trace
  <span class="hljs-title function_" data-en="1343">add</span>(<span class="hljs-params" data-en="1344">str</span>) {
    <span class="hljs-variable language_" data-en="1345">this</span>.#str += str;
  }
  @trace
  <span class="hljs-title function_" data-en="1346">toString</span>(<span class="hljs-params" data-en="1347"></span>) {
    <span class="hljs-keyword" data-en="1348">return</span> <span class="hljs-variable language_" data-en="1349">this</span>.#str;
  }
}

<span class="hljs-keyword" data-en="1350">const</span> sb = <span class="hljs-keyword" data-en="1351">new</span> <span class="hljs-title class_" data-en="1352">StringBuilder</span>();
sb.<span class="hljs-title function_" data-en="1353">add</span>(<span class="hljs-string" data-en="1354">'Home'</span>);
sb.<span class="hljs-title function_" data-en="1355">add</span>(<span class="hljs-string" data-en="1356">'page'</span>);
assert.<span class="hljs-title function_" data-en="1357">equal</span>(
  sb.<span class="hljs-title function_" data-en="1358">toString</span>(), <span class="hljs-string" data-en="1359">'Homepage'</span>
);

<span class="hljs-comment" data-en="1360">// Output:</span>
<span class="hljs-comment" data-en="1361">// CALL add: ["Home"]</span>
<span class="hljs-comment" data-en="1362">// =&gt; undefined</span>
<span class="hljs-comment" data-en="1363">// CALL add: ["page"]</span>
<span class="hljs-comment" data-en="1364">// =&gt; undefined</span>
<span class="hljs-comment" data-en="1365">// CALL toString: []</span>
<span class="hljs-comment" data-en="1366">// =&gt; "Homepage"</span>
</code></pre>
      <h3 id="example%3A-binding-methods-to-instances" tabindex="-1" data-en="1367">Example: binding methods to instances&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-binding-methods-to-instances" aria-hidden="true" data-en="1368">#</a></h3>
      <p data-en="1369">Normally, extracting methods (line A) means that we can’t function-call them because that sets <code data-en="1370">this</code> to <code data-en="1371">undefined</code>:</p>
      <pre data-en="1372"><code class="language-js" data-en="1373"><span class="hljs-keyword" data-en="1374">class</span> <span class="hljs-title class_" data-en="1375">Color1</span> {
  #name;
  <span class="hljs-title function_" data-en="1376">constructor</span>(<span class="hljs-params" data-en="1377">name</span>) {
    <span class="hljs-variable language_" data-en="1378">this</span>.#name = name;
  }
  <span class="hljs-title function_" data-en="1379">toString</span>(<span class="hljs-params" data-en="1380"></span>) {
    <span class="hljs-keyword" data-en="1381">return</span> <span class="hljs-string" data-en="1382">`Color(<span class="hljs-subst" data-en="1383">${<span class="hljs-variable language_" data-en="1384">this</span>.#name}</span>)`</span>;
  }
}

<span class="hljs-keyword" data-en="1385">const</span> green1 = <span class="hljs-keyword" data-en="1386">new</span> <span class="hljs-title class_" data-en="1387">Color1</span>(<span class="hljs-string" data-en="1388">'green'</span>);
<span class="hljs-keyword" data-en="1389">const</span> toString1 = green1.<span class="hljs-property" data-en="1390">toString</span>; <span class="hljs-comment" data-en="1391">// (A)</span>
assert.<span class="hljs-title function_" data-en="1392">throws</span>(
  <span class="hljs-function" data-en="1393">() =&gt;</span> <span class="hljs-title function_" data-en="1394">toString1</span>(),
  <span class="hljs-regexp" data-en="1395">/^TypeError: Cannot read properties of undefined/</span>
);
</code></pre>
      <p data-en="1396">We can fix that via the decorator <code data-en="1397">@bind</code>:</p>
      <pre data-en="1398"><code class="language-js" data-en="1399"><span class="hljs-keyword" data-en="1400">function</span> <span class="hljs-title function_" data-en="1401">bind</span>(<span class="hljs-params" data-en="1402">value, {kind, name, addInitializer}</span>) {
  <span class="hljs-keyword" data-en="1403">if</span> (kind === <span class="hljs-string" data-en="1404">'method'</span>) {
    <span class="hljs-title function_" data-en="1405">addInitializer</span>(<span class="hljs-keyword" data-en="1406">function</span> (<span class="hljs-params" data-en="1407"></span>) { <span class="hljs-comment" data-en="1408">// (B)</span>
      <span class="hljs-variable language_" data-en="1409">this</span>[name] = value.<span class="hljs-title function_" data-en="1410">bind</span>(<span class="hljs-variable language_" data-en="1411">this</span>); <span class="hljs-comment" data-en="1412">// (C)</span>
    });
  }
}

<span class="hljs-keyword" data-en="1413">class</span> <span class="hljs-title class_" data-en="1414">Color2</span> {
  #name;
  <span class="hljs-title function_" data-en="1415">constructor</span>(<span class="hljs-params" data-en="1416">name</span>) {
    <span class="hljs-variable language_" data-en="1417">this</span>.#name = name;
  }
  @bind
  <span class="hljs-title function_" data-en="1418">toString</span>(<span class="hljs-params" data-en="1419"></span>) {
    <span class="hljs-keyword" data-en="1420">return</span> <span class="hljs-string" data-en="1421">`Color(<span class="hljs-subst" data-en="1422">${<span class="hljs-variable language_" data-en="1423">this</span>.#name}</span>)`</span>;
  }
}

<span class="hljs-keyword" data-en="1424">const</span> green2 = <span class="hljs-keyword" data-en="1425">new</span> <span class="hljs-title class_" data-en="1426">Color2</span>(<span class="hljs-string" data-en="1427">'green'</span>);
<span class="hljs-keyword" data-en="1428">const</span> toString2 = green2.<span class="hljs-property" data-en="1429">toString</span>;
assert.<span class="hljs-title function_" data-en="1430">equal</span>(
  <span class="hljs-title function_" data-en="1431">toString2</span>(), <span class="hljs-string" data-en="1432">'Color(green)'</span>
);

<span class="hljs-comment" data-en="1433">// The own property green2.toString is different</span>
<span class="hljs-comment" data-en="1434">// from Color2.prototype.toString</span>
assert.<span class="hljs-title function_" data-en="1435">ok</span>(<span class="hljs-title class_" data-en="1436">Object</span>.<span class="hljs-title function_" data-en="1437">hasOwn</span>(green2, <span class="hljs-string" data-en="1438">'toString'</span>));
assert.<span class="hljs-title function_" data-en="1439">notEqual</span>(
  green2.<span class="hljs-property" data-en="1440">toString</span>,
  <span class="hljs-title class_" data-en="1441">Color2</span>.<span class="hljs-property" data-en="1442"><span class="hljs-keyword" data-en="1443">prototype</span></span>.<span class="hljs-property" data-en="1444">toString</span>
);
</code></pre>
      <p data-en="1445">Per decorated method, the initializer registered in line B is invoked whenever an instance is created and adds an own property whose value is a function with a fixed <code data-en="1446">this</code> (line C).</p>
      <h3 id="example%3A-applying-functions-to-methods" tabindex="-1" data-en="1447">Example: applying functions to methods&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-applying-functions-to-methods" aria-hidden="true" data-en="1448">#</a></h3>
      <p data-en="1449">The library <code data-en="1450">core-decorators</code> has <a href="https://github.com/jayphelps/core-decorators#decorate" data-en="1451">a decorator</a> that lets us apply functions to methods. That enables us to use helper functions such as Lodash’s <code data-en="1452">memoize()</code>. The following code shows an implementation <code data-en="1453">@applyFunction</code> of such a decorator:</p>
      <pre data-en="1454"><code class="language-js" data-en="1455"><span class="hljs-keyword" data-en="1456">import</span> { memoize } <span class="hljs-keyword" data-en="1457">from</span> <span class="hljs-string" data-en="1458">'lodash-es'</span>;

<span class="hljs-keyword" data-en="1459">function</span> <span class="hljs-title function_" data-en="1460">applyFunction</span>(<span class="hljs-params" data-en="1461">functionFactory</span>) {
  <span class="hljs-keyword" data-en="1462">return</span> <span class="hljs-function" data-en="1463">(<span class="hljs-params" data-en="1464">value, {kind}</span>) =&gt;</span> { <span class="hljs-comment" data-en="1465">// decorator function</span>
    <span class="hljs-keyword" data-en="1466">if</span> (kind === <span class="hljs-string" data-en="1467">'method'</span>) {
      <span class="hljs-keyword" data-en="1468">return</span> <span class="hljs-title function_" data-en="1469">functionFactory</span>(value);
    }
  };
}

<span class="hljs-keyword" data-en="1470">let</span> invocationCount = <span class="hljs-number" data-en="1471">0</span>;

<span class="hljs-keyword" data-en="1472">class</span> <span class="hljs-title class_" data-en="1473">Task</span> {
  @<span class="hljs-title function_" data-en="1474">applyFunction</span>(memoize)
  <span class="hljs-title function_" data-en="1475">expensiveOperation</span>(<span class="hljs-params" data-en="1476">str</span>) {
    invocationCount++;
    <span class="hljs-comment" data-en="1477">// Expensive processing of `str` 😀</span>
    <span class="hljs-keyword" data-en="1478">return</span> str + str;
  }
}

<span class="hljs-keyword" data-en="1479">const</span> task = <span class="hljs-keyword" data-en="1480">new</span> <span class="hljs-title class_" data-en="1481">Task</span>();
assert.<span class="hljs-title function_" data-en="1482">equal</span>(
  task.<span class="hljs-title function_" data-en="1483">expensiveOperation</span>(<span class="hljs-string" data-en="1484">'abc'</span>),
  <span class="hljs-string" data-en="1485">'abcabc'</span>
);
assert.<span class="hljs-title function_" data-en="1486">equal</span>(
  task.<span class="hljs-title function_" data-en="1487">expensiveOperation</span>(<span class="hljs-string" data-en="1488">'abc'</span>),
  <span class="hljs-string" data-en="1489">'abcabc'</span>
);
assert.<span class="hljs-title function_" data-en="1490">equal</span>(
  invocationCount, <span class="hljs-number" data-en="1491">1</span>
);
</code></pre>
      <h2 id="class-getter-decorators%2C-class-setter-decorators" tabindex="-1" data-en="1492">Class getter decorators, class setter decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-getter-decorators%2C-class-setter-decorators" aria-hidden="true" data-en="1493">#</a></h2>
      <p data-en="1494">These are the type signatures of getter decorators and setter decorators:</p>
      <pre data-en="1495"><code class="language-ts" data-en="1496"><span class="hljs-keyword" data-en="1497">type</span> <span class="hljs-title class_" data-en="1498">ClassGetterDecorator</span> = <span class="hljs-function" data-en="1499">(<span class="hljs-params" data-en="1500">
  <span class="hljs-attr" data-en="1501">value</span>: <span class="hljs-title class_" data-en="1502">Function</span>,
  <span class="hljs-attr" data-en="1503">context</span>: {
    kind: <span class="hljs-string" data-en="1504">'getter'</span>;
    name: <span class="hljs-built_in" data-en="1505">string</span> | <span class="hljs-built_in" data-en="1506">symbol</span>;
    <span class="hljs-keyword" data-en="1507">static</span>: <span class="hljs-built_in" data-en="1508">boolean</span>;
    <span class="hljs-keyword" data-en="1509">private</span>: <span class="hljs-built_in" data-en="1510">boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in" data-en="1511">unknown</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" data-en="1512">void</span>): <span class="hljs-built_in" data-en="1513">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_" data-en="1514">Function</span> | <span class="hljs-built_in" data-en="1515">void</span>;

<span class="hljs-keyword" data-en="1516">type</span> <span class="hljs-title class_" data-en="1517">ClassSetterDecorator</span> = <span class="hljs-function" data-en="1518">(<span class="hljs-params" data-en="1519">
  <span class="hljs-attr" data-en="1520">value</span>: <span class="hljs-title class_" data-en="1521">Function</span>,
  <span class="hljs-attr" data-en="1522">context</span>: {
    kind: <span class="hljs-string" data-en="1523">'setter'</span>;
    name: <span class="hljs-built_in" data-en="1524">string</span> | <span class="hljs-built_in" data-en="1525">symbol</span>;
    <span class="hljs-keyword" data-en="1526">static</span>: <span class="hljs-built_in" data-en="1527">boolean</span>;
    <span class="hljs-keyword" data-en="1528">private</span>: <span class="hljs-built_in" data-en="1529">boolean</span>;
    access: { set: (value: <span class="hljs-built_in" data-en="1530">unknown</span>) =&gt; <span class="hljs-built_in" data-en="1531">void</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" data-en="1532">void</span>): <span class="hljs-built_in" data-en="1533">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_" data-en="1534">Function</span> | <span class="hljs-built_in" data-en="1535">void</span>;
</code></pre>
      <p data-en="1536">Getter decorators and setter decorators have similar abilities to method decorators.</p>
      <h3 id="example%3A-computing-values-lazily" tabindex="-1" data-en="1537">Example: computing values lazily&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-computing-values-lazily" aria-hidden="true" data-en="1538">#</a></h3>
      <p data-en="1539">To implement a property whose value is computed <em data-en="1540">lazily</em> (on demand), we use two techniques:</p>
      <ul data-en="1541">
        <li data-en="1542">
          <p data-en="1543">We implement the property via a getter. That way, the code that computes its value, is only executed if the property is read.</p>
        </li>
        <li data-en="1544">
          <p data-en="1545">The decorator <code data-en="1546">@lazy</code> wraps the original getter: When the wrapper is invoked for the first time, it invokes the getter and creates an own data property whose value is the result. From now on, the own property overrides the inherited getter whenever someone reads the property.</p>
        </li>
      </ul>
      <pre data-en="1547"><code class="language-js" data-en="1548"><span class="hljs-keyword" data-en="1549">class</span> <span class="hljs-title class_" data-en="1550">C</span> {
  @lazy
  <span class="hljs-keyword" data-en="1551">get</span> <span class="hljs-title function_" data-en="1552">value</span>() {
    <span class="hljs-variable language_" data-en="1553">console</span>.<span class="hljs-title function_" data-en="1554">log</span>(<span class="hljs-string" data-en="1555">'COMPUTING'</span>);
    <span class="hljs-keyword" data-en="1556">return</span> <span class="hljs-string" data-en="1557">'Result of computation'</span>;
  }
}

<span class="hljs-keyword" data-en="1558">function</span> <span class="hljs-title function_" data-en="1559">lazy</span>(<span class="hljs-params" data-en="1560">value, {kind, name, addInitializer}</span>) {
  <span class="hljs-keyword" data-en="1561">if</span> (kind === <span class="hljs-string" data-en="1562">'getter'</span>) {
    <span class="hljs-keyword" data-en="1563">return</span> <span class="hljs-keyword" data-en="1564">function</span> (<span class="hljs-params" data-en="1565"></span>) {
      <span class="hljs-keyword" data-en="1566">const</span> result = value.<span class="hljs-title function_" data-en="1567">call</span>(<span class="hljs-variable language_" data-en="1568">this</span>);
      <span class="hljs-title class_" data-en="1569">Object</span>.<span class="hljs-title function_" data-en="1570">defineProperty</span>( <span class="hljs-comment" data-en="1571">// (A)</span>
        <span class="hljs-variable language_" data-en="1572">this</span>, name,
        {
          <span class="hljs-attr" data-en="1573">value</span>: result,
          <span class="hljs-attr" data-en="1574">writable</span>: <span class="hljs-literal" data-en="1575">false</span>,
        }
      );
      <span class="hljs-keyword" data-en="1576">return</span> result;
    };
  }
}

<span class="hljs-variable language_" data-en="1577">console</span>.<span class="hljs-title function_" data-en="1578">log</span>(<span class="hljs-string" data-en="1579">'1 new C()'</span>);
<span class="hljs-keyword" data-en="1580">const</span> inst = <span class="hljs-keyword" data-en="1581">new</span> <span class="hljs-title function_" data-en="1582">C</span>();
<span class="hljs-variable language_" data-en="1583">console</span>.<span class="hljs-title function_" data-en="1584">log</span>(<span class="hljs-string" data-en="1585">'2 inst.value'</span>);
assert.<span class="hljs-title function_" data-en="1586">equal</span>(inst.<span class="hljs-property" data-en="1587">value</span>, <span class="hljs-string" data-en="1588">'Result of computation'</span>);
<span class="hljs-variable language_" data-en="1589">console</span>.<span class="hljs-title function_" data-en="1590">log</span>(<span class="hljs-string" data-en="1591">'3 inst.value'</span>);
assert.<span class="hljs-title function_" data-en="1592">equal</span>(inst.<span class="hljs-property" data-en="1593">value</span>, <span class="hljs-string" data-en="1594">'Result of computation'</span>);
<span class="hljs-variable language_" data-en="1595">console</span>.<span class="hljs-title function_" data-en="1596">log</span>(<span class="hljs-string" data-en="1597">'4 end'</span>);

<span class="hljs-comment" data-en="1598">// Output:</span>
<span class="hljs-comment" data-en="1599">// 1 new C()</span>
<span class="hljs-comment" data-en="1600">// 2 inst.value</span>
<span class="hljs-comment" data-en="1601">// COMPUTING</span>
<span class="hljs-comment" data-en="1602">// 3 inst.value</span>
<span class="hljs-comment" data-en="1603">// 4 end</span>
</code></pre>
      <p data-en="1604">Note that property <code data-en="1605">.[name]</code> is immutable (because there is only a getter), which is why we have to define the property (line A) and can’t use assignment.</p>
      <h2 id="class-field-decorators" tabindex="-1" data-en="1606">Class field decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-field-decorators" aria-hidden="true" data-en="1607">#</a></h2>
      <p data-en="1608">Class field decorators have the following type signature:</p>
      <pre data-en="1609"><code class="language-ts" data-en="1610"><span class="hljs-keyword" data-en="1611">type</span> <span class="hljs-title class_" data-en="1612">ClassFieldDecorator</span> = <span class="hljs-function" data-en="1613">(<span class="hljs-params" data-en="1614">
  <span class="hljs-attr" data-en="1615">value</span>: <span class="hljs-literal" data-en="1616">undefined</span>,
  <span class="hljs-attr" data-en="1617">context</span>: {
    kind: <span class="hljs-string" data-en="1618">'field'</span>;
    name: <span class="hljs-built_in" data-en="1619">string</span> | <span class="hljs-built_in" data-en="1620">symbol</span>;
    <span class="hljs-keyword" data-en="1621">static</span>: <span class="hljs-built_in" data-en="1622">boolean</span>;
    <span class="hljs-keyword" data-en="1623">private</span>: <span class="hljs-built_in" data-en="1624">boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in" data-en="1625">unknown</span>, set: (value: <span class="hljs-built_in" data-en="1626">unknown</span>) =&gt; <span class="hljs-built_in" data-en="1627">void</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" data-en="1628">void</span>): <span class="hljs-built_in" data-en="1629">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-function" data-en="1630">(<span class="hljs-params" data-en="1631"><span class="hljs-attr" data-en="1632">initialValue</span>: <span class="hljs-built_in" data-en="1633">unknown</span></span>) =&gt;</span> <span class="hljs-built_in" data-en="1634">unknown</span> | <span class="hljs-built_in" data-en="1635">void</span>;
</code></pre>
      <p data-en="1636">Abilities of a field decorator:</p>
      <ul data-en="1637">
        <li data-en="1638">
          <p data-en="1639">It cannot change or replace its field. If we need that functionality, we have to use an <em data-en="1640">auto-accessor</em> (what that is, is described <a href="#auto-accessors" data-en="1641">later</a>).</p>
        </li>
        <li data-en="1642">
          <p data-en="1643">It can change the value with which “its” field is initialized, by returning a function that receives the original initialization value and returns a new initialization value.</p>
          <ul data-en="1644">
            <li data-en="1645">Inside that function, <code data-en="1646">this</code> refers to the current instance.</li>
          </ul>
        </li>
        <li data-en="1647">
          <p data-en="1648">It can register initializers. That is a recent change (post-2022-03) of the decorators API and wasn’t possible before.</p>
        </li>
      </ul>
      <ul data-en="1649">
        <li data-en="1650">It can expose access to its field (even if it’s private) via <code data-en="1651">context.access</code>.</li>
      </ul>
      <h3 id="example%3A-changing-initialization-values-of-fields" tabindex="-1" data-en="1652">Example: changing initialization values of fields&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-changing-initialization-values-of-fields" aria-hidden="true" data-en="1653">#</a></h3>
      <p data-en="1654">The decorator <code data-en="1655">@twice</code> doubles the original initialization value of a field by returning a function that performs this change:</p>
      <pre data-en="1656"><code class="language-js" data-en="1657"><span class="hljs-keyword" data-en="1658">function</span> <span class="hljs-title function_" data-en="1659">twice</span>(<span class="hljs-params" data-en="1660"></span>) {
  <span class="hljs-keyword" data-en="1661">return</span> <span class="hljs-function" data-en="1662"><span class="hljs-params" data-en="1663">initialValue</span> =&gt;</span> initialValue * <span class="hljs-number" data-en="1664">2</span>;
}

<span class="hljs-keyword" data-en="1665">class</span> <span class="hljs-title class_" data-en="1666">C</span> {
  @twice
  field = <span class="hljs-number" data-en="1667">3</span>;
}

<span class="hljs-keyword" data-en="1668">const</span> inst = <span class="hljs-keyword" data-en="1669">new</span> <span class="hljs-title function_" data-en="1670">C</span>();
assert.<span class="hljs-title function_" data-en="1671">equal</span>(
  inst.<span class="hljs-property" data-en="1672">field</span>, <span class="hljs-number" data-en="1673">6</span>
);
</code></pre>
      <h3 id="read-only-fields" tabindex="-1" data-en="1674">Example: read-only fields (instance public fields)&nbsp;&nbsp;<a class="heading-anchor" href="#read-only-fields" aria-hidden="true" data-en="1675">#</a></h3>
      <p data-en="1676">The decorator <code data-en="1677">@readOnly</code> makes a field immutable. It waits until the field was completely set up (either via an assignment or via the constructor) before it does so.</p>
      <pre data-en="1678"><code class="language-js" data-en="1679"><span class="hljs-keyword" data-en="1680">const</span> readOnlyFieldKeys = <span class="hljs-title class_" data-en="1681">Symbol</span>(<span class="hljs-string" data-en="1682">'readOnlyFieldKeys'</span>);

@readOnly
<span class="hljs-keyword" data-en="1683">class</span> <span class="hljs-title class_" data-en="1684">Color</span> {
  @readOnly
  name;
  <span class="hljs-title function_" data-en="1685">constructor</span>(<span class="hljs-params" data-en="1686">name</span>) {
    <span class="hljs-variable language_" data-en="1687">this</span>.<span class="hljs-property" data-en="1688">name</span> = name;
  }
}

<span class="hljs-keyword" data-en="1689">const</span> blue = <span class="hljs-keyword" data-en="1690">new</span> <span class="hljs-title class_" data-en="1691">Color</span>(<span class="hljs-string" data-en="1692">'blue'</span>);
assert.<span class="hljs-title function_" data-en="1693">equal</span>(blue.<span class="hljs-property" data-en="1694">name</span>, <span class="hljs-string" data-en="1695">'blue'</span>);
assert.<span class="hljs-title function_" data-en="1696">throws</span>(
  <span class="hljs-function" data-en="1697">() =&gt;</span> blue.<span class="hljs-property" data-en="1698">name</span> = <span class="hljs-string" data-en="1699">'brown'</span>,
  <span class="hljs-regexp" data-en="1700">/^TypeError: Cannot assign to read only property 'name'/</span>
);

<span class="hljs-keyword" data-en="1701">function</span> <span class="hljs-title function_" data-en="1702">readOnly</span>(<span class="hljs-params" data-en="1703">value, {kind, name}</span>) {
  <span class="hljs-keyword" data-en="1704">if</span> (kind === <span class="hljs-string" data-en="1705">'field'</span>) { <span class="hljs-comment" data-en="1706">// (A)</span>
    <span class="hljs-keyword" data-en="1707">return</span> <span class="hljs-keyword" data-en="1708">function</span> (<span class="hljs-params" data-en="1709"></span>) {
      <span class="hljs-keyword" data-en="1710">if</span> (!<span class="hljs-variable language_" data-en="1711">this</span>[readOnlyFieldKeys]) {
        <span class="hljs-variable language_" data-en="1712">this</span>[readOnlyFieldKeys] = [];
      }
      <span class="hljs-variable language_" data-en="1713">this</span>[readOnlyFieldKeys].<span class="hljs-title function_" data-en="1714">push</span>(name);
    };
  }
  <span class="hljs-keyword" data-en="1715">if</span> (kind === <span class="hljs-string" data-en="1716">'class'</span>) { <span class="hljs-comment" data-en="1717">// (B)</span>
    <span class="hljs-keyword" data-en="1718">return</span> <span class="hljs-keyword" data-en="1719">function</span> (<span class="hljs-params" data-en="1720">...args</span>) {
      <span class="hljs-keyword" data-en="1721">const</span> inst = <span class="hljs-keyword" data-en="1722">new</span> <span class="hljs-title function_" data-en="1723">value</span>(...args);
      <span class="hljs-keyword" data-en="1724">for</span> (<span class="hljs-keyword" data-en="1725">const</span> key <span class="hljs-keyword" data-en="1726">of</span> inst[readOnlyFieldKeys]) {
        <span class="hljs-title class_" data-en="1727">Object</span>.<span class="hljs-title function_" data-en="1728">defineProperty</span>(inst, key, {<span class="hljs-attr" data-en="1729">writable</span>: <span class="hljs-literal" data-en="1730">false</span>});
      }
      <span class="hljs-keyword" data-en="1731">return</span> inst;
    }
  }
}
</code></pre>
      <p data-en="1732">We need two steps to implement the functionality of <code data-en="1733">@readOnly</code> (which is why the class is also decorated):</p>
      <ul data-en="1734">
        <li data-en="1735">We first collect all keys of read-only fields (line A).</li>
        <li data-en="1736">Then we wait until the instance was completely set up and make the fields, whose keys we collected, non-writable (line B). We need to wrap the class because decorator initializers are executed too early.</li>
      </ul>
      <p data-en="1737">Similarly to making instances immutable, this decorator breaks <code data-en="1738">instanceof</code>. The same workaround can be used here, too.</p>
      <p data-en="1739">We’ll later see <a href="#read-only-auto-accessors" data-en="1740">a version <code data-en="1741">@readOnly</code> that works with auto-accessors</a> instead of fields. That implementation does not require the class to be decorated.</p>
      <h3 id="example%3A-dependency-injection-(instance-public-fields)" tabindex="-1" data-en="1742">Example: dependency injection (instance public fields)&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-dependency-injection-(instance-public-fields)" aria-hidden="true" data-en="1743">#</a></h3>
      <p data-en="1744"><em data-en="1745">Dependency injection</em> is motivated by the following observation: If we provide the constructor of a class with its dependencies (vs. the constructor setting them up itself), then it’s easier to adapt the dependencies to different environments, including testing.</p>
      <p data-en="1746">This is an <em data-en="1747">inversion of control</em>: The constructor does not do its own setup, we do it for it. Approaches for doing dependency injection:</p>
      <ol data-en="1748">
        <li data-en="1749">Manually, by creating dependencies and passing them to the constructor.</li>
        <li data-en="1750">Via “contexts” in frontend frameworks such as React</li>
        <li data-en="1751">Via decorators and a <em data-en="1752">dependency injection registry</em> (a minor variation of <em data-en="1753">dependency injection containers</em>)</li>
      </ol>
      <p data-en="1754">The following code is a simple implementation of approach #3:</p>
      <pre data-en="1755"><code class="language-js" data-en="1756"><span class="hljs-keyword" data-en="1757">const</span> {registry, inject} = <span class="hljs-title function_" data-en="1758">createRegistry</span>();

<span class="hljs-keyword" data-en="1759">class</span> <span class="hljs-title class_" data-en="1760">Logger</span> {
  <span class="hljs-title function_" data-en="1761">log</span>(<span class="hljs-params" data-en="1762">str</span>) {
    <span class="hljs-variable language_" data-en="1763">console</span>.<span class="hljs-title function_" data-en="1764">log</span>(str);
  }
}
<span class="hljs-keyword" data-en="1765">class</span> <span class="hljs-title class_" data-en="1766">Main</span> {
  @inject logger;
  <span class="hljs-title function_" data-en="1767">run</span>(<span class="hljs-params" data-en="1768"></span>) {
    <span class="hljs-variable language_" data-en="1769">this</span>.<span class="hljs-property" data-en="1770">logger</span>.<span class="hljs-title function_" data-en="1771">log</span>(<span class="hljs-string" data-en="1772">'Hello!'</span>);
  }
}

registry.<span class="hljs-title function_" data-en="1773">register</span>(<span class="hljs-string" data-en="1774">'logger'</span>, <span class="hljs-title class_" data-en="1775">Logger</span>);
<span class="hljs-keyword" data-en="1776">new</span> <span class="hljs-title class_" data-en="1777">Main</span>().<span class="hljs-title function_" data-en="1778">run</span>();

<span class="hljs-comment" data-en="1779">// Output:</span>
<span class="hljs-comment" data-en="1780">// Hello!</span>
</code></pre>
      <p data-en="1781">This is how <code data-en="1782">createRegistry()</code> is implemented:</p>
      <pre data-en="1783"><code class="language-js" data-en="1784"><span class="hljs-keyword" data-en="1785">function</span> <span class="hljs-title function_" data-en="1786">createRegistry</span>(<span class="hljs-params" data-en="1787"></span>) {
  <span class="hljs-keyword" data-en="1788">const</span> nameToClass = <span class="hljs-keyword" data-en="1789">new</span> <span class="hljs-title class_" data-en="1790">Map</span>();
  <span class="hljs-keyword" data-en="1791">const</span> nameToInstance = <span class="hljs-keyword" data-en="1792">new</span> <span class="hljs-title class_" data-en="1793">Map</span>();
  <span class="hljs-keyword" data-en="1794">const</span> registry = {
    <span class="hljs-title function_" data-en="1795">register</span>(<span class="hljs-params" data-en="1796">name, componentClass</span>) {
      nameToClass.<span class="hljs-title function_" data-en="1797">set</span>(name, componentClass);
    },
    <span class="hljs-title function_" data-en="1798">getInstance</span>(<span class="hljs-params" data-en="1799">name</span>) {
      <span class="hljs-keyword" data-en="1800">if</span> (nameToInstance.<span class="hljs-title function_" data-en="1801">has</span>(name)) {
        <span class="hljs-keyword" data-en="1802">return</span> nameToInstance.<span class="hljs-title function_" data-en="1803">get</span>(name);
      }
      <span class="hljs-keyword" data-en="1804">const</span> componentClass = nameToClass.<span class="hljs-title function_" data-en="1805">get</span>(name);
      <span class="hljs-keyword" data-en="1806">if</span> (componentClass === <span class="hljs-literal" data-en="1807">undefined</span>) {
        <span class="hljs-keyword" data-en="1808">throw</span> <span class="hljs-keyword" data-en="1809">new</span> <span class="hljs-title class_" data-en="1810">Error</span>(<span class="hljs-string" data-en="1811">'Unknown component name: '</span> + name);
      }
      <span class="hljs-keyword" data-en="1812">const</span> inst = <span class="hljs-keyword" data-en="1813">new</span> <span class="hljs-title function_" data-en="1814">componentClass</span>();
      nameToInstance.<span class="hljs-title function_" data-en="1815">set</span>(name, inst);
      <span class="hljs-keyword" data-en="1816">return</span> inst;
    },
  }; 
  <span class="hljs-keyword" data-en="1817">function</span> <span class="hljs-title function_" data-en="1818">inject</span> (<span class="hljs-params" data-en="1819">_value, {kind, name}</span>) {
    <span class="hljs-keyword" data-en="1820">if</span> (kind === <span class="hljs-string" data-en="1821">'field'</span>) {
      <span class="hljs-keyword" data-en="1822">return</span> <span class="hljs-function" data-en="1823">() =&gt;</span> registry.<span class="hljs-title function_" data-en="1824">getInstance</span>(name);
    }
  }
  <span class="hljs-keyword" data-en="1825">return</span> {registry, inject};
}
</code></pre>
      <h3 id="example-friend-visibility" tabindex="-1" data-en="1826">Example: “friend”&nbsp;visibility (instance private fields)&nbsp;&nbsp;<a class="heading-anchor" href="#example-friend-visibility" aria-hidden="true" data-en="1827">#</a></h3>
      <p data-en="1828">We can change the visibility of some class members by making them private. That prevents them from being accessed publicly. There are more useful kinds of visibility, though. For example, <em data-en="1829">friend visibility</em> lets a group of <em data-en="1830">friends</em> (functions, other classes, etc.) access the member.</p>
      <p data-en="1831">There are many ways in which friends can be specified. In the following example, everyone who has access to <code data-en="1832">friendName</code>, is a friend of <code data-en="1833">classWithSecret.#name</code>. The idea is that a module contains classes and functions that collaborate and that there is some instance data that only the collaborators should be able see.</p>
      <pre data-en="1834"><code class="language-js" data-en="1835"><span class="hljs-keyword" data-en="1836">const</span> friendName = <span class="hljs-keyword" data-en="1837">new</span> <span class="hljs-title class_" data-en="1838">Friend</span>();

<span class="hljs-keyword" data-en="1839">class</span> <span class="hljs-title class_" data-en="1840">ClassWithSecret</span> {
  @friendName.<span class="hljs-property" data-en="1841">install</span> #name = <span class="hljs-string" data-en="1842">'Rumpelstiltskin'</span>;
  <span class="hljs-title function_" data-en="1843">getName</span>(<span class="hljs-params" data-en="1844"></span>) {
    <span class="hljs-keyword" data-en="1845">return</span> <span class="hljs-variable language_" data-en="1846">this</span>.#name;
  }
}

<span class="hljs-comment" data-en="1847">// Everyone who has access to `secret`, can access inst.#name</span>
<span class="hljs-keyword" data-en="1848">const</span> inst = <span class="hljs-keyword" data-en="1849">new</span> <span class="hljs-title class_" data-en="1850">ClassWithSecret</span>();
assert.<span class="hljs-title function_" data-en="1851">equal</span>(
  friendName.<span class="hljs-title function_" data-en="1852">get</span>(inst), <span class="hljs-string" data-en="1853">'Rumpelstiltskin'</span>
);
friendName.<span class="hljs-title function_" data-en="1854">set</span>(inst, <span class="hljs-string" data-en="1855">'Joe'</span>);
assert.<span class="hljs-title function_" data-en="1856">equal</span>(
  inst.<span class="hljs-title function_" data-en="1857">getName</span>(), <span class="hljs-string" data-en="1858">'Joe'</span>
);
</code></pre>
      <p data-en="1859">This is how class <code data-en="1860">Friend</code> is implemented:</p>
      <pre data-en="1861"><code class="language-js" data-en="1862"><span class="hljs-keyword" data-en="1863">class</span> <span class="hljs-title class_" data-en="1864">Friend</span> {
  #access = <span class="hljs-literal" data-en="1865">undefined</span>;
  #<span class="hljs-title function_" data-en="1866">getAccessOrThrow</span>(<span class="hljs-params" data-en="1867"></span>) {
    <span class="hljs-keyword" data-en="1868">if</span> (<span class="hljs-variable language_" data-en="1869">this</span>.#access === <span class="hljs-literal" data-en="1870">undefined</span>) {
      <span class="hljs-keyword" data-en="1871">throw</span> <span class="hljs-keyword" data-en="1872">new</span> <span class="hljs-title class_" data-en="1873">Error</span>(<span class="hljs-string" data-en="1874">'The friend decorator wasn’t used yet'</span>);
    }
    <span class="hljs-keyword" data-en="1875">return</span> <span class="hljs-variable language_" data-en="1876">this</span>.#access;
  }
  <span class="hljs-comment" data-en="1877">// An instance property whose value is a function whose `this`</span>
  <span class="hljs-comment" data-en="1878">// is fixed (bound to the instance).</span>
  install = <span class="hljs-function" data-en="1879">(<span class="hljs-params" data-en="1880">_value, {kind, access}</span>) =&gt;</span> {
    <span class="hljs-keyword" data-en="1881">if</span> (kind === <span class="hljs-string" data-en="1882">'field'</span>) {
      <span class="hljs-keyword" data-en="1883">if</span> (<span class="hljs-variable language_" data-en="1884">this</span>.#access) {
        <span class="hljs-keyword" data-en="1885">throw</span> <span class="hljs-keyword" data-en="1886">new</span> <span class="hljs-title class_" data-en="1887">Error</span>(<span class="hljs-string" data-en="1888">'This decorator can only be used once'</span>);
      }
      <span class="hljs-variable language_" data-en="1889">this</span>.#access = access;
    }
  }
  <span class="hljs-title function_" data-en="1890">get</span>(<span class="hljs-params" data-en="1891">inst</span>) {
    <span class="hljs-keyword" data-en="1892">return</span> <span class="hljs-variable language_" data-en="1893">this</span>.#<span class="hljs-title function_" data-en="1894">getAccessOrThrow</span>().<span class="hljs-property" data-en="1895">get</span>.<span class="hljs-title function_" data-en="1896">call</span>(inst);
  }
  <span class="hljs-title function_" data-en="1897">set</span>(<span class="hljs-params" data-en="1898">inst, value</span>) {
    <span class="hljs-keyword" data-en="1899">return</span> <span class="hljs-variable language_" data-en="1900">this</span>.#<span class="hljs-title function_" data-en="1901">getAccessOrThrow</span>().<span class="hljs-property" data-en="1902">set</span>.<span class="hljs-title function_" data-en="1903">call</span>(inst, value);
  }
}
</code></pre>
      <h3 id="example%3A-enums-(static-public-fields)" tabindex="-1" data-en="1904">Example: enums (static public fields)&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-enums-(static-public-fields)" aria-hidden="true" data-en="1905">#</a></h3>
      <p data-en="1906">There are many ways to implement enums. An OOP-style approach is to use a class and static properties (<a href="https://2ality.com/2016/01/enumify.html" data-en="1907">more information on this approach</a>):</p>
      <pre data-en="1908"><code class="language-js" data-en="1909"><span class="hljs-keyword" data-en="1910">class</span> <span class="hljs-title class_" data-en="1911">Color</span> {
  <span class="hljs-keyword" data-en="1912">static</span> red = <span class="hljs-keyword" data-en="1913">new</span> <span class="hljs-title class_" data-en="1914">Color</span>(<span class="hljs-string" data-en="1915">'red'</span>);
  <span class="hljs-keyword" data-en="1916">static</span> green = <span class="hljs-keyword" data-en="1917">new</span> <span class="hljs-title class_" data-en="1918">Color</span>(<span class="hljs-string" data-en="1919">'green'</span>);
  <span class="hljs-keyword" data-en="1920">static</span> blue = <span class="hljs-keyword" data-en="1921">new</span> <span class="hljs-title class_" data-en="1922">Color</span>(<span class="hljs-string" data-en="1923">'blue'</span>);
  <span class="hljs-title function_" data-en="1924">constructor</span>(<span class="hljs-params" data-en="1925">enumKey</span>) {
    <span class="hljs-variable language_" data-en="1926">this</span>.<span class="hljs-property" data-en="1927">enumKey</span> = enumKey;
  }
  <span class="hljs-title function_" data-en="1928">toString</span>(<span class="hljs-params" data-en="1929"></span>) {
    <span class="hljs-keyword" data-en="1930">return</span> <span class="hljs-string" data-en="1931">`Color(<span class="hljs-subst" data-en="1932">${<span class="hljs-variable language_" data-en="1933">this</span>.enumKey}</span>)`</span>;
  }
}
assert.<span class="hljs-title function_" data-en="1934">equal</span>(
  <span class="hljs-title class_" data-en="1935">Color</span>.<span class="hljs-property" data-en="1936">green</span>.<span class="hljs-title function_" data-en="1937">toString</span>(),
  <span class="hljs-string" data-en="1938">'Color(green)'</span>
);
</code></pre>
      <p data-en="1939">We can use a decorator to automatically:</p>
      <ul data-en="1940">
        <li data-en="1941">Create a Map from “enum keys” (the names of their fields) to enum values.</li>
        <li data-en="1942">Add enum keys to enum values – without having to pass them to the constructor.</li>
      </ul>
      <p data-en="1943">That looks as follows:</p>
      <pre data-en="1944"><code class="language-js" data-en="1945"><span class="hljs-keyword" data-en="1946">function</span> <span class="hljs-title function_" data-en="1947">enumEntry</span>(<span class="hljs-params" data-en="1948">value, {kind, name}</span>) {
  <span class="hljs-keyword" data-en="1949">if</span> (kind === <span class="hljs-string" data-en="1950">'field'</span>) {
    <span class="hljs-keyword" data-en="1951">return</span> <span class="hljs-keyword" data-en="1952">function</span> (<span class="hljs-params" data-en="1953">initialValue</span>) {
      <span class="hljs-keyword" data-en="1954">if</span> (!<span class="hljs-title class_" data-en="1955">Object</span>.<span class="hljs-title function_" data-en="1956">hasOwn</span>(<span class="hljs-variable language_" data-en="1957">this</span>, <span class="hljs-string" data-en="1958">'enumFields'</span>)) {
        <span class="hljs-variable language_" data-en="1959">this</span>.<span class="hljs-property" data-en="1960">enumFields</span> = <span class="hljs-keyword" data-en="1961">new</span> <span class="hljs-title class_" data-en="1962">Map</span>();
      }
      <span class="hljs-variable language_" data-en="1963">this</span>.<span class="hljs-property" data-en="1964">enumFields</span>.<span class="hljs-title function_" data-en="1965">set</span>(name, initialValue);
      initialValue.<span class="hljs-property" data-en="1966">enumKey</span> = name;
      <span class="hljs-keyword" data-en="1967">return</span> initialValue;
    };
  }
}

<span class="hljs-keyword" data-en="1968">class</span> <span class="hljs-title class_" data-en="1969">Color</span> {
  @enumEntry <span class="hljs-keyword" data-en="1970">static</span> red = <span class="hljs-keyword" data-en="1971">new</span> <span class="hljs-title class_" data-en="1972">Color</span>();
  @enumEntry <span class="hljs-keyword" data-en="1973">static</span> green = <span class="hljs-keyword" data-en="1974">new</span> <span class="hljs-title class_" data-en="1975">Color</span>();
  @enumEntry <span class="hljs-keyword" data-en="1976">static</span> blue = <span class="hljs-keyword" data-en="1977">new</span> <span class="hljs-title class_" data-en="1978">Color</span>();
  <span class="hljs-title function_" data-en="1979">toString</span>(<span class="hljs-params" data-en="1980"></span>) {
    <span class="hljs-keyword" data-en="1981">return</span> <span class="hljs-string" data-en="1982">`Color(<span class="hljs-subst" data-en="1983">${<span class="hljs-variable language_" data-en="1984">this</span>.enumKey}</span>)`</span>;
  }
}
assert.<span class="hljs-title function_" data-en="1985">equal</span>(
  <span class="hljs-title class_" data-en="1986">Color</span>.<span class="hljs-property" data-en="1987">green</span>.<span class="hljs-title function_" data-en="1988">toString</span>(),
  <span class="hljs-string" data-en="1989">'Color(green)'</span>
);
assert.<span class="hljs-title function_" data-en="1990">deepEqual</span>(
  <span class="hljs-title class_" data-en="1991">Color</span>.<span class="hljs-property" data-en="1992">enumFields</span>,
  <span class="hljs-keyword" data-en="1993">new</span> <span class="hljs-title class_" data-en="1994">Map</span>([
    [<span class="hljs-string" data-en="1995">'red'</span>, <span class="hljs-title class_" data-en="1996">Color</span>.<span class="hljs-property" data-en="1997">red</span>],
    [<span class="hljs-string" data-en="1998">'green'</span>, <span class="hljs-title class_" data-en="1999">Color</span>.<span class="hljs-property" data-en="2000">green</span>],
    [<span class="hljs-string" data-en="2001">'blue'</span>, <span class="hljs-title class_" data-en="2002">Color</span>.<span class="hljs-property" data-en="2003">blue</span>],
  ])
);
</code></pre>
      <h2 id="auto-accessors" tabindex="-1" data-en="2004">Auto-accessors: a new member of class definitions&nbsp;&nbsp;<a class="heading-anchor" href="#auto-accessors" aria-hidden="true" data-en="2005">#</a></h2>
      <p data-en="2006">The decorators proposal introduces a new language feature: <em data-en="2007">auto-accessors</em>. An auto-accessor is created by putting the keyword <code data-en="2008">accessor</code> before a class field. It is used like a field but implemented differently at runtime. That helps decorators as we’ll see soon. This is what auto-accessors look like:</p>
      <pre data-en="2009"><code class="language-js" data-en="2010"><span class="hljs-keyword" data-en="2011">class</span> <span class="hljs-title class_" data-en="2012">C</span> {
  <span class="hljs-keyword" data-en="2013">static</span> accessor myField1;
  <span class="hljs-keyword" data-en="2014">static</span> accessor #myField2;
  accessor myField3;
  accessor #myField4;
}
</code></pre>
      <p data-en="2015">How do fields and auto-accessors differ?</p>
      <ul data-en="2016">
        <li data-en="2017">A field creates either:
          <ul data-en="2018">
            <li data-en="2019">Properties (static or instance)</li>
            <li data-en="2020">Private slots (static or instance)</li>
          </ul>
        </li>
        <li data-en="2021">An auto-accessor creates a private slot (static or instance) for the data and:
          <ul data-en="2022">
            <li data-en="2023">A public getter-setter pair (static or prototype)</li>
            <li data-en="2024">A private getter-setter pair (static or instance)
              <ul data-en="2025">
                <li data-en="2026">Private slots are not inherited and therefore never located in prototypes.</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <p data-en="2027">Consider the following class:</p>
      <pre data-en="2028"><code class="language-js" data-en="2029"><span class="hljs-keyword" data-en="2030">class</span> <span class="hljs-title class_" data-en="2031">C</span> {
  accessor str = <span class="hljs-string" data-en="2032">'abc'</span>;
}
<span class="hljs-keyword" data-en="2033">const</span> inst = <span class="hljs-keyword" data-en="2034">new</span> <span class="hljs-title function_" data-en="2035">C</span>();
assert.<span class="hljs-title function_" data-en="2036">equal</span>(
  inst.<span class="hljs-property" data-en="2037">str</span>, <span class="hljs-string" data-en="2038">'abc'</span>
);
inst.<span class="hljs-property" data-en="2039">str</span> = <span class="hljs-string" data-en="2040">'def'</span>;
assert.<span class="hljs-title function_" data-en="2041">equal</span>(
  inst.<span class="hljs-property" data-en="2042">str</span>, <span class="hljs-string" data-en="2043">'def'</span>
);
</code></pre>
      <p data-en="2044">Internally, it looks like this:</p>
      <pre data-en="2045"><code class="language-js" data-en="2046"><span class="hljs-keyword" data-en="2047">class</span> <span class="hljs-title class_" data-en="2048">C</span> {
  #str = <span class="hljs-string" data-en="2049">'abc'</span>;
  <span class="hljs-keyword" data-en="2050">get</span> <span class="hljs-title function_" data-en="2051">str</span>() {
    <span class="hljs-keyword" data-en="2052">return</span> <span class="hljs-variable language_" data-en="2053">this</span>.#str;
  }
  <span class="hljs-keyword" data-en="2054">set</span> <span class="hljs-title function_" data-en="2055">str</span>(<span class="hljs-params" data-en="2056">value</span>) {
    <span class="hljs-variable language_" data-en="2057">this</span>.#str = value;
  }
}
</code></pre>
      <p data-en="2058">The following code shows where the getters and setters of auto-accessors are located:</p>
      <pre data-en="2059"><code class="language-js" data-en="2060"><span class="hljs-keyword" data-en="2061">class</span> <span class="hljs-title class_" data-en="2062">C</span> {
  <span class="hljs-keyword" data-en="2063">static</span> accessor myField1;
  <span class="hljs-keyword" data-en="2064">static</span> accessor #myField2;
  accessor myField3;
  accessor #myField4;

  <span class="hljs-keyword" data-en="2065">static</span> {
    <span class="hljs-comment" data-en="2066">// Static getter and setter</span>
    assert.<span class="hljs-title function_" data-en="2067">ok</span>(
      <span class="hljs-title class_" data-en="2068">Object</span>.<span class="hljs-title function_" data-en="2069">hasOwn</span>(C, <span class="hljs-string" data-en="2070">'myField1'</span>), <span class="hljs-string" data-en="2071">'myField1'</span>
    );
    <span class="hljs-comment" data-en="2072">// Static getter and setter</span>
    assert.<span class="hljs-title function_" data-en="2073">ok</span>(
      #myField2 <span class="hljs-keyword" data-en="2074">in</span> C, <span class="hljs-string" data-en="2075">'#myField2'</span>
    );

    <span class="hljs-comment" data-en="2076">// Prototype getter and setter</span>
    assert.<span class="hljs-title function_" data-en="2077">ok</span>(
      <span class="hljs-title class_" data-en="2078">Object</span>.<span class="hljs-title function_" data-en="2079">hasOwn</span>(C.<span class="hljs-property" data-en="2080"><span class="hljs-keyword" data-en="2081">prototype</span></span>, <span class="hljs-string" data-en="2082">'myField3'</span>), <span class="hljs-string" data-en="2083">'myField3'</span>
    );
    <span class="hljs-comment" data-en="2084">// Private getter and setter</span>
    <span class="hljs-comment" data-en="2085">// (stored in instances, but shared between instances)</span>
    assert.<span class="hljs-title function_" data-en="2086">ok</span>(
      #myField4 <span class="hljs-keyword" data-en="2087">in</span> <span class="hljs-keyword" data-en="2088">new</span> <span class="hljs-title function_" data-en="2089">C</span>(), <span class="hljs-string" data-en="2090">'#myField4'</span>
    );
  }
}
</code></pre>
      <p data-en="2091">For more information on why the slots of private getters, private setters and private methods are stored in instances, see <a href="https://exploringjs.com/js/book/ch_classes.html#private-methods-accessors" data-en="2092">section “Private methods and accessors”</a> in “Exploring JavaScript”.</p>
      <h3 id="why-are-auto-accessors-needed%3F" tabindex="-1" data-en="2093">Why are auto-accessors needed?&nbsp;&nbsp;<a class="heading-anchor" href="#why-are-auto-accessors-needed%3F" aria-hidden="true" data-en="2094">#</a></h3>
      <p data-en="2095">Auto-accessors are needed by decorators:</p>
      <ul data-en="2096">
        <li data-en="2097">They can only influence the values fields are initialized with.</li>
        <li data-en="2098">But they can completely replace auto-accessors.</li>
      </ul>
      <p data-en="2099">Therefore, we have to use auto-accessors instead of fields whenever a decorator needs more control than it has with fields.</p>
      <h2 id="class-auto-accessor-decorators" tabindex="-1" data-en="2100">Class auto-accessor decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-auto-accessor-decorators" aria-hidden="true" data-en="2101">#</a></h2>
      <p data-en="2102">Class auto-accessor decorators have the following type signature:</p>
      <pre data-en="2103"><code class="language-ts" data-en="2104"><span class="hljs-keyword" data-en="2105">type</span> <span class="hljs-title class_" data-en="2106">ClassAutoAccessorDecorator</span> = <span class="hljs-function" data-en="2107">(<span class="hljs-params" data-en="2108">
  <span class="hljs-attr" data-en="2109">value</span>: {
    get: () =&gt; <span class="hljs-built_in" data-en="2110">unknown</span>;
    set: (value: <span class="hljs-built_in" data-en="2111">unknown</span>) =&gt; <span class="hljs-built_in" data-en="2112">void</span>;
  },
  <span class="hljs-attr" data-en="2113">context</span>: {
    kind: <span class="hljs-string" data-en="2114">'accessor'</span>;
    name: <span class="hljs-built_in" data-en="2115">string</span> | <span class="hljs-built_in" data-en="2116">symbol</span>;
    <span class="hljs-keyword" data-en="2117">static</span>: <span class="hljs-built_in" data-en="2118">boolean</span>;
    <span class="hljs-keyword" data-en="2119">private</span>: <span class="hljs-built_in" data-en="2120">boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in" data-en="2121">unknown</span>, set: (value: <span class="hljs-built_in" data-en="2122">unknown</span>) =&gt; <span class="hljs-built_in" data-en="2123">void</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" data-en="2124">void</span>): <span class="hljs-built_in" data-en="2125">void</span>;
  }
</span>) =&gt;</span> {
  <span class="hljs-attr" data-en="2126">get</span>?: <span class="hljs-function" data-en="2127">() =&gt;</span> <span class="hljs-built_in" data-en="2128">unknown</span>;
  <span class="hljs-attr" data-en="2129">set</span>?: <span class="hljs-function" data-en="2130">(<span class="hljs-params" data-en="2131"><span class="hljs-attr" data-en="2132">value</span>: <span class="hljs-built_in" data-en="2133">unknown</span></span>) =&gt;</span> <span class="hljs-built_in" data-en="2134">void</span>;
  <span class="hljs-attr" data-en="2135">init</span>?: <span class="hljs-function" data-en="2136">(<span class="hljs-params" data-en="2137"><span class="hljs-attr" data-en="2138">initialValue</span>: <span class="hljs-built_in" data-en="2139">unknown</span></span>) =&gt;</span> <span class="hljs-built_in" data-en="2140">unknown</span>;
} | <span class="hljs-built_in" data-en="2141">void</span>;
</code></pre>
      <p data-en="2142">Abilities of an auto-accessor decorator:</p>
      <ul data-en="2143">
        <li data-en="2144">It receives the getter and the setter of the auto-accessor via its parameter <code data-en="2145">value</code>.
          <ul data-en="2146">
            <li data-en="2147"><code data-en="2148">context.access</code> provides the same functionality.</li>
          </ul>
        </li>
        <li data-en="2149">It can replace the decorated auto-accessor by returning an object with the methods <code data-en="2150">.get()</code> and/or <code data-en="2151">.set()</code>.</li>
        <li data-en="2152">It can influence the initial value of the auto-accessor by returning an object with the method <code data-en="2153">.init()</code>.</li>
        <li data-en="2154">It can register initializers.</li>
      </ul>
      <h3 id="read-only-auto-accessors" tabindex="-1" data-en="2155">Example: read-only auto-accessors&nbsp;&nbsp;<a class="heading-anchor" href="#read-only-auto-accessors" aria-hidden="true" data-en="2156">#</a></h3>
      <p data-en="2157">We have already implemented <a href="#read-only-fields" data-en="2158">a decorator <code data-en="2159">@readOnly</code> for fields</a>. Let’s do the same for auto-accessors:</p>
      <pre data-en="2160"><code class="language-js" data-en="2161"><span class="hljs-keyword" data-en="2162">const</span> <span class="hljs-variable constant_" data-en="2163">UNINITIALIZED</span> = <span class="hljs-title class_" data-en="2164">Symbol</span>(<span class="hljs-string" data-en="2165">'UNINITIALIZED'</span>);
<span class="hljs-keyword" data-en="2166">function</span> <span class="hljs-title function_" data-en="2167">readOnly</span>(<span class="hljs-params" data-en="2168">{get,set}, {name, kind}</span>) {
  <span class="hljs-keyword" data-en="2169">if</span> (kind === <span class="hljs-string" data-en="2170">'accessor'</span>) {
    <span class="hljs-keyword" data-en="2171">return</span> {
      <span class="hljs-title function_" data-en="2172">init</span>(<span class="hljs-params" data-en="2173"></span>) {
        <span class="hljs-keyword" data-en="2174">return</span> <span class="hljs-variable constant_" data-en="2175">UNINITIALIZED</span>;
      },
      <span class="hljs-title function_" data-en="2176">get</span>(<span class="hljs-params" data-en="2177"></span>) {
        <span class="hljs-keyword" data-en="2178">const</span> value = get.<span class="hljs-title function_" data-en="2179">call</span>(<span class="hljs-variable language_" data-en="2180">this</span>);
        <span class="hljs-keyword" data-en="2181">if</span> (value === <span class="hljs-variable constant_" data-en="2182">UNINITIALIZED</span>) {
          <span class="hljs-keyword" data-en="2183">throw</span> <span class="hljs-keyword" data-en="2184">new</span> <span class="hljs-title class_" data-en="2185">TypeError</span>(
            <span class="hljs-string" data-en="2186">`Accessor <span class="hljs-subst" data-en="2187">${name}</span> hasn’t been initialized yet`</span>
          );
        }
        <span class="hljs-keyword" data-en="2188">return</span> value;
      },
      <span class="hljs-title function_" data-en="2189">set</span>(<span class="hljs-params" data-en="2190">newValue</span>) {
        <span class="hljs-keyword" data-en="2191">const</span> oldValue = get.<span class="hljs-title function_" data-en="2192">call</span>(<span class="hljs-variable language_" data-en="2193">this</span>);
        <span class="hljs-keyword" data-en="2194">if</span> (oldValue !== <span class="hljs-variable constant_" data-en="2195">UNINITIALIZED</span>) {
          <span class="hljs-keyword" data-en="2196">throw</span> <span class="hljs-keyword" data-en="2197">new</span> <span class="hljs-title class_" data-en="2198">TypeError</span>(
            <span class="hljs-string" data-en="2199">`Accessor <span class="hljs-subst" data-en="2200">${name}</span> can only be set once`</span>
          );
        }
        set.<span class="hljs-title function_" data-en="2201">call</span>(<span class="hljs-variable language_" data-en="2202">this</span>, newValue);
      },
    };
  }
}

<span class="hljs-keyword" data-en="2203">class</span> <span class="hljs-title class_" data-en="2204">Color</span> {
  @readOnly
  accessor name;
  <span class="hljs-title function_" data-en="2205">constructor</span>(<span class="hljs-params" data-en="2206">name</span>) {
    <span class="hljs-variable language_" data-en="2207">this</span>.<span class="hljs-property" data-en="2208">name</span> = name;
  }
}

<span class="hljs-keyword" data-en="2209">const</span> blue = <span class="hljs-keyword" data-en="2210">new</span> <span class="hljs-title class_" data-en="2211">Color</span>(<span class="hljs-string" data-en="2212">'blue'</span>);
assert.<span class="hljs-title function_" data-en="2213">equal</span>(blue.<span class="hljs-property" data-en="2214">name</span>, <span class="hljs-string" data-en="2215">'blue'</span>);
assert.<span class="hljs-title function_" data-en="2216">throws</span>(
  <span class="hljs-function" data-en="2217">() =&gt;</span> blue.<span class="hljs-property" data-en="2218">name</span> = <span class="hljs-string" data-en="2219">'yellow'</span>,
  <span class="hljs-regexp" data-en="2220">/^TypeError: Accessor name can only be set once$/</span>
);

<span class="hljs-keyword" data-en="2221">const</span> orange = <span class="hljs-keyword" data-en="2222">new</span> <span class="hljs-title class_" data-en="2223">Color</span>(<span class="hljs-string" data-en="2224">'orange'</span>);
assert.<span class="hljs-title function_" data-en="2225">equal</span>(orange.<span class="hljs-property" data-en="2226">name</span>, <span class="hljs-string" data-en="2227">'orange'</span>);
</code></pre>
      <p data-en="2228">Compared to the field version, this decorator has one considerable advantage: It does not need to wrap the class to ensure that the decorated constructs become read-only.</p>
      <h2 id="faq" tabindex="-1" data-en="2229">Frequently asked questions&nbsp;&nbsp;<a class="heading-anchor" href="#faq" aria-hidden="true" data-en="2230">#</a></h2>
      <h3 id="function-decorators" tabindex="-1" data-en="2231">Why can’t functions be decorated?&nbsp;&nbsp;<a class="heading-anchor" href="#function-decorators" aria-hidden="true" data-en="2232">#</a></h3>
      <p data-en="2233">The current proposal focuses on classes as a starting point. <a href="#more-decorator-related-proposals" data-en="2234">Decorators for function expressions were proposed.</a> However, there hasn’t been much progress since then and there is no proposal for function <em data-en="2235">declarations</em>.</p>
      <p data-en="2236">On the other hand, functions are relatively easy to decorate “manually”:</p>
      <pre data-en="2237"><code class="language-js" data-en="2238"><span class="hljs-keyword" data-en="2239">const</span> decoratedFunc = <span class="hljs-title function_" data-en="2240">decorator</span>(<span class="hljs-function" data-en="2241">(<span class="hljs-params" data-en="2242">x, y</span>) =&gt;</span> {});
</code></pre>
      <p data-en="2243">This looks even better with <a href="https://2ality.com/2022/01/pipe-operator.html" data-en="2244">the proposed pipeline operator</a>:</p>
      <pre data-en="2245"><code class="language-js" data-en="2246"><span class="hljs-keyword" data-en="2247">const</span> <span class="hljs-title function_" data-en="2248">decoratedFunc</span> = (<span class="hljs-params" data-en="2249">x, y</span>) =&gt; {} |&gt; <span class="hljs-title function_" data-en="2250">decorator</span>(%);
</code></pre>
      <h2 id="more-decorator-related-proposals" tabindex="-1" data-en="2251">More decorator-related proposals&nbsp;&nbsp;<a class="heading-anchor" href="#more-decorator-related-proposals" aria-hidden="true" data-en="2252">#</a></h2>
      <p data-en="2253">The following ECMAScript proposals provide more decorator-related features:</p>
      <ul data-en="2254">
        <li data-en="2255">Stage 2: <a href="https://github.com/tc39/proposal-decorator-metadata" data-en="2256">“Decorator Metadata”</a> by Chris Garrett (last update: 2022-04-11)
          <ul data-en="2257">
            <li data-en="2258">Quote: “This proposal seeks to extend the Decorators proposal by adding the ability for decorators to associate metadata with the value being decorated.”</li>
          </ul>
        </li>
        <li data-en="2259">Stage 0: <a href="https://docs.google.com/document/d/1ikxIP5-RVYq6d_f8lAvf3pKC00W78ueyp-xIZ6q67uU" data-en="2260">“Function Expression Decorators”</a> by Igor Minar (last update: 2016-01-25)</li>
        <li data-en="2261">Stage 0: <a href="https://docs.google.com/document/d/1Qpkqf_8NzAwfD8LdnqPjXAQ2wwh8BBUGynhn-ZlCWT0" data-en="2262">“Method Parameter Decorators”</a> by Igor Minar (last update: 2016-01-25)</li>
      </ul>
      <h2 id="resources" tabindex="-1" data-en="2263">Resources&nbsp;&nbsp;<a class="heading-anchor" href="#resources" aria-hidden="true" data-en="2264">#</a></h2>
      <h3 id="decorator-implementations" tabindex="-1" data-en="2265">Implementations&nbsp;&nbsp;<a class="heading-anchor" href="#decorator-implementations" aria-hidden="true" data-en="2266">#</a></h3>
      <ul data-en="2267">
        <li data-en="2268">Babel currently has the best support for stage 3 decorators, via <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators" data-en="2269"><code data-en="2270">@babel/plugin-proposal-decorators</code></a>.
          <ul data-en="2271">
            <li data-en="2272">Be sure to pick <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators#version" data-en="2273">the latest decorator version</a>.</li>
            <li data-en="2274">All the code in this blog post was developed via Babel.</li>
          </ul>
        </li>
        <li data-en="2275">TypeScript currently supports stage 1 decorators behind a flag.
          <ul data-en="2276">
            <li data-en="2277">There is <a href="https://github.com/microsoft/TypeScript/pull/50820" data-en="2278">a pull request by Ron Buckton</a> that supports stage 3 decorators and will likely ship in the release after TypeScript 4.9.</li>
          </ul>
        </li>
      </ul>
      <h3 id="libraries-with-decorators" tabindex="-1" data-en="2279">Libraries with decorators&nbsp;&nbsp;<a class="heading-anchor" href="#libraries-with-decorators" aria-hidden="true" data-en="2280">#</a></h3>
      <p data-en="2281">These are libraries with decorators. They currently only support stage 1 decorators but can serve as inspirations for what’s possible:</p>
      <ul data-en="2282">
        <li data-en="2283"><a href="https://github.com/jayphelps/core-decorators.js" data-en="2284">core-decorators.js</a> by Jay Phelps (targets Babel)</li>
        <li data-en="2285"><a href="https://github.com/NetanelBasal/helpful-decorators" data-en="2286">“Helpful Decorators For TypeScript Projects”</a> by Netanel Basal</li>
      </ul>
      <h2 id="acknowledgements" tabindex="-1" data-en="2287">Acknowledgements&nbsp;&nbsp;<a class="heading-anchor" href="#acknowledgements" aria-hidden="true" data-en="2288">#</a></h2>
      <ul data-en="2289">
        <li data-en="2290">Thanks to Chris Garrett for answering my questions about decorators.</li>
      </ul>
      <h2 id="further-reading" tabindex="-1" data-en="2291">Further reading&nbsp;&nbsp;<a class="heading-anchor" href="#further-reading" aria-hidden="true" data-en="2292">#</a></h2>
      <ul data-en="2293">
        <li data-en="2294">
          <p data-en="2295"><a href="https://exploringjs.com/js/book/ch_callables.html" data-en="2296">Chapter “Callable values”</a> [ordinary functions, arrow functions, classes, methods] in “Exploring JavaScript”</p>
        </li>
        <li data-en="2297">
          <p data-en="2298"><a href="https://exploringjs.com/js/book/ch_classes.html" data-en="2299">Chapter “Classes”</a> in “Exploring JavaScript”</p>
        </li>
      </ul>
    </div>
  </div>

</body>

</html>

</html>