<html lang="en-US" data-zh="0">

<head data-zh="1">
  <meta charset="utf-8" data-zh="2">
  <meta name="viewport" content="width=device-width" data-zh="3">
  <title data-zh="4">JavaScript metaprogramming with the 2022-03 decorators API</title>
</head>

<body data-zh="5">
  <div id="page-core-content" class="number-headings" data-zh="6">
    <h1 data-zh="7">JavaScript metaprogramming with the 2022-03 decorators API</h1>
    <div data-zh="8">
      <p data-zh="9">JavaScript decorators have finally reached <a href="https://exploringjs.com/js/book/ch_history.html#tc39-process" data-zh="10">stage 3</a>! Their latest version is already supported by Babel and <a href="#decorator-implementations" data-zh="11">will soon be supported by TypeScript</a>.</p>
      <p data-zh="12">This blog post covers the 2022-03 version (stage 3) of the ECMAScript proposal <a href="https://github.com/tc39/proposal-decorators" data-zh="13">“Decorators”</a> by Daniel Ehrenberg and Chris Garrett.</p>
      <p data-zh="14">A decorator is a keyword that starts with an <code data-zh="15">@</code> symbol and can be put in front of classes and class members (such as methods). For example, <code data-zh="16">@trace</code> is a decorator:</p>
      <pre data-zh="17"><code class="language-js" data-zh="18"><span class="hljs-keyword" data-zh="19">class</span> <span class="hljs-title class_" data-zh="20">C</span> {
  @trace
  <span class="hljs-title function_" data-zh="21">toString</span>(<span class="hljs-params" data-zh="22"></span>) {
    <span class="hljs-keyword" data-zh="23">return</span> <span class="hljs-string" data-zh="24">'C'</span>;
  }
}
</code>
</pre>
      <p data-zh="25">A decorator changes how the decorated construct works. In this case, every invocation of <code data-zh="26">.toString()</code> will be “traced” (arguments and result will be logged to the console). <a href="#example-tracing-method-invocations" data-zh="27">We’ll see how <code data-zh="28">@trace</code> is implemented later.</a></p>
      <!--more-->
      <p data-zh="29">Decorators are mostly an object-oriented feature and popular in OOP frameworks and libraries such as Ember, Angular, Vue, web component frameworks and MobX.</p>
      <p data-zh="30">There are two stakeholders when it comes to decorators:</p>
      <ul data-zh="31">
        <li data-zh="32">Library authors have to know their API so that they can implement them.</li>
        <li data-zh="33">Library users only have to know how to apply them.</li>
      </ul>
      <p data-zh="34">This blog post is intended for library authors: We’ll learn how decorators work and use our knowledge to implement several of them.</p>
      <nav class="table-of-contents" data-zh="35">
        <ul data-zh="36">
          <li data-zh="37">
            <a href="#history-of-decorators" data-zh="38">The history of decorators (optional section)</a>
            <ul data-zh="39">
              <li data-zh="40">
                <a href="#the-history-of-decorators" data-zh="41">The history of decorators</a>
              </li>
              <li data-zh="42">
                <a href="#the-history-of-babel%E2%80%99s-decorator-implementation" data-zh="43">The history of Babel’s decorator implementation</a>
              </li>
            </ul>
          </li>
          <li data-zh="44">
            <a href="#what-are-decorators%3F" data-zh="45">What are decorators?</a>
            <ul data-zh="46">
              <li data-zh="47">
                <a href="#the-shape-of-decorator-functions" data-zh="48">The shape of decorator functions</a>
              </li>
              <li data-zh="49">
                <a href="#what-can-decorators-do%3F" data-zh="50">What can decorators do?</a>
              </li>
              <li data-zh="51">
                <a href="#summary-tables" data-zh="52">Summary tables</a>
              </li>
            </ul>
          </li>
          <li data-zh="53">
            <a href="#more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)" data-zh="54">More information on the syntax and semantics of decorators (optional section)</a>
            <ul data-zh="55">
              <li data-zh="56">
                <a href="#the-syntax-of-decorator-expressions" data-zh="57">The syntax of decorator expressions</a>
              </li>
              <li data-zh="58">
                <a href="#how-are-decorators-executed%3F" data-zh="59">How are decorators executed?</a>
              </li>
              <li data-zh="60">
                <a href="#decorator-initializer-execution" data-zh="61">When do decorator initializers run?</a>
              </li>
            </ul>
          </li>
          <li data-zh="62">
            <a href="#techniques-for-exposing-data-from-decorators" data-zh="63">Techniques for exposing data from decorators</a>
            <ul data-zh="64">
              <li data-zh="65">
                <a href="#storing-exposed-data-in-a-surrounding-scope" data-zh="66">Storing exposed data in a surrounding scope</a>
              </li>
              <li data-zh="67">
                <a href="#managing-exposed-data-via-a-factory-function" data-zh="68">Managing exposed data via a factory function</a>
              </li>
              <li data-zh="69">
                <a href="#managing-exposed-data-via-a-class" data-zh="70">Managing exposed data via a class</a>
              </li>
            </ul>
          </li>
          <li data-zh="71">
            <a href="#class-decorators" data-zh="72">Class decorators</a>
            <ul data-zh="73">
              <li data-zh="74">
                <a href="#example%3A-collecting-instances" data-zh="75">Example: collecting instances</a>
              </li>
              <li data-zh="76">
                <a href="#making-sure-that-instanceof-works" data-zh="77">Making sure that <code data-zh="78">instanceof</code> works</a>
              </li>
              <li data-zh="79">
                <a href="#example-freezing-instances" data-zh="80">Example: freezing instances</a>
              </li>
              <li data-zh="81">
                <a href="#example%3A-making-classes-function-callable" data-zh="82">Example: making classes function-callable</a>
              </li>
            </ul>
          </li>
          <li data-zh="83">
            <a href="#class-method-decorators" data-zh="84">Class method decorators</a>
            <ul data-zh="85">
              <li data-zh="86">
                <a href="#example-tracing-method-invocations" data-zh="87">Example: tracing method invocations</a>
              </li>
              <li data-zh="88">
                <a href="#example%3A-binding-methods-to-instances" data-zh="89">Example: binding methods to instances</a>
              </li>
              <li data-zh="90">
                <a href="#example%3A-applying-functions-to-methods" data-zh="91">Example: applying functions to methods</a>
              </li>
            </ul>
          </li>
          <li data-zh="92">
            <a href="#class-getter-decorators%2C-class-setter-decorators" data-zh="93">Class getter decorators, class setter decorators</a>
            <ul data-zh="94">
              <li data-zh="95">
                <a href="#example%3A-computing-values-lazily" data-zh="96">Example: computing values lazily</a>
              </li>
            </ul>
          </li>
          <li data-zh="97">
            <a href="#class-field-decorators" data-zh="98">Class field decorators</a>
            <ul data-zh="99">
              <li data-zh="100">
                <a href="#example%3A-changing-initialization-values-of-fields" data-zh="101">Example: changing initialization values of fields</a>
              </li>
              <li data-zh="102">
                <a href="#read-only-fields" data-zh="103">Example: read-only fields (instance public fields)</a>
              </li>
              <li data-zh="104">
                <a href="#example%3A-dependency-injection-(instance-public-fields)" data-zh="105">Example: dependency injection (instance public fields)</a>
              </li>
              <li data-zh="106">
                <a href="#example-friend-visibility" data-zh="107">Example: “friend”&nbsp;visibility (instance private fields)</a>
              </li>
              <li data-zh="108">
                <a href="#example%3A-enums-(static-public-fields)" data-zh="109">Example: enums (static public fields)</a>
              </li>
            </ul>
          </li>
          <li data-zh="110">
            <a href="#auto-accessors" data-zh="111">Auto-accessors: a new member of class definitions</a>
            <ul data-zh="112">
              <li data-zh="113">
                <a href="#why-are-auto-accessors-needed%3F" data-zh="114">Why are auto-accessors needed?</a>
              </li>
            </ul>
          </li>
          <li data-zh="115">
            <a href="#class-auto-accessor-decorators" data-zh="116">Class auto-accessor decorators</a>
            <ul data-zh="117">
              <li data-zh="118">
                <a href="#read-only-auto-accessors" data-zh="119">Example: read-only auto-accessors</a>
              </li>
            </ul>
          </li>
          <li data-zh="120">
            <a href="#faq" data-zh="121">Frequently asked questions</a>
            <ul data-zh="122">
              <li data-zh="123">
                <a href="#function-decorators" data-zh="124">Why can’t functions be decorated?</a>
              </li>
            </ul>
          </li>
          <li data-zh="125">
            <a href="#more-decorator-related-proposals" data-zh="126">More decorator-related proposals</a>
          </li>
          <li data-zh="127">
            <a href="#resources" data-zh="128">Resources</a>
            <ul data-zh="129">
              <li data-zh="130">
                <a href="#decorator-implementations" data-zh="131">Implementations</a>
              </li>
              <li data-zh="132">
                <a href="#libraries-with-decorators" data-zh="133">Libraries with decorators</a>
              </li>
            </ul>
          </li>
          <li data-zh="134">
            <a href="#acknowledgements" data-zh="135">Acknowledgements</a>
          </li>
          <li data-zh="136">
            <a href="#further-reading" data-zh="137">Further reading</a>
          </li>
        </ul>
      </nav>
      <h2 id="history-of-decorators" tabindex="-1" data-zh="138">The history of decorators (optional section)&nbsp;&nbsp;<a class="heading-anchor" href="#history-of-decorators" aria-hidden="true" data-zh="139">#</a></h2>
      <p data-zh="140">(This section is optional. If you skip it, you can still understand the remaining content.)</p>
      <p data-zh="141">Let’s start by looking at the history of decorators. Among others, two questions will be answered:</p>
      <ul data-zh="142">
        <li data-zh="143">Why is this proposal taking so long?</li>
        <li data-zh="144">Why does it feel like JavaScript has already had decorators for years?</li>
      </ul>
      <h3 id="the-history-of-decorators" tabindex="-1" data-zh="145">The history of decorators&nbsp;&nbsp;<a class="heading-anchor" href="#the-history-of-decorators" aria-hidden="true" data-zh="146">#</a></h3>
      <p data-zh="147">The following history describes:</p>
      <ul data-zh="148">
        <li data-zh="149">How various groups both worked on their own projects and collaborated on the TC39 proposal.</li>
        <li data-zh="150">How the TC39 proposal advanced through the stages of <a href="https://exploringjs.com/js/book/ch_history.html#tc39-process" data-zh="151">the TC39 process</a> (which start at 0 and end at 4, when the proposal is ready to be added to ECMAScript). Along the way, the proposal changed in numerous ways.</li>
      </ul>
      <p data-zh="152">This is a chronological account of relevant events:</p>
      <ul data-zh="153">
        <li data-zh="154">
          <p data-zh="155"><a href="https://github.com/tc39/notes/blob/main/meetings/2014-04/apr-10.md" data-zh="156">2014-04-10</a>: Decorators were proposed to TC39 by Yehuda Katz. The proposal advanced to stage 0.</p>
          <ul data-zh="157">
            <li data-zh="158">Katz’s proposal was created in collaboration with Ron Buckton. Discussions about that proposal date back as far as <a href="https://twitter.com/rbuckton/status/1581292852532813825" data-zh="159">July 2013</a>.</li>
          </ul>
        </li>
        <li data-zh="160">
          <p data-zh="161">2014-10-22 (ngEurope conference, Paris): The Angular team announced that Angular 2.0 was being written in AtScript and compiled to JavaScript (via Traceur) and Dart. Plans included basing AtScript on TypeScript while adding:</p>
          <ul data-zh="162">
            <li data-zh="163">Three kinds of <em data-zh="164">annotations</em>:
              <ul data-zh="165">
                <li data-zh="166"><em data-zh="167">Type annotations</em></li>
                <li data-zh="168"><em data-zh="169">Field annotations</em> explicitly declare fields.</li>
                <li data-zh="170"><em data-zh="171">Metadata annotations</em> have the same syntax as decorators but only add metadata and don’t change how annotated constructs work.</li>
              </ul>
            </li>
            <li data-zh="172">Runtime type checking</li>
            <li data-zh="173">Type introspection</li>
          </ul>
        </li>
        <li data-zh="174">
          <p data-zh="175"><a href="https://github.com/tc39/notes/blob/main/meetings/2015-01/jan-28.md" data-zh="176">2015-01-28</a>: Yehuda Katz and Jonathan Turner reported that Katz and the TypeScript team were exchanging ideas.</p>
        </li>
        <li data-zh="177">
          <p data-zh="178">2015-03-05 (ng-conf, Salt Lake City): The Angular team and the TypeScript team announced that Angular would switch from AtScript to TypeScript and that TypeScript would adopt some of AtScript’s features (especially decorators).</p>
        </li>
        <li data-zh="179">
          <p data-zh="180"><a href="https://github.com/tc39/notes/blob/main/meetings/2015-03/mar-24.md" data-zh="181">2015-03-24</a>: The decorator proposal reached stage 1. At that time, they had <a href="https://github.com/wycats/javascript-decorators" data-zh="182">a repository on GitHub</a> (created by Yehuda Katz) that was later moved to <a href="https://github.com/tc39/proposal-decorators" data-zh="183">its current location</a>.</p>
        </li>
        <li data-zh="184">
          <p data-zh="185">2015-07-20: <a href="https://devblogs.microsoft.com/typescript/announcing-typescript-1-5/" data-zh="186">TypeScript 1.5</a> came out and supported <a href="https://www.typescriptlang.org/docs/handbook/decorators.html" data-zh="187">stage 1 decorators</a> behind the flag <code data-zh="188">--experimentalDecorators</code>.</p>
          <p data-zh="189">Several JavaScript projects (e.g. Angular and MobX) used this TypeScript feature which made it look like JavaScript already had decorators.</p>
          <p data-zh="190">So far, TypeScript has not supported a newer version of the decorators API. <a href="https://github.com/microsoft/TypeScript/pull/50820" data-zh="191">A pull request by Ron Buckton provides support for stage 3 decorators</a> and will likely ship in the release after v4.9.</p>
        </li>
        <li data-zh="192">
          <p data-zh="193"><a href="https://github.com/tc39/notes/blob/main/meetings/2016-07/jul-28.md" data-zh="194">2016-07-28</a>: The proposal reached stage 2, after a presentation by Yehuda Katz and Brian Terlson.</p>
        </li>
        <li data-zh="195">
          <p data-zh="196"><a href="https://github.com/tc39/notes/blob/main/meetings/2017-07/jul-27.md" data-zh="197">2017-07-27</a>: Daniel Ehrenberg held his first decorator presentation, after joining the proposal a few months earlier. He drove its evolution for several years.</p>
        </li>
        <li data-zh="198">
          <p data-zh="199">Later, Chris Garrett joined the proposal and helped get it to stage 3, which happened <a href="https://github.com/tc39/notes/blob/main/meetings/2022-03/mar-28.md" data-zh="200">on 2022-03-28</a>. Decorator metadata was moved to <a href="https://github.com/tc39/proposal-decorator-metadata" data-zh="201">a separate proposal</a> that started at stage 2.</p>
        </li>
      </ul>
      <p data-zh="202">It took a long time to reach stage 3 because it was difficult to get all stakeholders to agree on an API. Concerns included interactions with other features (such as class members and private state) and performance.</p>
      <h3 id="the-history-of-babel%E2%80%99s-decorator-implementation" tabindex="-1" data-zh="203">The history of Babel’s decorator implementation&nbsp;&nbsp;<a class="heading-anchor" href="#the-history-of-babel%E2%80%99s-decorator-implementation" aria-hidden="true" data-zh="204">#</a></h3>
      <p data-zh="205">Babel closely tracked the evolution of the decorator proposal, thanks to the efforts of Logan Smyth, Nicolò Ribaudo and others:</p>
      <ul data-zh="206">
        <li data-zh="207">
          <p data-zh="208"><a href="https://babeljs.io/blog/2015/03/31/5.0.0" data-zh="209">2015-03-31</a>: Babel 5.0.0 supported stage 1 decorators.</p>
        </li>
        <li data-zh="210">
          <p data-zh="211"><a href="https://github.com/loganfsmyth/babel-plugin-transform-decorators-legacy" data-zh="212">2015-11-29</a> An external plugin by Logan Smyth brought support for stage 1 decorators to Babel 6.</p>
        </li>
        <li data-zh="213">
          <p data-zh="214"><a href="https://babeljs.io/blog/2018/08/27/7.0.0" data-zh="215">2018-08-27</a> Babel 7.0.0 supported stage 2 decorators via the official <code data-zh="216">@babel/plugin-proposal-decorators</code>.</p>
        </li>
        <li data-zh="217">
          <p data-zh="218">The official plugin currently supports <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators#version" data-zh="219">the following versions</a>:</p>
          <ul data-zh="220">
            <li data-zh="221"><code data-zh="222">"legacy"</code>: <a href="https://github.com/wycats/javascript-decorators/blob/e1bf8d41bfa2591d949dd3bbf013514c8904b913/README.md" data-zh="223">stage 1 decorators</a></li>
            <li data-zh="224"><code data-zh="225">"2018-09"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/7fa580b40f2c19c561511ea2c978e307ae689a1b" data-zh="226">stage 2 decorators</a></li>
            <li data-zh="227"><code data-zh="228">"2021-12"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/d6c056fa061646178c34f361bad33d583316dc85" data-zh="229">an updated version of the original stage 2 decorators</a></li>
            <li data-zh="230"><code data-zh="231">"2022-03"</code>: <a href="https://github.com/tc39/proposal-decorators/tree/8ca65c046dd5e9aa3846a1fe5df343a6f7efd9f8" data-zh="232">stage 3 decorators</a></li>
          </ul>
        </li>
      </ul>
      <h2 id="what-are-decorators%3F" tabindex="-1" data-zh="233">What are decorators?&nbsp;&nbsp;<a class="heading-anchor" href="#what-are-decorators%3F" aria-hidden="true" data-zh="234">#</a></h2>
      <p data-zh="235">Decorators let us change how JavaScript constructs (such as classes and methods) work. Let’s revisit our previous example with the decorator <code data-zh="236">@trace</code>:</p>
      <pre data-zh="237"><code class="language-js" data-zh="238"><span class="hljs-keyword" data-zh="239">class</span> <span class="hljs-title class_" data-zh="240">C</span> {
  @trace
  <span class="hljs-title function_" data-zh="241">toString</span>(<span class="hljs-params" data-zh="242"></span>) {
    <span class="hljs-keyword" data-zh="243">return</span> <span class="hljs-string" data-zh="244">'C'</span>;
  }
}
</code></pre>
      <p data-zh="245">To implement <code data-zh="246">@trace</code>, we only have to write a function (<a href="#example-tracing-method-invocations" data-zh="247">the exact implementation will be shown later</a>):</p>
      <pre data-zh="248"><code class="language-js" data-zh="249"><span class="hljs-keyword" data-zh="250">function</span> <span class="hljs-title function_" data-zh="251">trace</span>(<span class="hljs-params" data-zh="252">decoratedMethod</span>) {
  <span class="hljs-comment" data-zh="253">// Returns a function that replaces `decoratedMethod`.</span>
}
</code></pre>
      <p data-zh="254">The class with the decorated method is roughly equivalent to the following code:</p>
      <pre data-zh="255"><code class="language-js" data-zh="256"><span class="hljs-keyword" data-zh="257">class</span> <span class="hljs-title class_" data-zh="258">C</span> {
  <span class="hljs-title function_" data-zh="259">toString</span>(<span class="hljs-params" data-zh="260"></span>) {
    <span class="hljs-keyword" data-zh="261">return</span> <span class="hljs-string" data-zh="262">'C'</span>;
  }
}
C.<span class="hljs-property" data-zh="263"><span class="hljs-keyword" data-zh="264">prototype</span></span>.<span class="hljs-property" data-zh="265">toString</span> = <span class="hljs-title function_" data-zh="266">trace</span>(C.<span class="hljs-property" data-zh="267"><span class="hljs-keyword" data-zh="268">prototype</span></span>.<span class="hljs-property" data-zh="269">toString</span>);
</code></pre>
      <p data-zh="270">In other words: A decorator is a function that we can apply to language constructs. We do so by putting <code data-zh="271">@</code> plus its name in front of them.</p>
      <p data-zh="272">Writing and using decorators is <em data-zh="273">metaprogramming</em>:</p>
      <ul data-zh="274">
        <li data-zh="275">We don’t write code that processes user data (<em data-zh="276">programming</em>).</li>
        <li data-zh="277">We write code that processes code that processes user data (<em data-zh="278">metaprogramming</em>).</li>
      </ul>
      <p data-zh="279">For more information on metaprogramming, see <a href="https://exploringjs.com/deep-js/ch_proxies.html#programming-vs-metaprogramming" data-zh="280">section “Programming versus metaprogramming”</a> in “Deep JavaScript”.</p>
      <h3 id="the-shape-of-decorator-functions" tabindex="-1" data-zh="281">The shape of decorator functions&nbsp;&nbsp;<a class="heading-anchor" href="#the-shape-of-decorator-functions" aria-hidden="true" data-zh="282">#</a></h3>
      <p data-zh="283">Before we explore examples of decorator functions, I’d like to take a look at their TypeScript type signature:</p>
      <pre data-zh="284"><code class="language-ts" data-zh="285"><span class="hljs-keyword" data-zh="286">type</span> <span class="hljs-title class_" data-zh="287">Decorator</span> = <span class="hljs-function" data-zh="288">(<span class="hljs-params" data-zh="289">
  <span class="hljs-attr" data-zh="290">value</span>: <span class="hljs-title class_" data-zh="291">DecoratedValue</span>, <span class="hljs-comment" data-zh="292">// only fields differ</span>
  <span class="hljs-attr" data-zh="293">context</span>: {
    kind: <span class="hljs-built_in" data-zh="294">string</span>;
    name: <span class="hljs-built_in" data-zh="295">string</span> | <span class="hljs-built_in" data-zh="296">symbol</span>;
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" data-zh="297">void</span>): <span class="hljs-built_in" data-zh="298">void</span>;

    // Don’t always exist:
    <span class="hljs-keyword" data-zh="299">static</span>: <span class="hljs-built_in" data-zh="300">boolean</span>;
    <span class="hljs-keyword" data-zh="301">private</span>: <span class="hljs-built_in" data-zh="302">boolean</span>;
    access: {get: () =&gt; <span class="hljs-built_in" data-zh="303">unknown</span>, set: (value: <span class="hljs-built_in" data-zh="304">unknown</span>) =&gt; <span class="hljs-built_in" data-zh="305">void</span>};
  }
</span>) =&gt;</span> <span class="hljs-built_in" data-zh="306">void</span> | <span class="hljs-title class_" data-zh="307">ReplacementValue</span>; <span class="hljs-comment" data-zh="308">// only fields differ</span>
</code></pre>
      <p data-zh="309">That is, a decorator is a function. Its parameters are:</p>
      <ul data-zh="310">
        <li data-zh="311">The <code data-zh="312">value</code> that the decorator is applied to.</li>
        <li data-zh="313">The object <code data-zh="314">context</code> with:
          <ul data-zh="315">
            <li data-zh="316">Additional information on <code data-zh="317">value</code> (<code data-zh="318">.static</code>, <code data-zh="319">.private</code>)</li>
            <li data-zh="320">A small API (<code data-zh="321">.access</code>, <code data-zh="322">.addInitializer</code>) with metaprogramming functionality</li>
          </ul>
        </li>
      </ul>
      <p data-zh="323">Property <code data-zh="324">.kind</code> tells the decorator which kind of JavaScript construct it is applied to. We can use the same function for multiple constructs.</p>
      <p data-zh="325">Currently, decorators can be applied to classes, methods, getters, setters, fields, and <em data-zh="326">auto-accessors</em> (a new class member that is explained <a href="#auto-accessors" data-zh="327">later</a>). The values of <code data-zh="328">.kind</code> reflect that:</p>
      <ul data-zh="329">
        <li data-zh="330"><code data-zh="331">'class'</code></li>
        <li data-zh="332"><code data-zh="333">'method'</code></li>
        <li data-zh="334"><code data-zh="335">'getter'</code></li>
        <li data-zh="336"><code data-zh="337">'setter'</code></li>
        <li data-zh="338"><code data-zh="339">'accessor'</code></li>
        <li data-zh="340"><code data-zh="341">'field'</code></li>
      </ul>
      <p data-zh="342">This is the exact type of <code data-zh="343">Decorator</code>:</p>
      <pre data-zh="344"><code class="language-ts" data-zh="345"><span class="hljs-keyword" data-zh="346">type</span> <span class="hljs-title class_" data-zh="347">Decorator</span> =
  | <span class="hljs-title class_" data-zh="348">ClassDecorator</span>
  | <span class="hljs-title class_" data-zh="349">ClassMethodDecorator</span>
  | <span class="hljs-title class_" data-zh="350">ClassGetterDecorator</span>
  | <span class="hljs-title class_" data-zh="351">ClassSetterDecorator</span>
  | <span class="hljs-title class_" data-zh="352">ClassAutoAccessorDecorator</span>
  | <span class="hljs-title class_" data-zh="353">ClassFieldDecorator</span>
;
</code></pre>
      <p data-zh="354">We’ll soon encounter each of these kinds of decorators and its type signature – where only these parts change:</p>
      <ul data-zh="355">
        <li data-zh="356">The type of <code data-zh="357">value</code></li>
        <li data-zh="358">Some of the properties of <code data-zh="359">context</code></li>
        <li data-zh="360">The return type</li>
      </ul>
      <h3 id="what-can-decorators-do%3F" tabindex="-1" data-zh="361">What can decorators do?&nbsp;&nbsp;<a class="heading-anchor" href="#what-can-decorators-do%3F" aria-hidden="true" data-zh="362">#</a></h3>
      <p data-zh="363">Each decorator has up to four abilities:</p>
      <ul data-zh="364">
        <li data-zh="365">
          <p data-zh="366">It can change the decorated entity by changing the parameter <code data-zh="367">value</code>.</p>
        </li>
        <li data-zh="368">
          <p data-zh="369">It can replace the decorated entity by returning a compatible value:</p>
          <ul data-zh="370">
            <li data-zh="371">“Compatible”&nbsp;means that the returned value must have the same type as the decorated value – e.g., class decorators must return callable values.</li>
            <li data-zh="372">If the decorator doesn’t want to replace the decorated value, it can return <code data-zh="373">undefined</code> – either explicitly or implicitly, by not returning anything.</li>
          </ul>
        </li>
        <li data-zh="374">
          <p data-zh="375">Exposing access to the decorated entity to others. <code data-zh="376">context.access</code> enables it to do that, via its methods <code data-zh="377">.get()</code> and <code data-zh="378">.set()</code>.</p>
        </li>
        <li data-zh="379">
          <p data-zh="380">Processing the decorated entity and its container (if it has one), after both exist: That functionality is provided by <code data-zh="381">context.addInitializer</code>. It lets the decorator register an <em data-zh="382">initializer</em> – a callback that is invoked when everything is ready (more details are explained <a href="#decorator-initializer-execution" data-zh="383">later</a>).</p>
        </li>
      </ul>
      <p data-zh="384">The next subsections demonstrate these abilities. We initially won’t use <code data-zh="385">context.kind</code> to check which kind of construct a decorator is applied to. We will do that later, though.</p>
      <h4 id="ability%3A-replacing-the-decorated-entity" tabindex="-1" data-zh="386">Ability: replacing the decorated entity&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-replacing-the-decorated-entity" aria-hidden="true" data-zh="387">#</a></h4>
      <p data-zh="388">In the following example, the decorator <code data-zh="389">@replaceMethod</code> replaces method <code data-zh="390">.hello()</code> (line B) with a function that it returns (line A).</p>
      <pre data-zh="391"><code class="language-js" data-zh="392"><span class="hljs-keyword" data-zh="393">function</span> <span class="hljs-title function_" data-zh="394">replaceMethod</span>(<span class="hljs-params" data-zh="395"></span>) {
  <span class="hljs-keyword" data-zh="396">return</span> <span class="hljs-keyword" data-zh="397">function</span> (<span class="hljs-params" data-zh="398"></span>) { <span class="hljs-comment" data-zh="399">// (A)</span>
    <span class="hljs-keyword" data-zh="400">return</span> <span class="hljs-string" data-zh="401">`How are you, <span class="hljs-subst" data-zh="402">${<span class="hljs-variable language_" data-zh="403">this</span>.name}</span>?`</span>;
  }
}

<span class="hljs-keyword" data-zh="404">class</span> <span class="hljs-title class_" data-zh="405">Person</span> {
  <span class="hljs-title function_" data-zh="406">constructor</span>(<span class="hljs-params" data-zh="407">name</span>) {
    <span class="hljs-variable language_" data-zh="408">this</span>.<span class="hljs-property" data-zh="409">name</span> = name;
  }
  @replaceMethod
  <span class="hljs-title function_" data-zh="410">hello</span>(<span class="hljs-params" data-zh="411"></span>) { <span class="hljs-comment" data-zh="412">// (B)</span>
    <span class="hljs-keyword" data-zh="413">return</span> <span class="hljs-string" data-zh="414">`Hi <span class="hljs-subst" data-zh="415">${<span class="hljs-variable language_" data-zh="416">this</span>.name}</span>!`</span>;
  }
}

<span class="hljs-keyword" data-zh="417">const</span> robin = <span class="hljs-keyword" data-zh="418">new</span> <span class="hljs-title class_" data-zh="419">Person</span>(<span class="hljs-string" data-zh="420">'Robin'</span>);
assert.<span class="hljs-title function_" data-zh="421">equal</span>(
  robin.<span class="hljs-title function_" data-zh="422">hello</span>(), <span class="hljs-string" data-zh="423">'How are you, Robin?'</span>
);
</code></pre>
      <h4 id="ability%3A-exposing-access-to-the-decorated-entity-to-others" tabindex="-1" data-zh="424">Ability: exposing access to the decorated entity to others&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-exposing-access-to-the-decorated-entity-to-others" aria-hidden="true" data-zh="425">#</a></h4>
      <p data-zh="426">In the next example, the decorator <code data-zh="427">@exposeAccess</code> stores an object in the variable <code data-zh="428">acc</code> that lets us access property <code data-zh="429">.green</code> of the instances of <code data-zh="430">Color</code>.</p>
      <pre data-zh="431"><code class="language-js" data-zh="432"><span class="hljs-keyword" data-zh="433">let</span> acc;
<span class="hljs-keyword" data-zh="434">function</span> <span class="hljs-title function_" data-zh="435">exposeAccess</span>(<span class="hljs-params" data-zh="436">_value, {access}</span>) {
  acc = access;
}

<span class="hljs-keyword" data-zh="437">class</span> <span class="hljs-title class_" data-zh="438">Color</span> {
  @exposeAccess
  name = <span class="hljs-string" data-zh="439">'green'</span>
}

<span class="hljs-keyword" data-zh="440">const</span> green = <span class="hljs-keyword" data-zh="441">new</span> <span class="hljs-title class_" data-zh="442">Color</span>();
assert.<span class="hljs-title function_" data-zh="443">equal</span>(
  green.<span class="hljs-property" data-zh="444">name</span>, <span class="hljs-string" data-zh="445">'green'</span>
);
<span class="hljs-comment" data-zh="446">// Using `acc` to get and set `green.name`</span>
assert.<span class="hljs-title function_" data-zh="447">equal</span>(
  acc.<span class="hljs-property" data-zh="448">get</span>.<span class="hljs-title function_" data-zh="449">call</span>(green), <span class="hljs-string" data-zh="450">'green'</span>
);
acc.<span class="hljs-property" data-zh="451">set</span>.<span class="hljs-title function_" data-zh="452">call</span>(green, <span class="hljs-string" data-zh="453">'red'</span>);
assert.<span class="hljs-title function_" data-zh="454">equal</span>(
  green.<span class="hljs-property" data-zh="455">name</span>, <span class="hljs-string" data-zh="456">'red'</span>
);
</code></pre>
      <h4 id="ability%3A-processing-the-decorated-entity-and-its-container" tabindex="-1" data-zh="457">Ability: processing the decorated entity and its container&nbsp;&nbsp;<a class="heading-anchor" href="#ability%3A-processing-the-decorated-entity-and-its-container" aria-hidden="true" data-zh="458">#</a></h4>
      <p data-zh="459">In the following code, we use the decorator <code data-zh="460">@collect</code> to store the keys of decorated methods in the instance property <code data-zh="461">.collectedMethodKeys</code>:</p>
      <pre data-zh="462"><code class="language-js" data-zh="463"><span class="hljs-keyword" data-zh="464">function</span> <span class="hljs-title function_" data-zh="465">collect</span>(<span class="hljs-params" data-zh="466">_value, {name, addInitializer}</span>) {
  <span class="hljs-title function_" data-zh="467">addInitializer</span>(<span class="hljs-keyword" data-zh="468">function</span> (<span class="hljs-params" data-zh="469"></span>) { <span class="hljs-comment" data-zh="470">// (A)</span>
    <span class="hljs-keyword" data-zh="471">if</span> (!<span class="hljs-variable language_" data-zh="472">this</span>.<span class="hljs-property" data-zh="473">collectedMethodKeys</span>) {
      <span class="hljs-variable language_" data-zh="474">this</span>.<span class="hljs-property" data-zh="475">collectedMethodKeys</span> = <span class="hljs-keyword" data-zh="476">new</span> <span class="hljs-title class_" data-zh="477">Set</span>();
    }
    <span class="hljs-variable language_" data-zh="478">this</span>.<span class="hljs-property" data-zh="479">collectedMethodKeys</span>.<span class="hljs-title function_" data-zh="480">add</span>(name);
  });
}

<span class="hljs-keyword" data-zh="481">class</span> <span class="hljs-title class_" data-zh="482">C</span> {
  @collect
  <span class="hljs-title function_" data-zh="483">toString</span>(<span class="hljs-params" data-zh="484"></span>) {}
  @collect
  [<span class="hljs-title class_" data-zh="485">Symbol</span>.<span class="hljs-property" data-zh="486">iterator</span>]() {}
}
<span class="hljs-keyword" data-zh="487">const</span> inst = <span class="hljs-keyword" data-zh="488">new</span> <span class="hljs-title function_" data-zh="489">C</span>();
assert.<span class="hljs-title function_" data-zh="490">deepEqual</span>(
  inst.<span class="hljs-property" data-zh="491">collectedMethodKeys</span>,
  <span class="hljs-keyword" data-zh="492">new</span> <span class="hljs-title class_" data-zh="493">Set</span>([<span class="hljs-string" data-zh="494">'toString'</span>, <span class="hljs-title class_" data-zh="495">Symbol</span>.<span class="hljs-property" data-zh="496">iterator</span>])
);
</code></pre>
      <p data-zh="497">The initializer function added by the decorator in line A must be an ordinary function because access to the implicit parameter <code data-zh="498">this</code> is needed. Arrow functions don’t provide this access – their <code data-zh="499">this</code> is statically scoped (like any normal variable).</p>
      <h3 id="summary-tables" tabindex="-1" data-zh="500">Summary tables&nbsp;&nbsp;<a class="heading-anchor" href="#summary-tables" aria-hidden="true" data-zh="501">#</a></h3>
      <p data-zh="502">Type signature:</p>
      <table class="framed" data-zh="503">
        <thead data-zh="504">
          <tr data-zh="505">
            <th data-zh="506">Kind of decorator</th>
            <th data-zh="507"><code data-zh="508">(input) =&gt; output</code></th>
            <th data-zh="509"><code data-zh="510">.access</code></th>
          </tr>
        </thead>
        <tbody data-zh="511">
          <tr data-zh="512">
            <td data-zh="513">Class</td>
            <td data-zh="514"><code data-zh="515">(func) =&gt; func2</code></td>
            <td data-zh="516">–</td>
          </tr>
          <tr data-zh="517">
            <td data-zh="518">Method</td>
            <td data-zh="519"><code data-zh="520">(func) =&gt; func2</code></td>
            <td data-zh="521"><code data-zh="522">{get}</code></td>
          </tr>
          <tr data-zh="523">
            <td data-zh="524">Getter</td>
            <td data-zh="525"><code data-zh="526">(func) =&gt; func2</code></td>
            <td data-zh="527"><code data-zh="528">{get}</code></td>
          </tr>
          <tr data-zh="529">
            <td data-zh="530">Setter</td>
            <td data-zh="531"><code data-zh="532">(func) =&gt; func2</code></td>
            <td data-zh="533"><code data-zh="534">{set}</code></td>
          </tr>
          <tr data-zh="535">
            <td data-zh="536">Auto-accessor</td>
            <td data-zh="537"><code data-zh="538">({get,set}) =&gt; {get,set,init}</code></td>
            <td data-zh="539"><code data-zh="540">{get,set}</code></td>
          </tr>
          <tr data-zh="541">
            <td data-zh="542">Field</td>
            <td data-zh="543"><code data-zh="544">() =&gt; (initValue)=&gt;initValue2</code></td>
            <td data-zh="545"><code data-zh="546">{get,set}</code></td>
          </tr>
        </tbody>
      </table>
      <p data-zh="547">Value of <code data-zh="548">this</code> in functions:</p>
      <table class="framed" data-zh="549">
        <thead data-zh="550">
          <tr data-zh="551">
            <th data-zh="552"><code data-zh="553">this</code> is →</th>
            <th data-zh="554"><code data-zh="555">undefined</code></th>
            <th data-zh="556">Class</th>
            <th data-zh="557">Instance</th>
          </tr>
        </thead>
        <tbody data-zh="558">
          <tr data-zh="559">
            <td data-zh="560">Decorator function</td>
            <td data-zh="561">✔</td>
            <td data-zh="562"></td>
            <td data-zh="563"></td>
          </tr>
          <tr data-zh="564">
            <td data-zh="565">Static initializer</td>
            <td data-zh="566"></td>
            <td data-zh="567">✔</td>
            <td data-zh="568"></td>
          </tr>
          <tr data-zh="569">
            <td data-zh="570">Non-static initializer</td>
            <td data-zh="571"></td>
            <td data-zh="572"></td>
            <td data-zh="573">✔</td>
          </tr>
          <tr data-zh="574">
            <td data-zh="575">Static field decorator result</td>
            <td data-zh="576"></td>
            <td data-zh="577">✔</td>
            <td data-zh="578"></td>
          </tr>
          <tr data-zh="579">
            <td data-zh="580">Non-static field decorator result</td>
            <td data-zh="581"></td>
            <td data-zh="582"></td>
            <td data-zh="583">✔</td>
          </tr>
        </tbody>
      </table>
      <h2 id="more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)" tabindex="-1" data-zh="584">More information on the syntax and semantics of decorators (optional section)&nbsp;&nbsp;<a class="heading-anchor" href="#more-information-on-the-syntax-and-semantics-of-decorators-(optional-section)" aria-hidden="true" data-zh="585">#</a></h2>
      <p data-zh="586">(This section is optional. If you skip it, you can still understand the remaining content.)</p>
      <h3 id="the-syntax-of-decorator-expressions" tabindex="-1" data-zh="587">The syntax of decorator expressions&nbsp;&nbsp;<a class="heading-anchor" href="#the-syntax-of-decorator-expressions" aria-hidden="true" data-zh="588">#</a></h3>
      <ul data-zh="589">
        <li data-zh="590">A decorator expression starts with a chain of one or more identifiers, separated by dots. Each identifier except the first one can be private (prefix <code data-zh="591">#</code>). Square brackets <code data-zh="592">[]</code> are not allowed.</li>
        <li data-zh="593">Optional at the end: function call arguments in parentheses. The next subsection explains what that means.</li>
        <li data-zh="594">We can use any expression if we put it in parentheses:
          <pre data-zh="595"><code class="language-js" data-zh="596">@(«expr»)
</code></pre>
        </li>
      </ul>
      <p data-zh="597">Wherever decorators are allowed, we can use more than one of them. The following code demonstrates decorator syntax:</p>
      <pre data-zh="598"><code class="language-js" data-zh="599"><span class="hljs-comment" data-zh="600">// Five decorators for MyClass</span>

@myFunc
@<span class="hljs-title function_" data-zh="601">myFuncFactory</span>(<span class="hljs-string" data-zh="602">'arg1'</span>, <span class="hljs-string" data-zh="603">'arg2'</span>)

@libraryModule.<span class="hljs-property" data-zh="604">prop</span>
@someObj.<span class="hljs-title function_" data-zh="605">method</span>(<span class="hljs-number" data-zh="606">123</span>)

@(<span class="hljs-title function_" data-zh="607">wrap</span>(dict[<span class="hljs-string" data-zh="608">'prop'</span>])) <span class="hljs-comment" data-zh="609">// arbitrary expression</span>

<span class="hljs-keyword" data-zh="610">class</span> <span class="hljs-title class_" data-zh="611">MyClass</span> {}
</code></pre>
      <h3 id="how-are-decorators-executed%3F" tabindex="-1" data-zh="612">How are decorators executed?&nbsp;&nbsp;<a class="heading-anchor" href="#how-are-decorators-executed%3F" aria-hidden="true" data-zh="613">#</a></h3>
      <ul data-zh="614">
        <li data-zh="615">
          <p data-zh="616">Evaluation: The expressions after the <code data-zh="617">@</code> symbols are evaluated during the execution of the class definition, along with computed property keys and static fields (see code below). The results must be functions. They are stored in temporary locations (think local variables), to be invoked later.</p>
        </li>
        <li data-zh="618">
          <p data-zh="619">Invocation: The decorator functions are called later during the execution of a class definition, after methods have been evaluated but before constructor and prototype have been assembled. Once again the results are stored in temporary locations.</p>
        </li>
        <li data-zh="620">
          <p data-zh="621">Application: After all decorator functions were invoked, their results are used, which can affect constructor and prototype. Class decorators are applied after all method and field decorators.</p>
        </li>
      </ul>
      <p data-zh="622">The following code illustrates in which order decorator expressions, computed property keys and field initializers are evaluated:</p>
      <pre data-zh="623"><code class="language-js" data-zh="624"><span class="hljs-keyword" data-zh="625">function</span> <span class="hljs-title function_" data-zh="626">decorate</span>(<span class="hljs-params" data-zh="627">str</span>) {
  <span class="hljs-variable language_" data-zh="628">console</span>.<span class="hljs-title function_" data-zh="629">log</span>(<span class="hljs-string" data-zh="630">`EVALUATE @decorate(): <span class="hljs-subst" data-zh="631">${str}</span>`</span>);
  <span class="hljs-keyword" data-zh="632">return</span> <span class="hljs-function" data-zh="633">() =&gt;</span> <span class="hljs-variable language_" data-zh="634">console</span>.<span class="hljs-title function_" data-zh="635">log</span>(<span class="hljs-string" data-zh="636">`APPLY @decorate(): <span class="hljs-subst" data-zh="637">${str}</span>`</span>); <span class="hljs-comment" data-zh="638">// (A)</span>
}
<span class="hljs-keyword" data-zh="639">function</span> <span class="hljs-title function_" data-zh="640">log</span>(<span class="hljs-params" data-zh="641">str</span>) {
  <span class="hljs-variable language_" data-zh="642">console</span>.<span class="hljs-title function_" data-zh="643">log</span>(str);
  <span class="hljs-keyword" data-zh="644">return</span> str;
}

@<span class="hljs-title function_" data-zh="645">decorate</span>(<span class="hljs-string" data-zh="646">'class'</span>)
<span class="hljs-keyword" data-zh="647">class</span> <span class="hljs-title class_" data-zh="648">TheClass</span> {

  @<span class="hljs-title function_" data-zh="649">decorate</span>(<span class="hljs-string" data-zh="650">'static field'</span>)
  <span class="hljs-keyword" data-zh="651">static</span> staticField = <span class="hljs-title function_" data-zh="652">log</span>(<span class="hljs-string" data-zh="653">'static field value'</span>);

  @<span class="hljs-title function_" data-zh="654">decorate</span>(<span class="hljs-string" data-zh="655">'prototype method'</span>)
  [<span class="hljs-title function_" data-zh="656">log</span>(<span class="hljs-string" data-zh="657">'computed key'</span>)]() {}

  @<span class="hljs-title function_" data-zh="658">decorate</span>(<span class="hljs-string" data-zh="659">'instance field'</span>)
  instanceField = <span class="hljs-title function_" data-zh="660">log</span>(<span class="hljs-string" data-zh="661">'instance field value'</span>);
    <span class="hljs-comment" data-zh="662">// This initializer only runs if we instantiate the class</span>
}

<span class="hljs-comment" data-zh="663">// Output:</span>
<span class="hljs-comment" data-zh="664">// EVALUATE @decorate(): class</span>
<span class="hljs-comment" data-zh="665">// EVALUATE @decorate(): static field</span>
<span class="hljs-comment" data-zh="666">// EVALUATE @decorate(): prototype method</span>
<span class="hljs-comment" data-zh="667">// computed key</span>
<span class="hljs-comment" data-zh="668">// EVALUATE @decorate(): instance field</span>
<span class="hljs-comment" data-zh="669">// APPLY @decorate(): prototype method</span>
<span class="hljs-comment" data-zh="670">// APPLY @decorate(): static field</span>
<span class="hljs-comment" data-zh="671">// APPLY @decorate(): instance field</span>
<span class="hljs-comment" data-zh="672">// APPLY @decorate(): class</span>
<span class="hljs-comment" data-zh="673">// static field value</span>
</code></pre>
      <p data-zh="674">Function <code data-zh="675">decorate</code> is invoked whenever the expression <code data-zh="676">decorate()</code> after the <code data-zh="677">@</code> symbol is evaluated. In line A, it returns the actual decorator function, which is applied later.</p>
      <h3 id="decorator-initializer-execution" tabindex="-1" data-zh="678">When do decorator initializers run?&nbsp;&nbsp;<a class="heading-anchor" href="#decorator-initializer-execution" aria-hidden="true" data-zh="679">#</a></h3>
      <p data-zh="680">When a decorator initializer runs, depends on the kind of decorator:</p>
      <ul data-zh="681">
        <li data-zh="682">
          <p data-zh="683">Class decorator initializers run after the class is fully defined and all static fields were initialized.</p>
        </li>
        <li data-zh="684">
          <p data-zh="685">The initializers of non-static class element decorators run during instantiation, before instance fields are initialized.</p>
        </li>
        <li data-zh="686">
          <p data-zh="687">The initializers of static class element decorators run during class definition, before static fields are defined but after other all other class elements were defined.</p>
        </li>
      </ul>
      <p data-zh="688">Why is that? For non-static initializers, we have five options – they can run:</p>
      <ol data-zh="689">
        <li data-zh="690">Before <code data-zh="691">super</code></li>
        <li data-zh="692">After <code data-zh="693">super</code>, before field initialization</li>
        <li data-zh="694">Interleaved between fields in definition order</li>
        <li data-zh="695">After field initialization, before child class instantiation</li>
        <li data-zh="696">After child class instantiation</li>
      </ol>
      <p data-zh="697">Why was #2 chosen?</p>
      <ul data-zh="698">
        <li data-zh="699">
          <p data-zh="700">#1 was rejected because decorator initializers must be able to access <code data-zh="701">this</code>, which isn’t possible before <code data-zh="702">super</code> runs.</p>
        </li>
        <li data-zh="703">
          <p data-zh="704">#3 was rejected because running all decorator initializers at the same time is simpler than ensuring that they are properly interleaved.</p>
        </li>
      </ul>
      <ul data-zh="705">
        <li data-zh="706">
          <p data-zh="707">#4 was rejected because running decorator initializers before fields ensures that fields don’t see partially initialized methods. For example, if there are <code data-zh="708">@bind</code> decorators, then field initializers can rely on the decorated methods being bound.</p>
        </li>
        <li data-zh="709">
          <p data-zh="710">#5 was rejected because it would allow superclasses to interfere with subclasses, which would break the rule that superclasses should not be aware of their subclasses.</p>
        </li>
      </ul>
      <p data-zh="711">The following code demonstrates in which order Babel currently invokes decorator initializers. Note that Babel does not yet support initializers for class field decorators (which was a recent change to the decorators API).</p>
      <pre data-zh="712"><code class="language-js" data-zh="713"><span class="hljs-comment" data-zh="714">// We wait until after instantiation before we log steps,</span>
<span class="hljs-comment" data-zh="715">// so that we can compare the value of `this` with the instance.</span>
<span class="hljs-keyword" data-zh="716">const</span> steps = [];
<span class="hljs-keyword" data-zh="717">function</span> <span class="hljs-title function_" data-zh="718">push</span>(<span class="hljs-params" data-zh="719">msg, _this</span>) {
  steps.<span class="hljs-title function_" data-zh="720">push</span>({msg, _this});
}
<span class="hljs-keyword" data-zh="721">function</span> <span class="hljs-title function_" data-zh="722">pushStr</span>(<span class="hljs-params" data-zh="723">str</span>) {
  steps.<span class="hljs-title function_" data-zh="724">push</span>(str);
}

<span class="hljs-keyword" data-zh="725">function</span> <span class="hljs-title function_" data-zh="726">init</span>(<span class="hljs-params" data-zh="727">_value, {name, addInitializer}</span>) {
  <span class="hljs-title function_" data-zh="728">pushStr</span>(<span class="hljs-string" data-zh="729">`@init <span class="hljs-subst" data-zh="730">${name}</span>`</span>);
  <span class="hljs-keyword" data-zh="731">if</span> (addInitializer) {
    <span class="hljs-title function_" data-zh="732">addInitializer</span>(<span class="hljs-keyword" data-zh="733">function</span> (<span class="hljs-params" data-zh="734"></span>) {
      <span class="hljs-title function_" data-zh="735">push</span>(<span class="hljs-string" data-zh="736">`DECORATOR INITIALIZER <span class="hljs-subst" data-zh="737">${name}</span>`</span>, <span class="hljs-variable language_" data-zh="738">this</span>);
    });
  }
}

@init <span class="hljs-keyword" data-zh="739">class</span> <span class="hljs-title class_" data-zh="740">TheClass</span> {
  <span class="hljs-comment" data-zh="741">//--- Static ---</span>

  <span class="hljs-keyword" data-zh="742">static</span> {
    <span class="hljs-title function_" data-zh="743">pushStr</span>(<span class="hljs-string" data-zh="744">'static block'</span>);
  }

  @init <span class="hljs-keyword" data-zh="745">static</span> <span class="hljs-title function_" data-zh="746">staticMethod</span>(<span class="hljs-params" data-zh="747"></span>) {}
  @init <span class="hljs-keyword" data-zh="748">static</span> accessor staticAcc = <span class="hljs-title function_" data-zh="749">pushStr</span>(<span class="hljs-string" data-zh="750">'staticAcc'</span>);
  @init <span class="hljs-keyword" data-zh="751">static</span> staticField = <span class="hljs-title function_" data-zh="752">pushStr</span>(<span class="hljs-string" data-zh="753">'staticField'</span>);

  <span class="hljs-comment" data-zh="754">//--- Non-static ---</span>

  @init <span class="hljs-title function_" data-zh="755">prototypeMethod</span>(<span class="hljs-params" data-zh="756"></span>) {}
  @init accessor instanceAcc = <span class="hljs-title function_" data-zh="757">pushStr</span>(<span class="hljs-string" data-zh="758">'instanceAcc'</span>);
  @init instanceField = <span class="hljs-title function_" data-zh="759">pushStr</span>(<span class="hljs-string" data-zh="760">'instanceField'</span>);

  <span class="hljs-title function_" data-zh="761">constructor</span>(<span class="hljs-params" data-zh="762"></span>) {
    <span class="hljs-title function_" data-zh="763">pushStr</span>(<span class="hljs-string" data-zh="764">'constructor'</span>);
  }
}

<span class="hljs-title function_" data-zh="765">pushStr</span>(<span class="hljs-string" data-zh="766">'===== Instantiation ====='</span>);
<span class="hljs-keyword" data-zh="767">const</span> inst = <span class="hljs-keyword" data-zh="768">new</span> <span class="hljs-title class_" data-zh="769">TheClass</span>();

<span class="hljs-keyword" data-zh="770">for</span> (<span class="hljs-keyword" data-zh="771">const</span> step <span class="hljs-keyword" data-zh="772">of</span> steps) {
  <span class="hljs-keyword" data-zh="773">if</span> (<span class="hljs-keyword" data-zh="774">typeof</span> step === <span class="hljs-string" data-zh="775">'string'</span>) {
    <span class="hljs-variable language_" data-zh="776">console</span>.<span class="hljs-title function_" data-zh="777">log</span>(step);
    <span class="hljs-keyword" data-zh="778">continue</span>;
  }
  <span class="hljs-keyword" data-zh="779">let</span> thisDesc = <span class="hljs-string" data-zh="780">'???'</span>;
  <span class="hljs-keyword" data-zh="781">if</span> (step.<span class="hljs-property" data-zh="782">_this</span> === <span class="hljs-title class_" data-zh="783">TheClass</span>) {
    thisDesc = <span class="hljs-title class_" data-zh="784">TheClass</span>.<span class="hljs-property" data-zh="785">name</span>;
  } <span class="hljs-keyword" data-zh="786">else</span> <span class="hljs-keyword" data-zh="787">if</span> (step.<span class="hljs-property" data-zh="788">_this</span> === inst) {
    thisDesc = <span class="hljs-string" data-zh="789">'inst'</span>;
  } <span class="hljs-keyword" data-zh="790">else</span> <span class="hljs-keyword" data-zh="791">if</span> (step.<span class="hljs-property" data-zh="792">_this</span> === <span class="hljs-literal" data-zh="793">undefined</span>) {
    thisDesc = <span class="hljs-string" data-zh="794">'undefined'</span>;
  }
  <span class="hljs-variable language_" data-zh="795">console</span>.<span class="hljs-title function_" data-zh="796">log</span>(<span class="hljs-string" data-zh="797">`<span class="hljs-subst" data-zh="798">${step.msg}</span> (this===<span class="hljs-subst" data-zh="799">${thisDesc}</span>)`</span>);
}

<span class="hljs-comment" data-zh="800">// Output:</span>
<span class="hljs-comment" data-zh="801">// @init staticMethod</span>
<span class="hljs-comment" data-zh="802">// @init staticAcc</span>
<span class="hljs-comment" data-zh="803">// @init prototypeMethod</span>
<span class="hljs-comment" data-zh="804">// @init instanceAcc</span>
<span class="hljs-comment" data-zh="805">// @init staticField</span>
<span class="hljs-comment" data-zh="806">// @init instanceField</span>
<span class="hljs-comment" data-zh="807">// @init TheClass</span>
<span class="hljs-comment" data-zh="808">// DECORATOR INITIALIZER staticMethod (this===TheClass)</span>
<span class="hljs-comment" data-zh="809">// DECORATOR INITIALIZER staticAcc (this===TheClass)</span>
<span class="hljs-comment" data-zh="810">// static block</span>
<span class="hljs-comment" data-zh="811">// staticAcc</span>
<span class="hljs-comment" data-zh="812">// staticField</span>
<span class="hljs-comment" data-zh="813">// DECORATOR INITIALIZER TheClass (this===TheClass)</span>
<span class="hljs-comment" data-zh="814">// ===== Instantiation =====</span>
<span class="hljs-comment" data-zh="815">// DECORATOR INITIALIZER prototypeMethod (this===inst)</span>
<span class="hljs-comment" data-zh="816">// DECORATOR INITIALIZER instanceAcc (this===inst)</span>
<span class="hljs-comment" data-zh="817">// instanceAcc</span>
<span class="hljs-comment" data-zh="818">// instanceField</span>
<span class="hljs-comment" data-zh="819">// constructor</span>
</code></pre>
      <h2 id="techniques-for-exposing-data-from-decorators" tabindex="-1" data-zh="820">Techniques for exposing data from decorators&nbsp;&nbsp;<a class="heading-anchor" href="#techniques-for-exposing-data-from-decorators" aria-hidden="true" data-zh="821">#</a></h2>
      <p data-zh="822">Sometimes decorators collect data. Let’s explore how they can make this data available to other parties.</p>
      <h3 id="storing-exposed-data-in-a-surrounding-scope" tabindex="-1" data-zh="823">Storing exposed data in a surrounding scope&nbsp;&nbsp;<a class="heading-anchor" href="#storing-exposed-data-in-a-surrounding-scope" aria-hidden="true" data-zh="824">#</a></h3>
      <p data-zh="825">The simplest solution is to store data in a location in a surrounding scope. For example, the decorator <code data-zh="826">@collect</code> collects classes and stores them in the Set <code data-zh="827">classes</code> (line A):</p>
      <pre data-zh="828"><code class="language-js" data-zh="829"><span class="hljs-keyword" data-zh="830">const</span> classes = <span class="hljs-keyword" data-zh="831">new</span> <span class="hljs-title class_" data-zh="832">Set</span>(); <span class="hljs-comment" data-zh="833">// (A)</span>

<span class="hljs-keyword" data-zh="834">function</span> <span class="hljs-title function_" data-zh="835">collect</span>(<span class="hljs-params" data-zh="836">value, {kind, addInitializer}</span>) {
  <span class="hljs-keyword" data-zh="837">if</span> (kind === <span class="hljs-string" data-zh="838">'class'</span>) {
    classes.<span class="hljs-title function_" data-zh="839">add</span>(value);
  }
}

@collect
<span class="hljs-keyword" data-zh="840">class</span> <span class="hljs-title class_" data-zh="841">A</span> {}
@collect
<span class="hljs-keyword" data-zh="842">class</span> <span class="hljs-title class_" data-zh="843">B</span> {}
@collect
<span class="hljs-keyword" data-zh="844">class</span> <span class="hljs-title class_" data-zh="845">C</span> {}

assert.<span class="hljs-title function_" data-zh="846">deepEqual</span>(
  classes, <span class="hljs-keyword" data-zh="847">new</span> <span class="hljs-title class_" data-zh="848">Set</span>([A, B, C])
);
</code></pre>
      <p data-zh="849">The downside of this approach is that it doesn’t work if a decorator comes from another module.</p>
      <h3 id="managing-exposed-data-via-a-factory-function" tabindex="-1" data-zh="850">Managing exposed data via a factory function&nbsp;&nbsp;<a class="heading-anchor" href="#managing-exposed-data-via-a-factory-function" aria-hidden="true" data-zh="851">#</a></h3>
      <p data-zh="852">A more sophisticated approach is to use a factory function <code data-zh="853">createClassCollector()</code> that returns:</p>
      <ul data-zh="854">
        <li data-zh="855">A class decorator <code data-zh="856">collect</code></li>
        <li data-zh="857">A Set <code data-zh="858">classes</code>, to which the decorator will add the classes it collects</li>
      </ul>
      <pre data-zh="859"><code class="language-js" data-zh="860"><span class="hljs-keyword" data-zh="861">function</span> <span class="hljs-title function_" data-zh="862">createClassCollector</span>(<span class="hljs-params" data-zh="863"></span>) {
  <span class="hljs-keyword" data-zh="864">const</span> classes = <span class="hljs-keyword" data-zh="865">new</span> <span class="hljs-title class_" data-zh="866">Set</span>();
  <span class="hljs-keyword" data-zh="867">function</span> <span class="hljs-title function_" data-zh="868">collect</span>(<span class="hljs-params" data-zh="869">value, {kind, addInitializer}</span>) {
    <span class="hljs-keyword" data-zh="870">if</span> (kind === <span class="hljs-string" data-zh="871">'class'</span>) {
      classes.<span class="hljs-title function_" data-zh="872">add</span>(value);
    }
  }
  <span class="hljs-keyword" data-zh="873">return</span> {
    classes,
    collect,
  };
}

<span class="hljs-keyword" data-zh="874">const</span> {classes, collect} = <span class="hljs-title function_" data-zh="875">createClassCollector</span>();

@collect
<span class="hljs-keyword" data-zh="876">class</span> <span class="hljs-title class_" data-zh="877">A</span> {}
@collect
<span class="hljs-keyword" data-zh="878">class</span> <span class="hljs-title class_" data-zh="879">B</span> {}
@collect
<span class="hljs-keyword" data-zh="880">class</span> <span class="hljs-title class_" data-zh="881">C</span> {}

assert.<span class="hljs-title function_" data-zh="882">deepEqual</span>(
  classes, <span class="hljs-keyword" data-zh="883">new</span> <span class="hljs-title class_" data-zh="884">Set</span>([A, B, C])
);
</code></pre>
      <h3 id="managing-exposed-data-via-a-class" tabindex="-1" data-zh="885">Managing exposed data via a class&nbsp;&nbsp;<a class="heading-anchor" href="#managing-exposed-data-via-a-class" aria-hidden="true" data-zh="886">#</a></h3>
      <p data-zh="887">Instead of a factory function, we can also use a class. It has two members:</p>
      <ul data-zh="888">
        <li data-zh="889"><code data-zh="890">.classes</code>, a Set with the collected classes</li>
        <li data-zh="891"><code data-zh="892">.install</code>, a class decorator</li>
      </ul>
      <pre data-zh="893"><code class="language-js" data-zh="894"><span class="hljs-keyword" data-zh="895">class</span> <span class="hljs-title class_" data-zh="896">ClassCollector</span> {
  classes = <span class="hljs-keyword" data-zh="897">new</span> <span class="hljs-title class_" data-zh="898">Set</span>();
  install = <span class="hljs-function" data-zh="899">(<span class="hljs-params" data-zh="900">value, {kind}</span>) =&gt;</span> { <span class="hljs-comment" data-zh="901">// (A)</span>
    <span class="hljs-keyword" data-zh="902">if</span> (kind === <span class="hljs-string" data-zh="903">'class'</span>) {
      <span class="hljs-variable language_" data-zh="904">this</span>.<span class="hljs-property" data-zh="905">classes</span>.<span class="hljs-title function_" data-zh="906">add</span>(value); <span class="hljs-comment" data-zh="907">// (B)</span>
    }
  };
}

<span class="hljs-keyword" data-zh="908">const</span> collector = <span class="hljs-keyword" data-zh="909">new</span> <span class="hljs-title class_" data-zh="910">ClassCollector</span>();

@collector.<span class="hljs-property" data-zh="911">install</span>
<span class="hljs-keyword" data-zh="912">class</span> <span class="hljs-title class_" data-zh="913">A</span> {}
@collector.<span class="hljs-property" data-zh="914">install</span>
<span class="hljs-keyword" data-zh="915">class</span> <span class="hljs-title class_" data-zh="916">B</span> {}
@collector.<span class="hljs-property" data-zh="917">install</span>
<span class="hljs-keyword" data-zh="918">class</span> <span class="hljs-title class_" data-zh="919">C</span> {}

assert.<span class="hljs-title function_" data-zh="920">deepEqual</span>(
  collector.<span class="hljs-property" data-zh="921">classes</span>, <span class="hljs-keyword" data-zh="922">new</span> <span class="hljs-title class_" data-zh="923">Set</span>([A, B, C])
);
</code></pre>
      <p data-zh="924">We implemented <code data-zh="925">.install</code> by assigning an arrow function to a public instance field (line A). Instance field initializers run in scopes where <code data-zh="926">this</code> refers to the current instance. That is also the outer scope of the arrow function and explains what value <code data-zh="927">this</code> has in line B.</p>
      <p data-zh="928">We could also implement <code data-zh="929">.install</code> via a getter, but then we’d have to return a new function whenever <code data-zh="930">.install</code> is read.</p>
      <h2 id="class-decorators" tabindex="-1" data-zh="931">Class decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-decorators" aria-hidden="true" data-zh="932">#</a></h2>
      <p data-zh="933">Class decorators have the following type signature:</p>
      <pre data-zh="934"><code class="language-ts" data-zh="935"><span class="hljs-keyword" data-zh="936">type</span> <span class="hljs-title class_" data-zh="937">ClassDecorator</span> = <span class="hljs-function" data-zh="938">(<span class="hljs-params" data-zh="939">
  <span class="hljs-attr" data-zh="940">value</span>: <span class="hljs-title class_" data-zh="941">Function</span>,
  <span class="hljs-attr" data-zh="942">context</span>: {
    kind: <span class="hljs-string" data-zh="943">'class'</span>;
    name: <span class="hljs-built_in" data-zh="944">string</span> | <span class="hljs-literal" data-zh="945">undefined</span>;
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" data-zh="946">void</span>): <span class="hljs-built_in" data-zh="947">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_" data-zh="948">Function</span> | <span class="hljs-built_in" data-zh="949">void</span>;
</code></pre>
      <p data-zh="950">Abilities of a class decorator:</p>
      <ul data-zh="951">
        <li data-zh="952">It can change the decorated class by changing <code data-zh="953">value</code>.</li>
        <li data-zh="954">It can replace the decorated class by returning a callable value.</li>
        <li data-zh="955">It can register initializers, which are called after the decorated class is fully set up.</li>
        <li data-zh="956">It does not get <code data-zh="957">context.access</code> because classes are not members of other language constructs (whereas, e.g., methods are members of classes).</li>
      </ul>
      <h3 id="example%3A-collecting-instances" tabindex="-1" data-zh="958">Example: collecting instances&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-collecting-instances" aria-hidden="true" data-zh="959">#</a></h3>
      <p data-zh="960">In the next example, we use a decorator to collect all instances of a decorated class:</p>
      <pre data-zh="961"><code class="language-js" data-zh="962"><span class="hljs-keyword" data-zh="963">class</span> <span class="hljs-title class_" data-zh="964">InstanceCollector</span> {
  instances = <span class="hljs-keyword" data-zh="965">new</span> <span class="hljs-title class_" data-zh="966">Set</span>();
  install = <span class="hljs-function" data-zh="967">(<span class="hljs-params" data-zh="968">value, {kind}</span>) =&gt;</span> {
    <span class="hljs-keyword" data-zh="969">if</span> (kind === <span class="hljs-string" data-zh="970">'class'</span>) {
      <span class="hljs-keyword" data-zh="971">const</span> _this = <span class="hljs-variable language_" data-zh="972">this</span>;
      <span class="hljs-keyword" data-zh="973">return</span> <span class="hljs-keyword" data-zh="974">function</span> (<span class="hljs-params" data-zh="975">...args</span>) { <span class="hljs-comment" data-zh="976">// (A)</span>
        <span class="hljs-keyword" data-zh="977">const</span> inst = <span class="hljs-keyword" data-zh="978">new</span> <span class="hljs-title function_" data-zh="979">value</span>(...args); <span class="hljs-comment" data-zh="980">// (B)</span>
        _this.<span class="hljs-property" data-zh="981">instances</span>.<span class="hljs-title function_" data-zh="982">add</span>(inst);
        <span class="hljs-keyword" data-zh="983">return</span> inst;
      };
    }
  };
}

<span class="hljs-keyword" data-zh="984">const</span> collector = <span class="hljs-keyword" data-zh="985">new</span> <span class="hljs-title class_" data-zh="986">InstanceCollector</span>();

@collector.<span class="hljs-property" data-zh="987">install</span>
<span class="hljs-keyword" data-zh="988">class</span> <span class="hljs-title class_" data-zh="989">MyClass</span> {}

<span class="hljs-keyword" data-zh="990">const</span> inst1 = <span class="hljs-keyword" data-zh="991">new</span> <span class="hljs-title class_" data-zh="992">MyClass</span>();
<span class="hljs-keyword" data-zh="993">const</span> inst2 = <span class="hljs-keyword" data-zh="994">new</span> <span class="hljs-title class_" data-zh="995">MyClass</span>();
<span class="hljs-keyword" data-zh="996">const</span> inst3 = <span class="hljs-keyword" data-zh="997">new</span> <span class="hljs-title class_" data-zh="998">MyClass</span>();

assert.<span class="hljs-title function_" data-zh="999">deepEqual</span>(
  collector.<span class="hljs-property" data-zh="1000">instances</span>, <span class="hljs-keyword" data-zh="1001">new</span> <span class="hljs-title class_" data-zh="1002">Set</span>([inst1, inst2, inst3])
);
</code></pre>
      <p data-zh="1003">The only way in which we can collect all instances of a given class via a decorator is by wrapping that class. The decorator in the field <code data-zh="1004">.install</code> does that by returning a function (line A) that new-calls the decorated <code data-zh="1005">value</code> (line B) and collects and returns the result.</p>
      <p data-zh="1006">Note that we can’t return an arrow function in line A, because arrow functions can’t be new-called.</p>
      <p data-zh="1007">One downside of this approach is that it breaks <code data-zh="1008">instanceof</code>:</p>
      <pre data-zh="1009"><code class="language-js" data-zh="1010">assert.<span class="hljs-title function_" data-zh="1011">equal</span>(
  inst1 <span class="hljs-keyword" data-zh="1012">instanceof</span> <span class="hljs-title class_" data-zh="1013">MyClass</span>,
  <span class="hljs-literal" data-zh="1014">false</span>
);
</code></pre>
      <p data-zh="1015">The next subsection explains how we can fix that.</p>
      <h3 id="making-sure-that-instanceof-works" tabindex="-1" data-zh="1016">Making sure that <code data-zh="1017">instanceof</code> works&nbsp;&nbsp;<a class="heading-anchor" href="#making-sure-that-instanceof-works" aria-hidden="true" data-zh="1018">#</a></h3>
      <p data-zh="1019">In this section, we use the simple decorator <code data-zh="1020">@countInstances</code> to show how we can support <code data-zh="1021">instanceof</code> for wrapped classes.</p>
      <h4 id="enabling-instanceof-via-.prototype" tabindex="-1" data-zh="1022">Enabling <code data-zh="1023">instanceof</code> via <code data-zh="1024">.prototype</code>&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-.prototype" aria-hidden="true" data-zh="1025">#</a></h4>
      <p data-zh="1026">One way of enabling <code data-zh="1027">instanceof</code> is to set the <code data-zh="1028">.prototype</code> of the wrapper function to the <code data-zh="1029">.prototype</code> of the wrapped <code data-zh="1030">value</code> (line A):</p>
      <pre data-zh="1031"><code class="language-js" data-zh="1032"><span class="hljs-keyword" data-zh="1033">function</span> <span class="hljs-title function_" data-zh="1034">countInstances</span>(<span class="hljs-params" data-zh="1035">value</span>) {
  <span class="hljs-keyword" data-zh="1036">const</span> _this = <span class="hljs-variable language_" data-zh="1037">this</span>;
  <span class="hljs-keyword" data-zh="1038">let</span> instanceCount = <span class="hljs-number" data-zh="1039">0</span>;
  <span class="hljs-comment" data-zh="1040">// The wrapper must be new-callable</span>
  <span class="hljs-keyword" data-zh="1041">const</span> wrapper = <span class="hljs-keyword" data-zh="1042">function</span> (<span class="hljs-params" data-zh="1043">...args</span>) {
    instanceCount++;
    <span class="hljs-keyword" data-zh="1044">const</span> instance = <span class="hljs-keyword" data-zh="1045">new</span> <span class="hljs-title function_" data-zh="1046">value</span>(...args);
    <span class="hljs-comment" data-zh="1047">// Change the instance</span>
    instance.<span class="hljs-property" data-zh="1048">count</span> = instanceCount;
    <span class="hljs-keyword" data-zh="1049">return</span> instance;
  };
  wrapper.<span class="hljs-property" data-zh="1050"><span class="hljs-keyword" data-zh="1051">prototype</span></span> = value.<span class="hljs-property" data-zh="1052"><span class="hljs-keyword" data-zh="1053">prototype</span></span>; <span class="hljs-comment" data-zh="1054">// (A)</span>
  <span class="hljs-keyword" data-zh="1055">return</span> wrapper;
}

@countInstances
<span class="hljs-keyword" data-zh="1056">class</span> <span class="hljs-title class_" data-zh="1057">MyClass</span> {}

<span class="hljs-keyword" data-zh="1058">const</span> inst1 = <span class="hljs-keyword" data-zh="1059">new</span> <span class="hljs-title class_" data-zh="1060">MyClass</span>();
assert.<span class="hljs-title function_" data-zh="1061">ok</span>(inst1 <span class="hljs-keyword" data-zh="1062">instanceof</span> <span class="hljs-title class_" data-zh="1063">MyClass</span>);
assert.<span class="hljs-title function_" data-zh="1064">equal</span>(inst1.<span class="hljs-property" data-zh="1065">count</span>, <span class="hljs-number" data-zh="1066">1</span>);

<span class="hljs-keyword" data-zh="1067">const</span> inst2 = <span class="hljs-keyword" data-zh="1068">new</span> <span class="hljs-title class_" data-zh="1069">MyClass</span>();
assert.<span class="hljs-title function_" data-zh="1070">ok</span>(inst2 <span class="hljs-keyword" data-zh="1071">instanceof</span> <span class="hljs-title class_" data-zh="1072">MyClass</span>);
assert.<span class="hljs-title function_" data-zh="1073">equal</span>(inst2.<span class="hljs-property" data-zh="1074">count</span>, <span class="hljs-number" data-zh="1075">2</span>);
</code></pre>
      <p data-zh="1076">Why does that work? Because the following expressions are equivalent:</p>
      <pre data-zh="1077"><code class="language-js" data-zh="1078">inst <span class="hljs-keyword" data-zh="1079">instanceof</span> C
C.<span class="hljs-property" data-zh="1080"><span class="hljs-keyword" data-zh="1081">prototype</span></span>.<span class="hljs-title function_" data-zh="1082">isPrototypeOf</span>(inst)
</code></pre>
      <p data-zh="1083">For more information on <code data-zh="1084">instanceof</code>, see <a href="https://exploringjs.com/js/book/ch_classes.html#instanceof-operator" data-zh="1085">“Exploring JavaScript”</a>.</p>
      <h4 id="enabling-instanceof-via-symbol.hasinstance" tabindex="-1" data-zh="1086">Enabling <code data-zh="1087">instanceof</code> via <code data-zh="1088">Symbol.hasInstance</code>&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-symbol.hasinstance" aria-hidden="true" data-zh="1089">#</a></h4>
      <p data-zh="1090">Another option for enabling <code data-zh="1091">instanceof</code> is to give the wrapper function a method whose key is <code data-zh="1092">Symbol.hasInstance</code> (line A):</p>
      <pre data-zh="1093"><code class="language-js" data-zh="1094"><span class="hljs-keyword" data-zh="1095">function</span> <span class="hljs-title function_" data-zh="1096">countInstances</span>(<span class="hljs-params" data-zh="1097">value</span>) {
  <span class="hljs-keyword" data-zh="1098">const</span> _this = <span class="hljs-variable language_" data-zh="1099">this</span>;
  <span class="hljs-keyword" data-zh="1100">let</span> instanceCount = <span class="hljs-number" data-zh="1101">0</span>;
  <span class="hljs-comment" data-zh="1102">// The wrapper must be new-callable</span>
  <span class="hljs-keyword" data-zh="1103">const</span> wrapper = <span class="hljs-keyword" data-zh="1104">function</span> (<span class="hljs-params" data-zh="1105">...args</span>) {
    instanceCount++;
    <span class="hljs-keyword" data-zh="1106">const</span> instance = <span class="hljs-keyword" data-zh="1107">new</span> <span class="hljs-title function_" data-zh="1108">value</span>(...args);
    <span class="hljs-comment" data-zh="1109">// Change the instance</span>
    instance.<span class="hljs-property" data-zh="1110">count</span> = instanceCount;
    <span class="hljs-keyword" data-zh="1111">return</span> instance;
  };
  <span class="hljs-comment" data-zh="1112">// Property is read-only, so we can’t use assignment</span>
  <span class="hljs-title class_" data-zh="1113">Object</span>.<span class="hljs-title function_" data-zh="1114">defineProperty</span>( <span class="hljs-comment" data-zh="1115">// (A)</span>
    wrapper, <span class="hljs-title class_" data-zh="1116">Symbol</span>.<span class="hljs-property" data-zh="1117">hasInstance</span>,
    {
      <span class="hljs-attr" data-zh="1118">value</span>: <span class="hljs-keyword" data-zh="1119">function</span> (<span class="hljs-params" data-zh="1120">x</span>) {
        <span class="hljs-keyword" data-zh="1121">return</span> x <span class="hljs-keyword" data-zh="1122">instanceof</span> value; 
      }
    }
  );
  <span class="hljs-keyword" data-zh="1123">return</span> wrapper;
}

@countInstances
<span class="hljs-keyword" data-zh="1124">class</span> <span class="hljs-title class_" data-zh="1125">MyClass</span> {}

<span class="hljs-keyword" data-zh="1126">const</span> inst1 = <span class="hljs-keyword" data-zh="1127">new</span> <span class="hljs-title class_" data-zh="1128">MyClass</span>();
assert.<span class="hljs-title function_" data-zh="1129">ok</span>(inst1 <span class="hljs-keyword" data-zh="1130">instanceof</span> <span class="hljs-title class_" data-zh="1131">MyClass</span>);
assert.<span class="hljs-title function_" data-zh="1132">equal</span>(inst1.<span class="hljs-property" data-zh="1133">count</span>, <span class="hljs-number" data-zh="1134">1</span>);

<span class="hljs-keyword" data-zh="1135">const</span> inst2 = <span class="hljs-keyword" data-zh="1136">new</span> <span class="hljs-title class_" data-zh="1137">MyClass</span>();
assert.<span class="hljs-title function_" data-zh="1138">ok</span>(inst2 <span class="hljs-keyword" data-zh="1139">instanceof</span> <span class="hljs-title class_" data-zh="1140">MyClass</span>);
assert.<span class="hljs-title function_" data-zh="1141">equal</span>(inst2.<span class="hljs-property" data-zh="1142">count</span>, <span class="hljs-number" data-zh="1143">2</span>);
</code></pre>
      <p data-zh="1144">“Exploring JavaScript” has <a href="https://exploringjs.com/js/book/ch_symbols.html#publicly-known-symbols" data-zh="1145">more information on <code data-zh="1146">Symbol.hasInstance</code></a>.</p>
      <h4 id="enabling-instanceof-via-subclassing" tabindex="-1" data-zh="1147">Enabling <code data-zh="1148">instanceof</code> via subclassing&nbsp;&nbsp;<a class="heading-anchor" href="#enabling-instanceof-via-subclassing" aria-hidden="true" data-zh="1149">#</a></h4>
      <p data-zh="1150">We can also enable <code data-zh="1151">instanceof</code> by returning a subclass of <code data-zh="1152">value</code> (line A):</p>
      <pre data-zh="1153"><code class="language-js" data-zh="1154"><span class="hljs-keyword" data-zh="1155">function</span> <span class="hljs-title function_" data-zh="1156">countInstances</span>(<span class="hljs-params" data-zh="1157">value</span>) {
  <span class="hljs-keyword" data-zh="1158">const</span> _this = <span class="hljs-variable language_" data-zh="1159">this</span>;
  <span class="hljs-keyword" data-zh="1160">let</span> instanceCount = <span class="hljs-number" data-zh="1161">0</span>;
  <span class="hljs-comment" data-zh="1162">// The wrapper must be new-callable</span>
  <span class="hljs-keyword" data-zh="1163">return</span> <span class="hljs-keyword" data-zh="1164">class</span> <span class="hljs-title class_" data-zh="1165">extends</span> value { <span class="hljs-comment" data-zh="1166">// (A)</span>
    <span class="hljs-title function_" data-zh="1167">constructor</span>(<span class="hljs-params" data-zh="1168">...args</span>) {
      <span class="hljs-variable language_" data-zh="1169">super</span>(...args);
      instanceCount++;
      <span class="hljs-comment" data-zh="1170">// Change the instance</span>
      <span class="hljs-variable language_" data-zh="1171">this</span>.<span class="hljs-property" data-zh="1172">count</span> = instanceCount;
    }
  };
}

@countInstances
<span class="hljs-keyword" data-zh="1173">class</span> <span class="hljs-title class_" data-zh="1174">MyClass</span> {}

<span class="hljs-keyword" data-zh="1175">const</span> inst1 = <span class="hljs-keyword" data-zh="1176">new</span> <span class="hljs-title class_" data-zh="1177">MyClass</span>();
assert.<span class="hljs-title function_" data-zh="1178">ok</span>(inst1 <span class="hljs-keyword" data-zh="1179">instanceof</span> <span class="hljs-title class_" data-zh="1180">MyClass</span>);
assert.<span class="hljs-title function_" data-zh="1181">equal</span>(inst1.<span class="hljs-property" data-zh="1182">count</span>, <span class="hljs-number" data-zh="1183">1</span>);

<span class="hljs-keyword" data-zh="1184">const</span> inst2 = <span class="hljs-keyword" data-zh="1185">new</span> <span class="hljs-title class_" data-zh="1186">MyClass</span>();
assert.<span class="hljs-title function_" data-zh="1187">ok</span>(inst2 <span class="hljs-keyword" data-zh="1188">instanceof</span> <span class="hljs-title class_" data-zh="1189">MyClass</span>);
assert.<span class="hljs-title function_" data-zh="1190">equal</span>(inst2.<span class="hljs-property" data-zh="1191">count</span>, <span class="hljs-number" data-zh="1192">2</span>);
</code></pre>
      <h3 id="example-freezing-instances" tabindex="-1" data-zh="1193">Example: freezing instances&nbsp;&nbsp;<a class="heading-anchor" href="#example-freezing-instances" aria-hidden="true" data-zh="1194">#</a></h3>
      <p data-zh="1195">The decorator class <code data-zh="1196">@freeze</code> freezes all instances produced by the classes it decorates:</p>
      <pre data-zh="1197"><code class="language-js" data-zh="1198"><span class="hljs-keyword" data-zh="1199">function</span> <span class="hljs-title function_" data-zh="1200">freeze</span> (<span class="hljs-params" data-zh="1201">value, {kind}</span>) {
  <span class="hljs-keyword" data-zh="1202">if</span> (kind === <span class="hljs-string" data-zh="1203">'class'</span>) {
    <span class="hljs-keyword" data-zh="1204">return</span> <span class="hljs-keyword" data-zh="1205">function</span> (<span class="hljs-params" data-zh="1206">...args</span>) {
      <span class="hljs-keyword" data-zh="1207">const</span> inst = <span class="hljs-keyword" data-zh="1208">new</span> <span class="hljs-title function_" data-zh="1209">value</span>(...args);
      <span class="hljs-keyword" data-zh="1210">return</span> <span class="hljs-title class_" data-zh="1211">Object</span>.<span class="hljs-title function_" data-zh="1212">freeze</span>(inst);
    }
  }
}

@freeze
<span class="hljs-keyword" data-zh="1213">class</span> <span class="hljs-title class_" data-zh="1214">Color</span> {
  <span class="hljs-title function_" data-zh="1215">constructor</span>(<span class="hljs-params" data-zh="1216">name</span>) {
    <span class="hljs-variable language_" data-zh="1217">this</span>.<span class="hljs-property" data-zh="1218">name</span> = name;
  }
}

<span class="hljs-keyword" data-zh="1219">const</span> red = <span class="hljs-keyword" data-zh="1220">new</span> <span class="hljs-title class_" data-zh="1221">Color</span>(<span class="hljs-string" data-zh="1222">'red'</span>);
assert.<span class="hljs-title function_" data-zh="1223">throws</span>(
  <span class="hljs-function" data-zh="1224">() =&gt;</span> red.<span class="hljs-property" data-zh="1225">name</span> = <span class="hljs-string" data-zh="1226">'green'</span>,
  <span class="hljs-regexp" data-zh="1227">/^TypeError: Cannot assign to read only property 'name'/</span>
);
</code></pre>
      <p data-zh="1228">This decorator has downsides:</p>
      <ul data-zh="1229">
        <li data-zh="1230">It breaks <code data-zh="1231">instanceof</code>. We have already seen how to fix this.</li>
        <li data-zh="1232">Subclassing a decorated class doesn’t work well:
          <ul data-zh="1233">
            <li data-zh="1234">The way in which constructors are connected isn’t ideal – with a wrapped constructor in the mix. This can be partially fixed by returning a subclass of the decorated <code data-zh="1235">value</code>.</li>
            <li data-zh="1236">Subclasses can’t set up properties, because their <code data-zh="1237">this</code> is immutable. There is no way to avoid this downside.</li>
          </ul>
        </li>
      </ul>
      <p data-zh="1238">The last downside could be avoided by giving class decorators access to the instances of the decorated classes after all constructors were executed.</p>
      <p data-zh="1239">This would change how inheritance works because a superclass could now change properties that were added by subclasses. Therefore, it’s not sure if such a mechanism is in the cards.</p>
      <h3 id="example%3A-making-classes-function-callable" tabindex="-1" data-zh="1240">Example: making classes function-callable&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-making-classes-function-callable" aria-hidden="true" data-zh="1241">#</a></h3>
      <p data-zh="1242">Classes decorated by <code data-zh="1243">@functionCallable</code> can be invoked by function calls instead of the <code data-zh="1244">new</code> operator:</p>
      <pre data-zh="1245"><code class="language-js" data-zh="1246"><span class="hljs-keyword" data-zh="1247">function</span> <span class="hljs-title function_" data-zh="1248">functionCallable</span>(<span class="hljs-params" data-zh="1249">value, {kind}</span>) {
  <span class="hljs-keyword" data-zh="1250">if</span> (kind === <span class="hljs-string" data-zh="1251">'class'</span>) {
    <span class="hljs-keyword" data-zh="1252">return</span> <span class="hljs-keyword" data-zh="1253">function</span> (<span class="hljs-params" data-zh="1254">...args</span>) {
      <span class="hljs-keyword" data-zh="1255">if</span> (<span class="hljs-keyword" data-zh="1256">new</span>.<span class="hljs-property" data-zh="1257">target</span> !== <span class="hljs-literal" data-zh="1258">undefined</span>) {
        <span class="hljs-keyword" data-zh="1259">throw</span> <span class="hljs-keyword" data-zh="1260">new</span> <span class="hljs-title class_" data-zh="1261">TypeError</span>(<span class="hljs-string" data-zh="1262">'This function can’t be new-invoked'</span>);
      }
      <span class="hljs-keyword" data-zh="1263">return</span> <span class="hljs-keyword" data-zh="1264">new</span> <span class="hljs-title function_" data-zh="1265">value</span>(...args);
    }
  }
}

@functionCallable
<span class="hljs-keyword" data-zh="1266">class</span> <span class="hljs-title class_" data-zh="1267">Person</span> {
  <span class="hljs-title function_" data-zh="1268">constructor</span>(<span class="hljs-params" data-zh="1269">name</span>) {
    <span class="hljs-variable language_" data-zh="1270">this</span>.<span class="hljs-property" data-zh="1271">name</span> = name;
  }
}
<span class="hljs-keyword" data-zh="1272">const</span> robin = <span class="hljs-title class_" data-zh="1273">Person</span>(<span class="hljs-string" data-zh="1274">'Robin'</span>);
assert.<span class="hljs-title function_" data-zh="1275">equal</span>(
  robin.<span class="hljs-property" data-zh="1276">name</span>, <span class="hljs-string" data-zh="1277">'Robin'</span>
);
</code></pre>
      <h2 id="class-method-decorators" tabindex="-1" data-zh="1278">Class method decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-method-decorators" aria-hidden="true" data-zh="1279">#</a></h2>
      <p data-zh="1280">Class method decorators have the following type signature:</p>
      <pre data-zh="1281"><code class="language-ts" data-zh="1282"><span class="hljs-keyword" data-zh="1283">type</span> <span class="hljs-title class_" data-zh="1284">ClassMethodDecorator</span> = <span class="hljs-function" data-zh="1285">(<span class="hljs-params" data-zh="1286">
  <span class="hljs-attr" data-zh="1287">value</span>: <span class="hljs-title class_" data-zh="1288">Function</span>,
  <span class="hljs-attr" data-zh="1289">context</span>: {
    kind: <span class="hljs-string" data-zh="1290">'method'</span>;
    name: <span class="hljs-built_in" data-zh="1291">string</span> | <span class="hljs-built_in" data-zh="1292">symbol</span>;
    <span class="hljs-keyword" data-zh="1293">static</span>: <span class="hljs-built_in" data-zh="1294">boolean</span>;
    <span class="hljs-keyword" data-zh="1295">private</span>: <span class="hljs-built_in" data-zh="1296">boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in" data-zh="1297">unknown</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" data-zh="1298">void</span>): <span class="hljs-built_in" data-zh="1299">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_" data-zh="1300">Function</span> | <span class="hljs-built_in" data-zh="1301">void</span>;
</code></pre>
      <p data-zh="1302">Abilities of a method decorator:</p>
      <ul data-zh="1303">
        <li data-zh="1304">It can change the decorated method by changing <code data-zh="1305">value</code>.</li>
        <li data-zh="1306">It can replace the decorated method by returning a function.</li>
        <li data-zh="1307">It can register initializers.</li>
        <li data-zh="1308"><code data-zh="1309">context.access</code> only supports getting the value of its property, not setting it.</li>
      </ul>
      <p data-zh="1310">Constructors can’t be decorated: They look like methods, but they aren’t really methods.</p>
      <h3 id="example-tracing-method-invocations" tabindex="-1" data-zh="1311">Example: tracing method invocations&nbsp;&nbsp;<a class="heading-anchor" href="#example-tracing-method-invocations" aria-hidden="true" data-zh="1312">#</a></h3>
      <p data-zh="1313">The decorator <code data-zh="1314">@trace</code> wraps methods so that their invocations and results are logged to the console:</p>
      <pre data-zh="1315"><code class="language-js" data-zh="1316"><span class="hljs-keyword" data-zh="1317">function</span> <span class="hljs-title function_" data-zh="1318">trace</span>(<span class="hljs-params" data-zh="1319">value, {kind, name}</span>) {
  <span class="hljs-keyword" data-zh="1320">if</span> (kind === <span class="hljs-string" data-zh="1321">'method'</span>) {
    <span class="hljs-keyword" data-zh="1322">return</span> <span class="hljs-keyword" data-zh="1323">function</span> (<span class="hljs-params" data-zh="1324">...args</span>) {
      <span class="hljs-variable language_" data-zh="1325">console</span>.<span class="hljs-title function_" data-zh="1326">log</span>(<span class="hljs-string" data-zh="1327">`CALL <span class="hljs-subst" data-zh="1328">${name}</span>: <span class="hljs-subst" data-zh="1329">${<span class="hljs-built_in" data-zh="1330">JSON</span>.stringify(args)}</span>`</span>);
      <span class="hljs-keyword" data-zh="1331">const</span> result = value.<span class="hljs-title function_" data-zh="1332">apply</span>(<span class="hljs-variable language_" data-zh="1333">this</span>, args);
      <span class="hljs-variable language_" data-zh="1334">console</span>.<span class="hljs-title function_" data-zh="1335">log</span>(<span class="hljs-string" data-zh="1336">'=&gt; '</span> + <span class="hljs-title class_" data-zh="1337">JSON</span>.<span class="hljs-title function_" data-zh="1338">stringify</span>(result));
      <span class="hljs-keyword" data-zh="1339">return</span> result;
    };
  }
}

<span class="hljs-keyword" data-zh="1340">class</span> <span class="hljs-title class_" data-zh="1341">StringBuilder</span> {
  #str = <span class="hljs-string" data-zh="1342">''</span>;
  @trace
  <span class="hljs-title function_" data-zh="1343">add</span>(<span class="hljs-params" data-zh="1344">str</span>) {
    <span class="hljs-variable language_" data-zh="1345">this</span>.#str += str;
  }
  @trace
  <span class="hljs-title function_" data-zh="1346">toString</span>(<span class="hljs-params" data-zh="1347"></span>) {
    <span class="hljs-keyword" data-zh="1348">return</span> <span class="hljs-variable language_" data-zh="1349">this</span>.#str;
  }
}

<span class="hljs-keyword" data-zh="1350">const</span> sb = <span class="hljs-keyword" data-zh="1351">new</span> <span class="hljs-title class_" data-zh="1352">StringBuilder</span>();
sb.<span class="hljs-title function_" data-zh="1353">add</span>(<span class="hljs-string" data-zh="1354">'Home'</span>);
sb.<span class="hljs-title function_" data-zh="1355">add</span>(<span class="hljs-string" data-zh="1356">'page'</span>);
assert.<span class="hljs-title function_" data-zh="1357">equal</span>(
  sb.<span class="hljs-title function_" data-zh="1358">toString</span>(), <span class="hljs-string" data-zh="1359">'Homepage'</span>
);

<span class="hljs-comment" data-zh="1360">// Output:</span>
<span class="hljs-comment" data-zh="1361">// CALL add: ["Home"]</span>
<span class="hljs-comment" data-zh="1362">// =&gt; undefined</span>
<span class="hljs-comment" data-zh="1363">// CALL add: ["page"]</span>
<span class="hljs-comment" data-zh="1364">// =&gt; undefined</span>
<span class="hljs-comment" data-zh="1365">// CALL toString: []</span>
<span class="hljs-comment" data-zh="1366">// =&gt; "Homepage"</span>
</code></pre>
      <h3 id="example%3A-binding-methods-to-instances" tabindex="-1" data-zh="1367">Example: binding methods to instances&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-binding-methods-to-instances" aria-hidden="true" data-zh="1368">#</a></h3>
      <p data-zh="1369">Normally, extracting methods (line A) means that we can’t function-call them because that sets <code data-zh="1370">this</code> to <code data-zh="1371">undefined</code>:</p>
      <pre data-zh="1372"><code class="language-js" data-zh="1373"><span class="hljs-keyword" data-zh="1374">class</span> <span class="hljs-title class_" data-zh="1375">Color1</span> {
  #name;
  <span class="hljs-title function_" data-zh="1376">constructor</span>(<span class="hljs-params" data-zh="1377">name</span>) {
    <span class="hljs-variable language_" data-zh="1378">this</span>.#name = name;
  }
  <span class="hljs-title function_" data-zh="1379">toString</span>(<span class="hljs-params" data-zh="1380"></span>) {
    <span class="hljs-keyword" data-zh="1381">return</span> <span class="hljs-string" data-zh="1382">`Color(<span class="hljs-subst" data-zh="1383">${<span class="hljs-variable language_" data-zh="1384">this</span>.#name}</span>)`</span>;
  }
}

<span class="hljs-keyword" data-zh="1385">const</span> green1 = <span class="hljs-keyword" data-zh="1386">new</span> <span class="hljs-title class_" data-zh="1387">Color1</span>(<span class="hljs-string" data-zh="1388">'green'</span>);
<span class="hljs-keyword" data-zh="1389">const</span> toString1 = green1.<span class="hljs-property" data-zh="1390">toString</span>; <span class="hljs-comment" data-zh="1391">// (A)</span>
assert.<span class="hljs-title function_" data-zh="1392">throws</span>(
  <span class="hljs-function" data-zh="1393">() =&gt;</span> <span class="hljs-title function_" data-zh="1394">toString1</span>(),
  <span class="hljs-regexp" data-zh="1395">/^TypeError: Cannot read properties of undefined/</span>
);
</code></pre>
      <p data-zh="1396">We can fix that via the decorator <code data-zh="1397">@bind</code>:</p>
      <pre data-zh="1398"><code class="language-js" data-zh="1399"><span class="hljs-keyword" data-zh="1400">function</span> <span class="hljs-title function_" data-zh="1401">bind</span>(<span class="hljs-params" data-zh="1402">value, {kind, name, addInitializer}</span>) {
  <span class="hljs-keyword" data-zh="1403">if</span> (kind === <span class="hljs-string" data-zh="1404">'method'</span>) {
    <span class="hljs-title function_" data-zh="1405">addInitializer</span>(<span class="hljs-keyword" data-zh="1406">function</span> (<span class="hljs-params" data-zh="1407"></span>) { <span class="hljs-comment" data-zh="1408">// (B)</span>
      <span class="hljs-variable language_" data-zh="1409">this</span>[name] = value.<span class="hljs-title function_" data-zh="1410">bind</span>(<span class="hljs-variable language_" data-zh="1411">this</span>); <span class="hljs-comment" data-zh="1412">// (C)</span>
    });
  }
}

<span class="hljs-keyword" data-zh="1413">class</span> <span class="hljs-title class_" data-zh="1414">Color2</span> {
  #name;
  <span class="hljs-title function_" data-zh="1415">constructor</span>(<span class="hljs-params" data-zh="1416">name</span>) {
    <span class="hljs-variable language_" data-zh="1417">this</span>.#name = name;
  }
  @bind
  <span class="hljs-title function_" data-zh="1418">toString</span>(<span class="hljs-params" data-zh="1419"></span>) {
    <span class="hljs-keyword" data-zh="1420">return</span> <span class="hljs-string" data-zh="1421">`Color(<span class="hljs-subst" data-zh="1422">${<span class="hljs-variable language_" data-zh="1423">this</span>.#name}</span>)`</span>;
  }
}

<span class="hljs-keyword" data-zh="1424">const</span> green2 = <span class="hljs-keyword" data-zh="1425">new</span> <span class="hljs-title class_" data-zh="1426">Color2</span>(<span class="hljs-string" data-zh="1427">'green'</span>);
<span class="hljs-keyword" data-zh="1428">const</span> toString2 = green2.<span class="hljs-property" data-zh="1429">toString</span>;
assert.<span class="hljs-title function_" data-zh="1430">equal</span>(
  <span class="hljs-title function_" data-zh="1431">toString2</span>(), <span class="hljs-string" data-zh="1432">'Color(green)'</span>
);

<span class="hljs-comment" data-zh="1433">// The own property green2.toString is different</span>
<span class="hljs-comment" data-zh="1434">// from Color2.prototype.toString</span>
assert.<span class="hljs-title function_" data-zh="1435">ok</span>(<span class="hljs-title class_" data-zh="1436">Object</span>.<span class="hljs-title function_" data-zh="1437">hasOwn</span>(green2, <span class="hljs-string" data-zh="1438">'toString'</span>));
assert.<span class="hljs-title function_" data-zh="1439">notEqual</span>(
  green2.<span class="hljs-property" data-zh="1440">toString</span>,
  <span class="hljs-title class_" data-zh="1441">Color2</span>.<span class="hljs-property" data-zh="1442"><span class="hljs-keyword" data-zh="1443">prototype</span></span>.<span class="hljs-property" data-zh="1444">toString</span>
);
</code></pre>
      <p data-zh="1445">Per decorated method, the initializer registered in line B is invoked whenever an instance is created and adds an own property whose value is a function with a fixed <code data-zh="1446">this</code> (line C).</p>
      <h3 id="example%3A-applying-functions-to-methods" tabindex="-1" data-zh="1447">Example: applying functions to methods&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-applying-functions-to-methods" aria-hidden="true" data-zh="1448">#</a></h3>
      <p data-zh="1449">The library <code data-zh="1450">core-decorators</code> has <a href="https://github.com/jayphelps/core-decorators#decorate" data-zh="1451">a decorator</a> that lets us apply functions to methods. That enables us to use helper functions such as Lodash’s <code data-zh="1452">memoize()</code>. The following code shows an implementation <code data-zh="1453">@applyFunction</code> of such a decorator:</p>
      <pre data-zh="1454"><code class="language-js" data-zh="1455"><span class="hljs-keyword" data-zh="1456">import</span> { memoize } <span class="hljs-keyword" data-zh="1457">from</span> <span class="hljs-string" data-zh="1458">'lodash-es'</span>;

<span class="hljs-keyword" data-zh="1459">function</span> <span class="hljs-title function_" data-zh="1460">applyFunction</span>(<span class="hljs-params" data-zh="1461">functionFactory</span>) {
  <span class="hljs-keyword" data-zh="1462">return</span> <span class="hljs-function" data-zh="1463">(<span class="hljs-params" data-zh="1464">value, {kind}</span>) =&gt;</span> { <span class="hljs-comment" data-zh="1465">// decorator function</span>
    <span class="hljs-keyword" data-zh="1466">if</span> (kind === <span class="hljs-string" data-zh="1467">'method'</span>) {
      <span class="hljs-keyword" data-zh="1468">return</span> <span class="hljs-title function_" data-zh="1469">functionFactory</span>(value);
    }
  };
}

<span class="hljs-keyword" data-zh="1470">let</span> invocationCount = <span class="hljs-number" data-zh="1471">0</span>;

<span class="hljs-keyword" data-zh="1472">class</span> <span class="hljs-title class_" data-zh="1473">Task</span> {
  @<span class="hljs-title function_" data-zh="1474">applyFunction</span>(memoize)
  <span class="hljs-title function_" data-zh="1475">expensiveOperation</span>(<span class="hljs-params" data-zh="1476">str</span>) {
    invocationCount++;
    <span class="hljs-comment" data-zh="1477">// Expensive processing of `str` 😀</span>
    <span class="hljs-keyword" data-zh="1478">return</span> str + str;
  }
}

<span class="hljs-keyword" data-zh="1479">const</span> task = <span class="hljs-keyword" data-zh="1480">new</span> <span class="hljs-title class_" data-zh="1481">Task</span>();
assert.<span class="hljs-title function_" data-zh="1482">equal</span>(
  task.<span class="hljs-title function_" data-zh="1483">expensiveOperation</span>(<span class="hljs-string" data-zh="1484">'abc'</span>),
  <span class="hljs-string" data-zh="1485">'abcabc'</span>
);
assert.<span class="hljs-title function_" data-zh="1486">equal</span>(
  task.<span class="hljs-title function_" data-zh="1487">expensiveOperation</span>(<span class="hljs-string" data-zh="1488">'abc'</span>),
  <span class="hljs-string" data-zh="1489">'abcabc'</span>
);
assert.<span class="hljs-title function_" data-zh="1490">equal</span>(
  invocationCount, <span class="hljs-number" data-zh="1491">1</span>
);
</code></pre>
      <h2 id="class-getter-decorators%2C-class-setter-decorators" tabindex="-1" data-zh="1492">Class getter decorators, class setter decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-getter-decorators%2C-class-setter-decorators" aria-hidden="true" data-zh="1493">#</a></h2>
      <p data-zh="1494">These are the type signatures of getter decorators and setter decorators:</p>
      <pre data-zh="1495"><code class="language-ts" data-zh="1496"><span class="hljs-keyword" data-zh="1497">type</span> <span class="hljs-title class_" data-zh="1498">ClassGetterDecorator</span> = <span class="hljs-function" data-zh="1499">(<span class="hljs-params" data-zh="1500">
  <span class="hljs-attr" data-zh="1501">value</span>: <span class="hljs-title class_" data-zh="1502">Function</span>,
  <span class="hljs-attr" data-zh="1503">context</span>: {
    kind: <span class="hljs-string" data-zh="1504">'getter'</span>;
    name: <span class="hljs-built_in" data-zh="1505">string</span> | <span class="hljs-built_in" data-zh="1506">symbol</span>;
    <span class="hljs-keyword" data-zh="1507">static</span>: <span class="hljs-built_in" data-zh="1508">boolean</span>;
    <span class="hljs-keyword" data-zh="1509">private</span>: <span class="hljs-built_in" data-zh="1510">boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in" data-zh="1511">unknown</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" data-zh="1512">void</span>): <span class="hljs-built_in" data-zh="1513">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_" data-zh="1514">Function</span> | <span class="hljs-built_in" data-zh="1515">void</span>;

<span class="hljs-keyword" data-zh="1516">type</span> <span class="hljs-title class_" data-zh="1517">ClassSetterDecorator</span> = <span class="hljs-function" data-zh="1518">(<span class="hljs-params" data-zh="1519">
  <span class="hljs-attr" data-zh="1520">value</span>: <span class="hljs-title class_" data-zh="1521">Function</span>,
  <span class="hljs-attr" data-zh="1522">context</span>: {
    kind: <span class="hljs-string" data-zh="1523">'setter'</span>;
    name: <span class="hljs-built_in" data-zh="1524">string</span> | <span class="hljs-built_in" data-zh="1525">symbol</span>;
    <span class="hljs-keyword" data-zh="1526">static</span>: <span class="hljs-built_in" data-zh="1527">boolean</span>;
    <span class="hljs-keyword" data-zh="1528">private</span>: <span class="hljs-built_in" data-zh="1529">boolean</span>;
    access: { set: (value: <span class="hljs-built_in" data-zh="1530">unknown</span>) =&gt; <span class="hljs-built_in" data-zh="1531">void</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" data-zh="1532">void</span>): <span class="hljs-built_in" data-zh="1533">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-title class_" data-zh="1534">Function</span> | <span class="hljs-built_in" data-zh="1535">void</span>;
</code></pre>
      <p data-zh="1536">Getter decorators and setter decorators have similar abilities to method decorators.</p>
      <h3 id="example%3A-computing-values-lazily" tabindex="-1" data-zh="1537">Example: computing values lazily&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-computing-values-lazily" aria-hidden="true" data-zh="1538">#</a></h3>
      <p data-zh="1539">To implement a property whose value is computed <em data-zh="1540">lazily</em> (on demand), we use two techniques:</p>
      <ul data-zh="1541">
        <li data-zh="1542">
          <p data-zh="1543">We implement the property via a getter. That way, the code that computes its value, is only executed if the property is read.</p>
        </li>
        <li data-zh="1544">
          <p data-zh="1545">The decorator <code data-zh="1546">@lazy</code> wraps the original getter: When the wrapper is invoked for the first time, it invokes the getter and creates an own data property whose value is the result. From now on, the own property overrides the inherited getter whenever someone reads the property.</p>
        </li>
      </ul>
      <pre data-zh="1547"><code class="language-js" data-zh="1548"><span class="hljs-keyword" data-zh="1549">class</span> <span class="hljs-title class_" data-zh="1550">C</span> {
  @lazy
  <span class="hljs-keyword" data-zh="1551">get</span> <span class="hljs-title function_" data-zh="1552">value</span>() {
    <span class="hljs-variable language_" data-zh="1553">console</span>.<span class="hljs-title function_" data-zh="1554">log</span>(<span class="hljs-string" data-zh="1555">'COMPUTING'</span>);
    <span class="hljs-keyword" data-zh="1556">return</span> <span class="hljs-string" data-zh="1557">'Result of computation'</span>;
  }
}

<span class="hljs-keyword" data-zh="1558">function</span> <span class="hljs-title function_" data-zh="1559">lazy</span>(<span class="hljs-params" data-zh="1560">value, {kind, name, addInitializer}</span>) {
  <span class="hljs-keyword" data-zh="1561">if</span> (kind === <span class="hljs-string" data-zh="1562">'getter'</span>) {
    <span class="hljs-keyword" data-zh="1563">return</span> <span class="hljs-keyword" data-zh="1564">function</span> (<span class="hljs-params" data-zh="1565"></span>) {
      <span class="hljs-keyword" data-zh="1566">const</span> result = value.<span class="hljs-title function_" data-zh="1567">call</span>(<span class="hljs-variable language_" data-zh="1568">this</span>);
      <span class="hljs-title class_" data-zh="1569">Object</span>.<span class="hljs-title function_" data-zh="1570">defineProperty</span>( <span class="hljs-comment" data-zh="1571">// (A)</span>
        <span class="hljs-variable language_" data-zh="1572">this</span>, name,
        {
          <span class="hljs-attr" data-zh="1573">value</span>: result,
          <span class="hljs-attr" data-zh="1574">writable</span>: <span class="hljs-literal" data-zh="1575">false</span>,
        }
      );
      <span class="hljs-keyword" data-zh="1576">return</span> result;
    };
  }
}

<span class="hljs-variable language_" data-zh="1577">console</span>.<span class="hljs-title function_" data-zh="1578">log</span>(<span class="hljs-string" data-zh="1579">'1 new C()'</span>);
<span class="hljs-keyword" data-zh="1580">const</span> inst = <span class="hljs-keyword" data-zh="1581">new</span> <span class="hljs-title function_" data-zh="1582">C</span>();
<span class="hljs-variable language_" data-zh="1583">console</span>.<span class="hljs-title function_" data-zh="1584">log</span>(<span class="hljs-string" data-zh="1585">'2 inst.value'</span>);
assert.<span class="hljs-title function_" data-zh="1586">equal</span>(inst.<span class="hljs-property" data-zh="1587">value</span>, <span class="hljs-string" data-zh="1588">'Result of computation'</span>);
<span class="hljs-variable language_" data-zh="1589">console</span>.<span class="hljs-title function_" data-zh="1590">log</span>(<span class="hljs-string" data-zh="1591">'3 inst.value'</span>);
assert.<span class="hljs-title function_" data-zh="1592">equal</span>(inst.<span class="hljs-property" data-zh="1593">value</span>, <span class="hljs-string" data-zh="1594">'Result of computation'</span>);
<span class="hljs-variable language_" data-zh="1595">console</span>.<span class="hljs-title function_" data-zh="1596">log</span>(<span class="hljs-string" data-zh="1597">'4 end'</span>);

<span class="hljs-comment" data-zh="1598">// Output:</span>
<span class="hljs-comment" data-zh="1599">// 1 new C()</span>
<span class="hljs-comment" data-zh="1600">// 2 inst.value</span>
<span class="hljs-comment" data-zh="1601">// COMPUTING</span>
<span class="hljs-comment" data-zh="1602">// 3 inst.value</span>
<span class="hljs-comment" data-zh="1603">// 4 end</span>
</code></pre>
      <p data-zh="1604">Note that property <code data-zh="1605">.[name]</code> is immutable (because there is only a getter), which is why we have to define the property (line A) and can’t use assignment.</p>
      <h2 id="class-field-decorators" tabindex="-1" data-zh="1606">Class field decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-field-decorators" aria-hidden="true" data-zh="1607">#</a></h2>
      <p data-zh="1608">Class field decorators have the following type signature:</p>
      <pre data-zh="1609"><code class="language-ts" data-zh="1610"><span class="hljs-keyword" data-zh="1611">type</span> <span class="hljs-title class_" data-zh="1612">ClassFieldDecorator</span> = <span class="hljs-function" data-zh="1613">(<span class="hljs-params" data-zh="1614">
  <span class="hljs-attr" data-zh="1615">value</span>: <span class="hljs-literal" data-zh="1616">undefined</span>,
  <span class="hljs-attr" data-zh="1617">context</span>: {
    kind: <span class="hljs-string" data-zh="1618">'field'</span>;
    name: <span class="hljs-built_in" data-zh="1619">string</span> | <span class="hljs-built_in" data-zh="1620">symbol</span>;
    <span class="hljs-keyword" data-zh="1621">static</span>: <span class="hljs-built_in" data-zh="1622">boolean</span>;
    <span class="hljs-keyword" data-zh="1623">private</span>: <span class="hljs-built_in" data-zh="1624">boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in" data-zh="1625">unknown</span>, set: (value: <span class="hljs-built_in" data-zh="1626">unknown</span>) =&gt; <span class="hljs-built_in" data-zh="1627">void</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" data-zh="1628">void</span>): <span class="hljs-built_in" data-zh="1629">void</span>;
  }
</span>) =&gt;</span> <span class="hljs-function" data-zh="1630">(<span class="hljs-params" data-zh="1631"><span class="hljs-attr" data-zh="1632">initialValue</span>: <span class="hljs-built_in" data-zh="1633">unknown</span></span>) =&gt;</span> <span class="hljs-built_in" data-zh="1634">unknown</span> | <span class="hljs-built_in" data-zh="1635">void</span>;
</code></pre>
      <p data-zh="1636">Abilities of a field decorator:</p>
      <ul data-zh="1637">
        <li data-zh="1638">
          <p data-zh="1639">It cannot change or replace its field. If we need that functionality, we have to use an <em data-zh="1640">auto-accessor</em> (what that is, is described <a href="#auto-accessors" data-zh="1641">later</a>).</p>
        </li>
        <li data-zh="1642">
          <p data-zh="1643">It can change the value with which “its” field is initialized, by returning a function that receives the original initialization value and returns a new initialization value.</p>
          <ul data-zh="1644">
            <li data-zh="1645">Inside that function, <code data-zh="1646">this</code> refers to the current instance.</li>
          </ul>
        </li>
        <li data-zh="1647">
          <p data-zh="1648">It can register initializers. That is a recent change (post-2022-03) of the decorators API and wasn’t possible before.</p>
        </li>
      </ul>
      <ul data-zh="1649">
        <li data-zh="1650">It can expose access to its field (even if it’s private) via <code data-zh="1651">context.access</code>.</li>
      </ul>
      <h3 id="example%3A-changing-initialization-values-of-fields" tabindex="-1" data-zh="1652">Example: changing initialization values of fields&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-changing-initialization-values-of-fields" aria-hidden="true" data-zh="1653">#</a></h3>
      <p data-zh="1654">The decorator <code data-zh="1655">@twice</code> doubles the original initialization value of a field by returning a function that performs this change:</p>
      <pre data-zh="1656"><code class="language-js" data-zh="1657"><span class="hljs-keyword" data-zh="1658">function</span> <span class="hljs-title function_" data-zh="1659">twice</span>(<span class="hljs-params" data-zh="1660"></span>) {
  <span class="hljs-keyword" data-zh="1661">return</span> <span class="hljs-function" data-zh="1662"><span class="hljs-params" data-zh="1663">initialValue</span> =&gt;</span> initialValue * <span class="hljs-number" data-zh="1664">2</span>;
}

<span class="hljs-keyword" data-zh="1665">class</span> <span class="hljs-title class_" data-zh="1666">C</span> {
  @twice
  field = <span class="hljs-number" data-zh="1667">3</span>;
}

<span class="hljs-keyword" data-zh="1668">const</span> inst = <span class="hljs-keyword" data-zh="1669">new</span> <span class="hljs-title function_" data-zh="1670">C</span>();
assert.<span class="hljs-title function_" data-zh="1671">equal</span>(
  inst.<span class="hljs-property" data-zh="1672">field</span>, <span class="hljs-number" data-zh="1673">6</span>
);
</code></pre>
      <h3 id="read-only-fields" tabindex="-1" data-zh="1674">Example: read-only fields (instance public fields)&nbsp;&nbsp;<a class="heading-anchor" href="#read-only-fields" aria-hidden="true" data-zh="1675">#</a></h3>
      <p data-zh="1676">The decorator <code data-zh="1677">@readOnly</code> makes a field immutable. It waits until the field was completely set up (either via an assignment or via the constructor) before it does so.</p>
      <pre data-zh="1678"><code class="language-js" data-zh="1679"><span class="hljs-keyword" data-zh="1680">const</span> readOnlyFieldKeys = <span class="hljs-title class_" data-zh="1681">Symbol</span>(<span class="hljs-string" data-zh="1682">'readOnlyFieldKeys'</span>);

@readOnly
<span class="hljs-keyword" data-zh="1683">class</span> <span class="hljs-title class_" data-zh="1684">Color</span> {
  @readOnly
  name;
  <span class="hljs-title function_" data-zh="1685">constructor</span>(<span class="hljs-params" data-zh="1686">name</span>) {
    <span class="hljs-variable language_" data-zh="1687">this</span>.<span class="hljs-property" data-zh="1688">name</span> = name;
  }
}

<span class="hljs-keyword" data-zh="1689">const</span> blue = <span class="hljs-keyword" data-zh="1690">new</span> <span class="hljs-title class_" data-zh="1691">Color</span>(<span class="hljs-string" data-zh="1692">'blue'</span>);
assert.<span class="hljs-title function_" data-zh="1693">equal</span>(blue.<span class="hljs-property" data-zh="1694">name</span>, <span class="hljs-string" data-zh="1695">'blue'</span>);
assert.<span class="hljs-title function_" data-zh="1696">throws</span>(
  <span class="hljs-function" data-zh="1697">() =&gt;</span> blue.<span class="hljs-property" data-zh="1698">name</span> = <span class="hljs-string" data-zh="1699">'brown'</span>,
  <span class="hljs-regexp" data-zh="1700">/^TypeError: Cannot assign to read only property 'name'/</span>
);

<span class="hljs-keyword" data-zh="1701">function</span> <span class="hljs-title function_" data-zh="1702">readOnly</span>(<span class="hljs-params" data-zh="1703">value, {kind, name}</span>) {
  <span class="hljs-keyword" data-zh="1704">if</span> (kind === <span class="hljs-string" data-zh="1705">'field'</span>) { <span class="hljs-comment" data-zh="1706">// (A)</span>
    <span class="hljs-keyword" data-zh="1707">return</span> <span class="hljs-keyword" data-zh="1708">function</span> (<span class="hljs-params" data-zh="1709"></span>) {
      <span class="hljs-keyword" data-zh="1710">if</span> (!<span class="hljs-variable language_" data-zh="1711">this</span>[readOnlyFieldKeys]) {
        <span class="hljs-variable language_" data-zh="1712">this</span>[readOnlyFieldKeys] = [];
      }
      <span class="hljs-variable language_" data-zh="1713">this</span>[readOnlyFieldKeys].<span class="hljs-title function_" data-zh="1714">push</span>(name);
    };
  }
  <span class="hljs-keyword" data-zh="1715">if</span> (kind === <span class="hljs-string" data-zh="1716">'class'</span>) { <span class="hljs-comment" data-zh="1717">// (B)</span>
    <span class="hljs-keyword" data-zh="1718">return</span> <span class="hljs-keyword" data-zh="1719">function</span> (<span class="hljs-params" data-zh="1720">...args</span>) {
      <span class="hljs-keyword" data-zh="1721">const</span> inst = <span class="hljs-keyword" data-zh="1722">new</span> <span class="hljs-title function_" data-zh="1723">value</span>(...args);
      <span class="hljs-keyword" data-zh="1724">for</span> (<span class="hljs-keyword" data-zh="1725">const</span> key <span class="hljs-keyword" data-zh="1726">of</span> inst[readOnlyFieldKeys]) {
        <span class="hljs-title class_" data-zh="1727">Object</span>.<span class="hljs-title function_" data-zh="1728">defineProperty</span>(inst, key, {<span class="hljs-attr" data-zh="1729">writable</span>: <span class="hljs-literal" data-zh="1730">false</span>});
      }
      <span class="hljs-keyword" data-zh="1731">return</span> inst;
    }
  }
}
</code></pre>
      <p data-zh="1732">We need two steps to implement the functionality of <code data-zh="1733">@readOnly</code> (which is why the class is also decorated):</p>
      <ul data-zh="1734">
        <li data-zh="1735">We first collect all keys of read-only fields (line A).</li>
        <li data-zh="1736">Then we wait until the instance was completely set up and make the fields, whose keys we collected, non-writable (line B). We need to wrap the class because decorator initializers are executed too early.</li>
      </ul>
      <p data-zh="1737">Similarly to making instances immutable, this decorator breaks <code data-zh="1738">instanceof</code>. The same workaround can be used here, too.</p>
      <p data-zh="1739">We’ll later see <a href="#read-only-auto-accessors" data-zh="1740">a version <code data-zh="1741">@readOnly</code> that works with auto-accessors</a> instead of fields. That implementation does not require the class to be decorated.</p>
      <h3 id="example%3A-dependency-injection-(instance-public-fields)" tabindex="-1" data-zh="1742">Example: dependency injection (instance public fields)&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-dependency-injection-(instance-public-fields)" aria-hidden="true" data-zh="1743">#</a></h3>
      <p data-zh="1744"><em data-zh="1745">Dependency injection</em> is motivated by the following observation: If we provide the constructor of a class with its dependencies (vs. the constructor setting them up itself), then it’s easier to adapt the dependencies to different environments, including testing.</p>
      <p data-zh="1746">This is an <em data-zh="1747">inversion of control</em>: The constructor does not do its own setup, we do it for it. Approaches for doing dependency injection:</p>
      <ol data-zh="1748">
        <li data-zh="1749">Manually, by creating dependencies and passing them to the constructor.</li>
        <li data-zh="1750">Via “contexts” in frontend frameworks such as React</li>
        <li data-zh="1751">Via decorators and a <em data-zh="1752">dependency injection registry</em> (a minor variation of <em data-zh="1753">dependency injection containers</em>)</li>
      </ol>
      <p data-zh="1754">The following code is a simple implementation of approach #3:</p>
      <pre data-zh="1755"><code class="language-js" data-zh="1756"><span class="hljs-keyword" data-zh="1757">const</span> {registry, inject} = <span class="hljs-title function_" data-zh="1758">createRegistry</span>();

<span class="hljs-keyword" data-zh="1759">class</span> <span class="hljs-title class_" data-zh="1760">Logger</span> {
  <span class="hljs-title function_" data-zh="1761">log</span>(<span class="hljs-params" data-zh="1762">str</span>) {
    <span class="hljs-variable language_" data-zh="1763">console</span>.<span class="hljs-title function_" data-zh="1764">log</span>(str);
  }
}
<span class="hljs-keyword" data-zh="1765">class</span> <span class="hljs-title class_" data-zh="1766">Main</span> {
  @inject logger;
  <span class="hljs-title function_" data-zh="1767">run</span>(<span class="hljs-params" data-zh="1768"></span>) {
    <span class="hljs-variable language_" data-zh="1769">this</span>.<span class="hljs-property" data-zh="1770">logger</span>.<span class="hljs-title function_" data-zh="1771">log</span>(<span class="hljs-string" data-zh="1772">'Hello!'</span>);
  }
}

registry.<span class="hljs-title function_" data-zh="1773">register</span>(<span class="hljs-string" data-zh="1774">'logger'</span>, <span class="hljs-title class_" data-zh="1775">Logger</span>);
<span class="hljs-keyword" data-zh="1776">new</span> <span class="hljs-title class_" data-zh="1777">Main</span>().<span class="hljs-title function_" data-zh="1778">run</span>();

<span class="hljs-comment" data-zh="1779">// Output:</span>
<span class="hljs-comment" data-zh="1780">// Hello!</span>
</code></pre>
      <p data-zh="1781">This is how <code data-zh="1782">createRegistry()</code> is implemented:</p>
      <pre data-zh="1783"><code class="language-js" data-zh="1784"><span class="hljs-keyword" data-zh="1785">function</span> <span class="hljs-title function_" data-zh="1786">createRegistry</span>(<span class="hljs-params" data-zh="1787"></span>) {
  <span class="hljs-keyword" data-zh="1788">const</span> nameToClass = <span class="hljs-keyword" data-zh="1789">new</span> <span class="hljs-title class_" data-zh="1790">Map</span>();
  <span class="hljs-keyword" data-zh="1791">const</span> nameToInstance = <span class="hljs-keyword" data-zh="1792">new</span> <span class="hljs-title class_" data-zh="1793">Map</span>();
  <span class="hljs-keyword" data-zh="1794">const</span> registry = {
    <span class="hljs-title function_" data-zh="1795">register</span>(<span class="hljs-params" data-zh="1796">name, componentClass</span>) {
      nameToClass.<span class="hljs-title function_" data-zh="1797">set</span>(name, componentClass);
    },
    <span class="hljs-title function_" data-zh="1798">getInstance</span>(<span class="hljs-params" data-zh="1799">name</span>) {
      <span class="hljs-keyword" data-zh="1800">if</span> (nameToInstance.<span class="hljs-title function_" data-zh="1801">has</span>(name)) {
        <span class="hljs-keyword" data-zh="1802">return</span> nameToInstance.<span class="hljs-title function_" data-zh="1803">get</span>(name);
      }
      <span class="hljs-keyword" data-zh="1804">const</span> componentClass = nameToClass.<span class="hljs-title function_" data-zh="1805">get</span>(name);
      <span class="hljs-keyword" data-zh="1806">if</span> (componentClass === <span class="hljs-literal" data-zh="1807">undefined</span>) {
        <span class="hljs-keyword" data-zh="1808">throw</span> <span class="hljs-keyword" data-zh="1809">new</span> <span class="hljs-title class_" data-zh="1810">Error</span>(<span class="hljs-string" data-zh="1811">'Unknown component name: '</span> + name);
      }
      <span class="hljs-keyword" data-zh="1812">const</span> inst = <span class="hljs-keyword" data-zh="1813">new</span> <span class="hljs-title function_" data-zh="1814">componentClass</span>();
      nameToInstance.<span class="hljs-title function_" data-zh="1815">set</span>(name, inst);
      <span class="hljs-keyword" data-zh="1816">return</span> inst;
    },
  }; 
  <span class="hljs-keyword" data-zh="1817">function</span> <span class="hljs-title function_" data-zh="1818">inject</span> (<span class="hljs-params" data-zh="1819">_value, {kind, name}</span>) {
    <span class="hljs-keyword" data-zh="1820">if</span> (kind === <span class="hljs-string" data-zh="1821">'field'</span>) {
      <span class="hljs-keyword" data-zh="1822">return</span> <span class="hljs-function" data-zh="1823">() =&gt;</span> registry.<span class="hljs-title function_" data-zh="1824">getInstance</span>(name);
    }
  }
  <span class="hljs-keyword" data-zh="1825">return</span> {registry, inject};
}
</code></pre>
      <h3 id="example-friend-visibility" tabindex="-1" data-zh="1826">Example: “friend”&nbsp;visibility (instance private fields)&nbsp;&nbsp;<a class="heading-anchor" href="#example-friend-visibility" aria-hidden="true" data-zh="1827">#</a></h3>
      <p data-zh="1828">We can change the visibility of some class members by making them private. That prevents them from being accessed publicly. There are more useful kinds of visibility, though. For example, <em data-zh="1829">friend visibility</em> lets a group of <em data-zh="1830">friends</em> (functions, other classes, etc.) access the member.</p>
      <p data-zh="1831">There are many ways in which friends can be specified. In the following example, everyone who has access to <code data-zh="1832">friendName</code>, is a friend of <code data-zh="1833">classWithSecret.#name</code>. The idea is that a module contains classes and functions that collaborate and that there is some instance data that only the collaborators should be able see.</p>
      <pre data-zh="1834"><code class="language-js" data-zh="1835"><span class="hljs-keyword" data-zh="1836">const</span> friendName = <span class="hljs-keyword" data-zh="1837">new</span> <span class="hljs-title class_" data-zh="1838">Friend</span>();

<span class="hljs-keyword" data-zh="1839">class</span> <span class="hljs-title class_" data-zh="1840">ClassWithSecret</span> {
  @friendName.<span class="hljs-property" data-zh="1841">install</span> #name = <span class="hljs-string" data-zh="1842">'Rumpelstiltskin'</span>;
  <span class="hljs-title function_" data-zh="1843">getName</span>(<span class="hljs-params" data-zh="1844"></span>) {
    <span class="hljs-keyword" data-zh="1845">return</span> <span class="hljs-variable language_" data-zh="1846">this</span>.#name;
  }
}

<span class="hljs-comment" data-zh="1847">// Everyone who has access to `secret`, can access inst.#name</span>
<span class="hljs-keyword" data-zh="1848">const</span> inst = <span class="hljs-keyword" data-zh="1849">new</span> <span class="hljs-title class_" data-zh="1850">ClassWithSecret</span>();
assert.<span class="hljs-title function_" data-zh="1851">equal</span>(
  friendName.<span class="hljs-title function_" data-zh="1852">get</span>(inst), <span class="hljs-string" data-zh="1853">'Rumpelstiltskin'</span>
);
friendName.<span class="hljs-title function_" data-zh="1854">set</span>(inst, <span class="hljs-string" data-zh="1855">'Joe'</span>);
assert.<span class="hljs-title function_" data-zh="1856">equal</span>(
  inst.<span class="hljs-title function_" data-zh="1857">getName</span>(), <span class="hljs-string" data-zh="1858">'Joe'</span>
);
</code></pre>
      <p data-zh="1859">This is how class <code data-zh="1860">Friend</code> is implemented:</p>
      <pre data-zh="1861"><code class="language-js" data-zh="1862"><span class="hljs-keyword" data-zh="1863">class</span> <span class="hljs-title class_" data-zh="1864">Friend</span> {
  #access = <span class="hljs-literal" data-zh="1865">undefined</span>;
  #<span class="hljs-title function_" data-zh="1866">getAccessOrThrow</span>(<span class="hljs-params" data-zh="1867"></span>) {
    <span class="hljs-keyword" data-zh="1868">if</span> (<span class="hljs-variable language_" data-zh="1869">this</span>.#access === <span class="hljs-literal" data-zh="1870">undefined</span>) {
      <span class="hljs-keyword" data-zh="1871">throw</span> <span class="hljs-keyword" data-zh="1872">new</span> <span class="hljs-title class_" data-zh="1873">Error</span>(<span class="hljs-string" data-zh="1874">'The friend decorator wasn’t used yet'</span>);
    }
    <span class="hljs-keyword" data-zh="1875">return</span> <span class="hljs-variable language_" data-zh="1876">this</span>.#access;
  }
  <span class="hljs-comment" data-zh="1877">// An instance property whose value is a function whose `this`</span>
  <span class="hljs-comment" data-zh="1878">// is fixed (bound to the instance).</span>
  install = <span class="hljs-function" data-zh="1879">(<span class="hljs-params" data-zh="1880">_value, {kind, access}</span>) =&gt;</span> {
    <span class="hljs-keyword" data-zh="1881">if</span> (kind === <span class="hljs-string" data-zh="1882">'field'</span>) {
      <span class="hljs-keyword" data-zh="1883">if</span> (<span class="hljs-variable language_" data-zh="1884">this</span>.#access) {
        <span class="hljs-keyword" data-zh="1885">throw</span> <span class="hljs-keyword" data-zh="1886">new</span> <span class="hljs-title class_" data-zh="1887">Error</span>(<span class="hljs-string" data-zh="1888">'This decorator can only be used once'</span>);
      }
      <span class="hljs-variable language_" data-zh="1889">this</span>.#access = access;
    }
  }
  <span class="hljs-title function_" data-zh="1890">get</span>(<span class="hljs-params" data-zh="1891">inst</span>) {
    <span class="hljs-keyword" data-zh="1892">return</span> <span class="hljs-variable language_" data-zh="1893">this</span>.#<span class="hljs-title function_" data-zh="1894">getAccessOrThrow</span>().<span class="hljs-property" data-zh="1895">get</span>.<span class="hljs-title function_" data-zh="1896">call</span>(inst);
  }
  <span class="hljs-title function_" data-zh="1897">set</span>(<span class="hljs-params" data-zh="1898">inst, value</span>) {
    <span class="hljs-keyword" data-zh="1899">return</span> <span class="hljs-variable language_" data-zh="1900">this</span>.#<span class="hljs-title function_" data-zh="1901">getAccessOrThrow</span>().<span class="hljs-property" data-zh="1902">set</span>.<span class="hljs-title function_" data-zh="1903">call</span>(inst, value);
  }
}
</code></pre>
      <h3 id="example%3A-enums-(static-public-fields)" tabindex="-1" data-zh="1904">Example: enums (static public fields)&nbsp;&nbsp;<a class="heading-anchor" href="#example%3A-enums-(static-public-fields)" aria-hidden="true" data-zh="1905">#</a></h3>
      <p data-zh="1906">There are many ways to implement enums. An OOP-style approach is to use a class and static properties (<a href="https://2ality.com/2016/01/enumify.html" data-zh="1907">more information on this approach</a>):</p>
      <pre data-zh="1908"><code class="language-js" data-zh="1909"><span class="hljs-keyword" data-zh="1910">class</span> <span class="hljs-title class_" data-zh="1911">Color</span> {
  <span class="hljs-keyword" data-zh="1912">static</span> red = <span class="hljs-keyword" data-zh="1913">new</span> <span class="hljs-title class_" data-zh="1914">Color</span>(<span class="hljs-string" data-zh="1915">'red'</span>);
  <span class="hljs-keyword" data-zh="1916">static</span> green = <span class="hljs-keyword" data-zh="1917">new</span> <span class="hljs-title class_" data-zh="1918">Color</span>(<span class="hljs-string" data-zh="1919">'green'</span>);
  <span class="hljs-keyword" data-zh="1920">static</span> blue = <span class="hljs-keyword" data-zh="1921">new</span> <span class="hljs-title class_" data-zh="1922">Color</span>(<span class="hljs-string" data-zh="1923">'blue'</span>);
  <span class="hljs-title function_" data-zh="1924">constructor</span>(<span class="hljs-params" data-zh="1925">enumKey</span>) {
    <span class="hljs-variable language_" data-zh="1926">this</span>.<span class="hljs-property" data-zh="1927">enumKey</span> = enumKey;
  }
  <span class="hljs-title function_" data-zh="1928">toString</span>(<span class="hljs-params" data-zh="1929"></span>) {
    <span class="hljs-keyword" data-zh="1930">return</span> <span class="hljs-string" data-zh="1931">`Color(<span class="hljs-subst" data-zh="1932">${<span class="hljs-variable language_" data-zh="1933">this</span>.enumKey}</span>)`</span>;
  }
}
assert.<span class="hljs-title function_" data-zh="1934">equal</span>(
  <span class="hljs-title class_" data-zh="1935">Color</span>.<span class="hljs-property" data-zh="1936">green</span>.<span class="hljs-title function_" data-zh="1937">toString</span>(),
  <span class="hljs-string" data-zh="1938">'Color(green)'</span>
);
</code></pre>
      <p data-zh="1939">We can use a decorator to automatically:</p>
      <ul data-zh="1940">
        <li data-zh="1941">Create a Map from “enum keys” (the names of their fields) to enum values.</li>
        <li data-zh="1942">Add enum keys to enum values – without having to pass them to the constructor.</li>
      </ul>
      <p data-zh="1943">That looks as follows:</p>
      <pre data-zh="1944"><code class="language-js" data-zh="1945"><span class="hljs-keyword" data-zh="1946">function</span> <span class="hljs-title function_" data-zh="1947">enumEntry</span>(<span class="hljs-params" data-zh="1948">value, {kind, name}</span>) {
  <span class="hljs-keyword" data-zh="1949">if</span> (kind === <span class="hljs-string" data-zh="1950">'field'</span>) {
    <span class="hljs-keyword" data-zh="1951">return</span> <span class="hljs-keyword" data-zh="1952">function</span> (<span class="hljs-params" data-zh="1953">initialValue</span>) {
      <span class="hljs-keyword" data-zh="1954">if</span> (!<span class="hljs-title class_" data-zh="1955">Object</span>.<span class="hljs-title function_" data-zh="1956">hasOwn</span>(<span class="hljs-variable language_" data-zh="1957">this</span>, <span class="hljs-string" data-zh="1958">'enumFields'</span>)) {
        <span class="hljs-variable language_" data-zh="1959">this</span>.<span class="hljs-property" data-zh="1960">enumFields</span> = <span class="hljs-keyword" data-zh="1961">new</span> <span class="hljs-title class_" data-zh="1962">Map</span>();
      }
      <span class="hljs-variable language_" data-zh="1963">this</span>.<span class="hljs-property" data-zh="1964">enumFields</span>.<span class="hljs-title function_" data-zh="1965">set</span>(name, initialValue);
      initialValue.<span class="hljs-property" data-zh="1966">enumKey</span> = name;
      <span class="hljs-keyword" data-zh="1967">return</span> initialValue;
    };
  }
}

<span class="hljs-keyword" data-zh="1968">class</span> <span class="hljs-title class_" data-zh="1969">Color</span> {
  @enumEntry <span class="hljs-keyword" data-zh="1970">static</span> red = <span class="hljs-keyword" data-zh="1971">new</span> <span class="hljs-title class_" data-zh="1972">Color</span>();
  @enumEntry <span class="hljs-keyword" data-zh="1973">static</span> green = <span class="hljs-keyword" data-zh="1974">new</span> <span class="hljs-title class_" data-zh="1975">Color</span>();
  @enumEntry <span class="hljs-keyword" data-zh="1976">static</span> blue = <span class="hljs-keyword" data-zh="1977">new</span> <span class="hljs-title class_" data-zh="1978">Color</span>();
  <span class="hljs-title function_" data-zh="1979">toString</span>(<span class="hljs-params" data-zh="1980"></span>) {
    <span class="hljs-keyword" data-zh="1981">return</span> <span class="hljs-string" data-zh="1982">`Color(<span class="hljs-subst" data-zh="1983">${<span class="hljs-variable language_" data-zh="1984">this</span>.enumKey}</span>)`</span>;
  }
}
assert.<span class="hljs-title function_" data-zh="1985">equal</span>(
  <span class="hljs-title class_" data-zh="1986">Color</span>.<span class="hljs-property" data-zh="1987">green</span>.<span class="hljs-title function_" data-zh="1988">toString</span>(),
  <span class="hljs-string" data-zh="1989">'Color(green)'</span>
);
assert.<span class="hljs-title function_" data-zh="1990">deepEqual</span>(
  <span class="hljs-title class_" data-zh="1991">Color</span>.<span class="hljs-property" data-zh="1992">enumFields</span>,
  <span class="hljs-keyword" data-zh="1993">new</span> <span class="hljs-title class_" data-zh="1994">Map</span>([
    [<span class="hljs-string" data-zh="1995">'red'</span>, <span class="hljs-title class_" data-zh="1996">Color</span>.<span class="hljs-property" data-zh="1997">red</span>],
    [<span class="hljs-string" data-zh="1998">'green'</span>, <span class="hljs-title class_" data-zh="1999">Color</span>.<span class="hljs-property" data-zh="2000">green</span>],
    [<span class="hljs-string" data-zh="2001">'blue'</span>, <span class="hljs-title class_" data-zh="2002">Color</span>.<span class="hljs-property" data-zh="2003">blue</span>],
  ])
);
</code></pre>
      <h2 id="auto-accessors" tabindex="-1" data-zh="2004">Auto-accessors: a new member of class definitions&nbsp;&nbsp;<a class="heading-anchor" href="#auto-accessors" aria-hidden="true" data-zh="2005">#</a></h2>
      <p data-zh="2006">The decorators proposal introduces a new language feature: <em data-zh="2007">auto-accessors</em>. An auto-accessor is created by putting the keyword <code data-zh="2008">accessor</code> before a class field. It is used like a field but implemented differently at runtime. That helps decorators as we’ll see soon. This is what auto-accessors look like:</p>
      <pre data-zh="2009"><code class="language-js" data-zh="2010"><span class="hljs-keyword" data-zh="2011">class</span> <span class="hljs-title class_" data-zh="2012">C</span> {
  <span class="hljs-keyword" data-zh="2013">static</span> accessor myField1;
  <span class="hljs-keyword" data-zh="2014">static</span> accessor #myField2;
  accessor myField3;
  accessor #myField4;
}
</code></pre>
      <p data-zh="2015">How do fields and auto-accessors differ?</p>
      <ul data-zh="2016">
        <li data-zh="2017">A field creates either:
          <ul data-zh="2018">
            <li data-zh="2019">Properties (static or instance)</li>
            <li data-zh="2020">Private slots (static or instance)</li>
          </ul>
        </li>
        <li data-zh="2021">An auto-accessor creates a private slot (static or instance) for the data and:
          <ul data-zh="2022">
            <li data-zh="2023">A public getter-setter pair (static or prototype)</li>
            <li data-zh="2024">A private getter-setter pair (static or instance)
              <ul data-zh="2025">
                <li data-zh="2026">Private slots are not inherited and therefore never located in prototypes.</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <p data-zh="2027">Consider the following class:</p>
      <pre data-zh="2028"><code class="language-js" data-zh="2029"><span class="hljs-keyword" data-zh="2030">class</span> <span class="hljs-title class_" data-zh="2031">C</span> {
  accessor str = <span class="hljs-string" data-zh="2032">'abc'</span>;
}
<span class="hljs-keyword" data-zh="2033">const</span> inst = <span class="hljs-keyword" data-zh="2034">new</span> <span class="hljs-title function_" data-zh="2035">C</span>();
assert.<span class="hljs-title function_" data-zh="2036">equal</span>(
  inst.<span class="hljs-property" data-zh="2037">str</span>, <span class="hljs-string" data-zh="2038">'abc'</span>
);
inst.<span class="hljs-property" data-zh="2039">str</span> = <span class="hljs-string" data-zh="2040">'def'</span>;
assert.<span class="hljs-title function_" data-zh="2041">equal</span>(
  inst.<span class="hljs-property" data-zh="2042">str</span>, <span class="hljs-string" data-zh="2043">'def'</span>
);
</code></pre>
      <p data-zh="2044">Internally, it looks like this:</p>
      <pre data-zh="2045"><code class="language-js" data-zh="2046"><span class="hljs-keyword" data-zh="2047">class</span> <span class="hljs-title class_" data-zh="2048">C</span> {
  #str = <span class="hljs-string" data-zh="2049">'abc'</span>;
  <span class="hljs-keyword" data-zh="2050">get</span> <span class="hljs-title function_" data-zh="2051">str</span>() {
    <span class="hljs-keyword" data-zh="2052">return</span> <span class="hljs-variable language_" data-zh="2053">this</span>.#str;
  }
  <span class="hljs-keyword" data-zh="2054">set</span> <span class="hljs-title function_" data-zh="2055">str</span>(<span class="hljs-params" data-zh="2056">value</span>) {
    <span class="hljs-variable language_" data-zh="2057">this</span>.#str = value;
  }
}
</code></pre>
      <p data-zh="2058">The following code shows where the getters and setters of auto-accessors are located:</p>
      <pre data-zh="2059"><code class="language-js" data-zh="2060"><span class="hljs-keyword" data-zh="2061">class</span> <span class="hljs-title class_" data-zh="2062">C</span> {
  <span class="hljs-keyword" data-zh="2063">static</span> accessor myField1;
  <span class="hljs-keyword" data-zh="2064">static</span> accessor #myField2;
  accessor myField3;
  accessor #myField4;

  <span class="hljs-keyword" data-zh="2065">static</span> {
    <span class="hljs-comment" data-zh="2066">// Static getter and setter</span>
    assert.<span class="hljs-title function_" data-zh="2067">ok</span>(
      <span class="hljs-title class_" data-zh="2068">Object</span>.<span class="hljs-title function_" data-zh="2069">hasOwn</span>(C, <span class="hljs-string" data-zh="2070">'myField1'</span>), <span class="hljs-string" data-zh="2071">'myField1'</span>
    );
    <span class="hljs-comment" data-zh="2072">// Static getter and setter</span>
    assert.<span class="hljs-title function_" data-zh="2073">ok</span>(
      #myField2 <span class="hljs-keyword" data-zh="2074">in</span> C, <span class="hljs-string" data-zh="2075">'#myField2'</span>
    );

    <span class="hljs-comment" data-zh="2076">// Prototype getter and setter</span>
    assert.<span class="hljs-title function_" data-zh="2077">ok</span>(
      <span class="hljs-title class_" data-zh="2078">Object</span>.<span class="hljs-title function_" data-zh="2079">hasOwn</span>(C.<span class="hljs-property" data-zh="2080"><span class="hljs-keyword" data-zh="2081">prototype</span></span>, <span class="hljs-string" data-zh="2082">'myField3'</span>), <span class="hljs-string" data-zh="2083">'myField3'</span>
    );
    <span class="hljs-comment" data-zh="2084">// Private getter and setter</span>
    <span class="hljs-comment" data-zh="2085">// (stored in instances, but shared between instances)</span>
    assert.<span class="hljs-title function_" data-zh="2086">ok</span>(
      #myField4 <span class="hljs-keyword" data-zh="2087">in</span> <span class="hljs-keyword" data-zh="2088">new</span> <span class="hljs-title function_" data-zh="2089">C</span>(), <span class="hljs-string" data-zh="2090">'#myField4'</span>
    );
  }
}
</code></pre>
      <p data-zh="2091">For more information on why the slots of private getters, private setters and private methods are stored in instances, see <a href="https://exploringjs.com/js/book/ch_classes.html#private-methods-accessors" data-zh="2092">section “Private methods and accessors”</a> in “Exploring JavaScript”.</p>
      <h3 id="why-are-auto-accessors-needed%3F" tabindex="-1" data-zh="2093">Why are auto-accessors needed?&nbsp;&nbsp;<a class="heading-anchor" href="#why-are-auto-accessors-needed%3F" aria-hidden="true" data-zh="2094">#</a></h3>
      <p data-zh="2095">Auto-accessors are needed by decorators:</p>
      <ul data-zh="2096">
        <li data-zh="2097">They can only influence the values fields are initialized with.</li>
        <li data-zh="2098">But they can completely replace auto-accessors.</li>
      </ul>
      <p data-zh="2099">Therefore, we have to use auto-accessors instead of fields whenever a decorator needs more control than it has with fields.</p>
      <h2 id="class-auto-accessor-decorators" tabindex="-1" data-zh="2100">Class auto-accessor decorators&nbsp;&nbsp;<a class="heading-anchor" href="#class-auto-accessor-decorators" aria-hidden="true" data-zh="2101">#</a></h2>
      <p data-zh="2102">Class auto-accessor decorators have the following type signature:</p>
      <pre data-zh="2103"><code class="language-ts" data-zh="2104"><span class="hljs-keyword" data-zh="2105">type</span> <span class="hljs-title class_" data-zh="2106">ClassAutoAccessorDecorator</span> = <span class="hljs-function" data-zh="2107">(<span class="hljs-params" data-zh="2108">
  <span class="hljs-attr" data-zh="2109">value</span>: {
    get: () =&gt; <span class="hljs-built_in" data-zh="2110">unknown</span>;
    set: (value: <span class="hljs-built_in" data-zh="2111">unknown</span>) =&gt; <span class="hljs-built_in" data-zh="2112">void</span>;
  },
  <span class="hljs-attr" data-zh="2113">context</span>: {
    kind: <span class="hljs-string" data-zh="2114">'accessor'</span>;
    name: <span class="hljs-built_in" data-zh="2115">string</span> | <span class="hljs-built_in" data-zh="2116">symbol</span>;
    <span class="hljs-keyword" data-zh="2117">static</span>: <span class="hljs-built_in" data-zh="2118">boolean</span>;
    <span class="hljs-keyword" data-zh="2119">private</span>: <span class="hljs-built_in" data-zh="2120">boolean</span>;
    access: { get: () =&gt; <span class="hljs-built_in" data-zh="2121">unknown</span>, set: (value: <span class="hljs-built_in" data-zh="2122">unknown</span>) =&gt; <span class="hljs-built_in" data-zh="2123">void</span> };
    addInitializer(initializer: () =&gt; <span class="hljs-built_in" data-zh="2124">void</span>): <span class="hljs-built_in" data-zh="2125">void</span>;
  }
</span>) =&gt;</span> {
  <span class="hljs-attr" data-zh="2126">get</span>?: <span class="hljs-function" data-zh="2127">() =&gt;</span> <span class="hljs-built_in" data-zh="2128">unknown</span>;
  <span class="hljs-attr" data-zh="2129">set</span>?: <span class="hljs-function" data-zh="2130">(<span class="hljs-params" data-zh="2131"><span class="hljs-attr" data-zh="2132">value</span>: <span class="hljs-built_in" data-zh="2133">unknown</span></span>) =&gt;</span> <span class="hljs-built_in" data-zh="2134">void</span>;
  <span class="hljs-attr" data-zh="2135">init</span>?: <span class="hljs-function" data-zh="2136">(<span class="hljs-params" data-zh="2137"><span class="hljs-attr" data-zh="2138">initialValue</span>: <span class="hljs-built_in" data-zh="2139">unknown</span></span>) =&gt;</span> <span class="hljs-built_in" data-zh="2140">unknown</span>;
} | <span class="hljs-built_in" data-zh="2141">void</span>;
</code></pre>
      <p data-zh="2142">Abilities of an auto-accessor decorator:</p>
      <ul data-zh="2143">
        <li data-zh="2144">It receives the getter and the setter of the auto-accessor via its parameter <code data-zh="2145">value</code>.
          <ul data-zh="2146">
            <li data-zh="2147"><code data-zh="2148">context.access</code> provides the same functionality.</li>
          </ul>
        </li>
        <li data-zh="2149">It can replace the decorated auto-accessor by returning an object with the methods <code data-zh="2150">.get()</code> and/or <code data-zh="2151">.set()</code>.</li>
        <li data-zh="2152">It can influence the initial value of the auto-accessor by returning an object with the method <code data-zh="2153">.init()</code>.</li>
        <li data-zh="2154">It can register initializers.</li>
      </ul>
      <h3 id="read-only-auto-accessors" tabindex="-1" data-zh="2155">Example: read-only auto-accessors&nbsp;&nbsp;<a class="heading-anchor" href="#read-only-auto-accessors" aria-hidden="true" data-zh="2156">#</a></h3>
      <p data-zh="2157">We have already implemented <a href="#read-only-fields" data-zh="2158">a decorator <code data-zh="2159">@readOnly</code> for fields</a>. Let’s do the same for auto-accessors:</p>
      <pre data-zh="2160"><code class="language-js" data-zh="2161"><span class="hljs-keyword" data-zh="2162">const</span> <span class="hljs-variable constant_" data-zh="2163">UNINITIALIZED</span> = <span class="hljs-title class_" data-zh="2164">Symbol</span>(<span class="hljs-string" data-zh="2165">'UNINITIALIZED'</span>);
<span class="hljs-keyword" data-zh="2166">function</span> <span class="hljs-title function_" data-zh="2167">readOnly</span>(<span class="hljs-params" data-zh="2168">{get,set}, {name, kind}</span>) {
  <span class="hljs-keyword" data-zh="2169">if</span> (kind === <span class="hljs-string" data-zh="2170">'accessor'</span>) {
    <span class="hljs-keyword" data-zh="2171">return</span> {
      <span class="hljs-title function_" data-zh="2172">init</span>(<span class="hljs-params" data-zh="2173"></span>) {
        <span class="hljs-keyword" data-zh="2174">return</span> <span class="hljs-variable constant_" data-zh="2175">UNINITIALIZED</span>;
      },
      <span class="hljs-title function_" data-zh="2176">get</span>(<span class="hljs-params" data-zh="2177"></span>) {
        <span class="hljs-keyword" data-zh="2178">const</span> value = get.<span class="hljs-title function_" data-zh="2179">call</span>(<span class="hljs-variable language_" data-zh="2180">this</span>);
        <span class="hljs-keyword" data-zh="2181">if</span> (value === <span class="hljs-variable constant_" data-zh="2182">UNINITIALIZED</span>) {
          <span class="hljs-keyword" data-zh="2183">throw</span> <span class="hljs-keyword" data-zh="2184">new</span> <span class="hljs-title class_" data-zh="2185">TypeError</span>(
            <span class="hljs-string" data-zh="2186">`Accessor <span class="hljs-subst" data-zh="2187">${name}</span> hasn’t been initialized yet`</span>
          );
        }
        <span class="hljs-keyword" data-zh="2188">return</span> value;
      },
      <span class="hljs-title function_" data-zh="2189">set</span>(<span class="hljs-params" data-zh="2190">newValue</span>) {
        <span class="hljs-keyword" data-zh="2191">const</span> oldValue = get.<span class="hljs-title function_" data-zh="2192">call</span>(<span class="hljs-variable language_" data-zh="2193">this</span>);
        <span class="hljs-keyword" data-zh="2194">if</span> (oldValue !== <span class="hljs-variable constant_" data-zh="2195">UNINITIALIZED</span>) {
          <span class="hljs-keyword" data-zh="2196">throw</span> <span class="hljs-keyword" data-zh="2197">new</span> <span class="hljs-title class_" data-zh="2198">TypeError</span>(
            <span class="hljs-string" data-zh="2199">`Accessor <span class="hljs-subst" data-zh="2200">${name}</span> can only be set once`</span>
          );
        }
        set.<span class="hljs-title function_" data-zh="2201">call</span>(<span class="hljs-variable language_" data-zh="2202">this</span>, newValue);
      },
    };
  }
}

<span class="hljs-keyword" data-zh="2203">class</span> <span class="hljs-title class_" data-zh="2204">Color</span> {
  @readOnly
  accessor name;
  <span class="hljs-title function_" data-zh="2205">constructor</span>(<span class="hljs-params" data-zh="2206">name</span>) {
    <span class="hljs-variable language_" data-zh="2207">this</span>.<span class="hljs-property" data-zh="2208">name</span> = name;
  }
}

<span class="hljs-keyword" data-zh="2209">const</span> blue = <span class="hljs-keyword" data-zh="2210">new</span> <span class="hljs-title class_" data-zh="2211">Color</span>(<span class="hljs-string" data-zh="2212">'blue'</span>);
assert.<span class="hljs-title function_" data-zh="2213">equal</span>(blue.<span class="hljs-property" data-zh="2214">name</span>, <span class="hljs-string" data-zh="2215">'blue'</span>);
assert.<span class="hljs-title function_" data-zh="2216">throws</span>(
  <span class="hljs-function" data-zh="2217">() =&gt;</span> blue.<span class="hljs-property" data-zh="2218">name</span> = <span class="hljs-string" data-zh="2219">'yellow'</span>,
  <span class="hljs-regexp" data-zh="2220">/^TypeError: Accessor name can only be set once$/</span>
);

<span class="hljs-keyword" data-zh="2221">const</span> orange = <span class="hljs-keyword" data-zh="2222">new</span> <span class="hljs-title class_" data-zh="2223">Color</span>(<span class="hljs-string" data-zh="2224">'orange'</span>);
assert.<span class="hljs-title function_" data-zh="2225">equal</span>(orange.<span class="hljs-property" data-zh="2226">name</span>, <span class="hljs-string" data-zh="2227">'orange'</span>);
</code></pre>
      <p data-zh="2228">Compared to the field version, this decorator has one considerable advantage: It does not need to wrap the class to ensure that the decorated constructs become read-only.</p>
      <h2 id="faq" tabindex="-1" data-zh="2229">Frequently asked questions&nbsp;&nbsp;<a class="heading-anchor" href="#faq" aria-hidden="true" data-zh="2230">#</a></h2>
      <h3 id="function-decorators" tabindex="-1" data-zh="2231">Why can’t functions be decorated?&nbsp;&nbsp;<a class="heading-anchor" href="#function-decorators" aria-hidden="true" data-zh="2232">#</a></h3>
      <p data-zh="2233">The current proposal focuses on classes as a starting point. <a href="#more-decorator-related-proposals" data-zh="2234">Decorators for function expressions were proposed.</a> However, there hasn’t been much progress since then and there is no proposal for function <em data-zh="2235">declarations</em>.</p>
      <p data-zh="2236">On the other hand, functions are relatively easy to decorate “manually”:</p>
      <pre data-zh="2237"><code class="language-js" data-zh="2238"><span class="hljs-keyword" data-zh="2239">const</span> decoratedFunc = <span class="hljs-title function_" data-zh="2240">decorator</span>(<span class="hljs-function" data-zh="2241">(<span class="hljs-params" data-zh="2242">x, y</span>) =&gt;</span> {});
</code></pre>
      <p data-zh="2243">This looks even better with <a href="https://2ality.com/2022/01/pipe-operator.html" data-zh="2244">the proposed pipeline operator</a>:</p>
      <pre data-zh="2245"><code class="language-js" data-zh="2246"><span class="hljs-keyword" data-zh="2247">const</span> <span class="hljs-title function_" data-zh="2248">decoratedFunc</span> = (<span class="hljs-params" data-zh="2249">x, y</span>) =&gt; {} |&gt; <span class="hljs-title function_" data-zh="2250">decorator</span>(%);
</code></pre>
      <h2 id="more-decorator-related-proposals" tabindex="-1" data-zh="2251">More decorator-related proposals&nbsp;&nbsp;<a class="heading-anchor" href="#more-decorator-related-proposals" aria-hidden="true" data-zh="2252">#</a></h2>
      <p data-zh="2253">The following ECMAScript proposals provide more decorator-related features:</p>
      <ul data-zh="2254">
        <li data-zh="2255">Stage 2: <a href="https://github.com/tc39/proposal-decorator-metadata" data-zh="2256">“Decorator Metadata”</a> by Chris Garrett (last update: 2022-04-11)
          <ul data-zh="2257">
            <li data-zh="2258">Quote: “This proposal seeks to extend the Decorators proposal by adding the ability for decorators to associate metadata with the value being decorated.”</li>
          </ul>
        </li>
        <li data-zh="2259">Stage 0: <a href="https://docs.google.com/document/d/1ikxIP5-RVYq6d_f8lAvf3pKC00W78ueyp-xIZ6q67uU" data-zh="2260">“Function Expression Decorators”</a> by Igor Minar (last update: 2016-01-25)</li>
        <li data-zh="2261">Stage 0: <a href="https://docs.google.com/document/d/1Qpkqf_8NzAwfD8LdnqPjXAQ2wwh8BBUGynhn-ZlCWT0" data-zh="2262">“Method Parameter Decorators”</a> by Igor Minar (last update: 2016-01-25)</li>
      </ul>
      <h2 id="resources" tabindex="-1" data-zh="2263">Resources&nbsp;&nbsp;<a class="heading-anchor" href="#resources" aria-hidden="true" data-zh="2264">#</a></h2>
      <h3 id="decorator-implementations" tabindex="-1" data-zh="2265">Implementations&nbsp;&nbsp;<a class="heading-anchor" href="#decorator-implementations" aria-hidden="true" data-zh="2266">#</a></h3>
      <ul data-zh="2267">
        <li data-zh="2268">Babel currently has the best support for stage 3 decorators, via <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators" data-zh="2269"><code data-zh="2270">@babel/plugin-proposal-decorators</code></a>.
          <ul data-zh="2271">
            <li data-zh="2272">Be sure to pick <a href="https://babeljs.io/docs/en/babel-plugin-proposal-decorators#version" data-zh="2273">the latest decorator version</a>.</li>
            <li data-zh="2274">All the code in this blog post was developed via Babel.</li>
          </ul>
        </li>
        <li data-zh="2275">TypeScript currently supports stage 1 decorators behind a flag.
          <ul data-zh="2276">
            <li data-zh="2277">There is <a href="https://github.com/microsoft/TypeScript/pull/50820" data-zh="2278">a pull request by Ron Buckton</a> that supports stage 3 decorators and will likely ship in the release after TypeScript 4.9.</li>
          </ul>
        </li>
      </ul>
      <h3 id="libraries-with-decorators" tabindex="-1" data-zh="2279">Libraries with decorators&nbsp;&nbsp;<a class="heading-anchor" href="#libraries-with-decorators" aria-hidden="true" data-zh="2280">#</a></h3>
      <p data-zh="2281">These are libraries with decorators. They currently only support stage 1 decorators but can serve as inspirations for what’s possible:</p>
      <ul data-zh="2282">
        <li data-zh="2283"><a href="https://github.com/jayphelps/core-decorators.js" data-zh="2284">core-decorators.js</a> by Jay Phelps (targets Babel)</li>
        <li data-zh="2285"><a href="https://github.com/NetanelBasal/helpful-decorators" data-zh="2286">“Helpful Decorators For TypeScript Projects”</a> by Netanel Basal</li>
      </ul>
      <h2 id="acknowledgements" tabindex="-1" data-zh="2287">Acknowledgements&nbsp;&nbsp;<a class="heading-anchor" href="#acknowledgements" aria-hidden="true" data-zh="2288">#</a></h2>
      <ul data-zh="2289">
        <li data-zh="2290">Thanks to Chris Garrett for answering my questions about decorators.</li>
      </ul>
      <h2 id="further-reading" tabindex="-1" data-zh="2291">Further reading&nbsp;&nbsp;<a class="heading-anchor" href="#further-reading" aria-hidden="true" data-zh="2292">#</a></h2>
      <ul data-zh="2293">
        <li data-zh="2294">
          <p data-zh="2295"><a href="https://exploringjs.com/js/book/ch_callables.html" data-zh="2296">Chapter “Callable values”</a> [ordinary functions, arrow functions, classes, methods] in “Exploring JavaScript”</p>
        </li>
        <li data-zh="2297">
          <p data-zh="2298"><a href="https://exploringjs.com/js/book/ch_classes.html" data-zh="2299">Chapter “Classes”</a> in “Exploring JavaScript”</p>
        </li>
      </ul>
    </div>
  </div>

</body>

</html>

</html>